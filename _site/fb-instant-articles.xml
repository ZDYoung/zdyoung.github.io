<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title></title>
    <link>http://localhost:4000</link>
    <description>
      A simple, beautiful theme for Jekyll that emphasizes content rather than aesthetic fluff.
    </description>
    
        
            <item>
                <title>RunLoop小记</title>
                <link>http://localhost:4000/objective-c/runloop/2017/05/09/RunLoop%E5%B0%8F%E8%AE%B0/</link>
                <content:encoded>
                    <![CDATA[
                    <p>标签： objective-c RunLoop</p>

<hr />

<h2 id="前言">前言</h2>

<p>本文主要从RunLoop是什么，如何使用RunLoop，它和线程之间的关系以及在编程中可能用到的地方来介绍RunLoop。现在CoreFoundation开源了，你可以在<a href="http://opensource.apple.com/tarballs/CF/">这里</a>下载源码。</p>

<h2 id="正文">正文</h2>

<p>RunLoop是什么？从名字上看，它是一个loop而且是一个带条件的，同时又是一个”死循环”，但是它又很特殊，在没有事干的时候，这个循环处于闲等待的状态。写一个死循环容易：</p>
<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="p">{</span>

<span class="p">}</span>
</code></pre>
</div>
<p>如果RunLoop是这样做的话，那么也就没什么值研究的了。所以说它是一种带条件的循环，那么又是什么条件呢？那就是消息或者事件，RunLoop是一个基于消息的循环。当没有消息的时候，它就会进入休眠，内核会将其挂起也就是：我睡觉了，没事别叫我。当有消息来的时候就加入到这个循环里时，内核就会将其唤醒，然后对消息进行处理，也就是：睡你XX，起来嗨。比如：点击了屏幕，滚动了scrollView，这些都是消息。形象一点就是：</p>
<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="err">程序员</span> <span class="o">=</span> <span class="err">死了没</span><span class="p">();</span>
<span class="k">while</span><span class="p">(</span><span class="err">程序员</span><span class="p">)</span>
<span class="p">{</span>
    <span class="err">有事干了</span> <span class="o">=</span> <span class="err">我睡觉了没事别叫我</span><span class="p">();</span>
    <span class="k">if</span><span class="p">(</span><span class="err">该搬砖了</span><span class="p">){</span>
        <span class="err">搬砖</span><span class="p">();</span>
    <span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="err">该吃饭了</span><span class="p">){</span>
        <span class="err">吃饭</span><span class="p">();</span>
    <span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="err">该陪妹子了</span><span class="p">){</span>
        <span class="err">@</span><span class="n">throw</span><span class="p">(</span><span class="err">你没妹子</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>RunLoop是和线程配合使用的，一般来说一个线程执行用来执行一个任务，执行完之后就会退出。当我们启动应用程序的时候，默认启动了一个主线程，所有的UI界面都是运行在主线程里的。但是启动后应用程序并不会马上就退出，而是一直运行在那里，等待用户的输入。正常情况下，应该是启动完成后，就会退出。正是RunLoop，才使得应用程序一直运行着。线程刚创建的时候并没有RunLoop（主线程除外），如果不去主动获取。RunLoop的创建发生在第一次获取时，销毁发生在线程结束时。用户只能在一个线程内部获取其RunLoop（主线程除外）。</p>

<p>如何像主线程一样，让我们创建的线程成为常驻线程，当有任务的时候，就交线这个线程去执行。后面的例子中会提到。</p>

<h3 id="runloop工作">RunLoop工作</h3>

<p>先来看看，在我们启动一个应用程序的时候，观察一下主线程的RunLoop的状态。首先说一下，RunLoop的工作的mode：</p>
<ul>
  <li>
    <font color="#FF6100">NSDefaultRunLoopMode</font>
    <p>RunLoop的默认Mode，空闲状态，也就是什么也不干的时候。</p>
  </li>
  <li>
    <font color="#FF6100">UITrackingRunLoopMode</font>
    <p>有滑动等其它需要追踪的事件发生时，RunLoop处于此Mode，比如在滚动scrollView时。</p>
  </li>
  <li>
    <font color="#FF6100">NSInitializationRunLoopMode</font>
    <p>这是一个Private RunLoopMode，App启动时处于此Mode，启动完成进入App主界面后App处于NSDefaultRunLoopMode</p>
  </li>
  <li>
    <font color="#FF6100">NSRunLoopCommonModes</font>
    <p>此Mode默认包含了NSDefaultRunLoopMode和UITrackingRunLoopMode。所以，当RunLoop运行在NSDefaultRunLoopMode或UITrackingRunLoopMode时，监听NSRunLoopCommonModes的Observer都会被回调。另外，还可以向NSRunLoopCommonModes里添加其它自定义的Mode。</p>
  </li>
</ul>

<p>每个mode下面又有timer，source和observer。timer是基于时间的触发器，我们在创建timer完的时候一定要把timer放进当前线程的RunLoop中，如果不是主线程还要将这个RunLoop启动，不然这个timer是不会触发的。source是事件产生的地方，系统提供了两个版本，也可以自定义source：</p>
<ul>
  <li>
    <font color="#FF6100">source0</font>
    <p>处理App内部事件(特指non-port-based事件，这里的事件是一个广义的事件，包括但不限于UI事件)，App负责管理自己的事件触发，如：UIEvent(Touch事件等，GS发起到RunLoop运行再到事件回调到UI)、CFSocketRef.</p>
  </li>
  <li>
    <font color="#FF6100">source1</font>
    <p>由RunLoop和内核管理，由Mach port驱动（特指port-based事件），如CFMachPort、CFMessagePort、NSSocketPort。特别要注意一下Mach port的概念，它是一个轻量级的进程间通讯的方式，可以理解为它是一个通讯通道，假如同时有几个进程都挂在这个通道上，那么其它进程向这个通道发送消息后，这些挂在这个通道上的进程都可以收到相应的消息。这个Port的概念非常重要，因为它是RunLoop休眠和被唤醒的关键，它是RunLoop与系统内核进行消息通讯的窗口。</p>
  </li>
</ul>

<p>observe是用来监听RunLoop的状态的，RunLoop有以下几种状态：</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="cm">/* Run Loop Observer Activities */</span>
<span class="k">typedef</span> <span class="nf">CF_OPTIONS</span><span class="p">(</span><span class="n">CFOptionFlags</span><span class="p">,</span> <span class="n">CFRunLoopActivity</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">kCFRunLoopEntry</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span> <span class="c1">//InputSource/Timer已经加入到RunLoop了
</span>    <span class="n">kCFRunLoopBeforeTimers</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span> <span class="c1">//Timer即将要被执行了
</span>    <span class="n">kCFRunLoopBeforeSources</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">),</span> <span class="c1">//InputSource即将要被执行了
</span>    <span class="n">kCFRunLoopBeforeWaiting</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">),</span> <span class="c1">//RunLoop即将休眠了
</span>    <span class="n">kCFRunLoopAfterWaiting</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">),</span> <span class="c1">//RunLoop即将被唤醒
</span>    <span class="n">kCFRunLoopExit</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">),</span> <span class="c1">//RunLoop停止运转了
</span>    <span class="n">kCFRunLoopAllActivities</span> <span class="o">=</span> <span class="mh">0x0FFFFFFFU</span>
<span class="p">}</span>
</code></pre>
</div>
<p>可以看到前四个描述了一个RunLoop的循环周期。</p>

<p>这里得说一下NSAutoreleasePool，先来看看官方文档中怎么说的：</p>
<blockquote>
  <p>The Application Kit creates an autorelease pool on the main thread at the beginning of every cycle of the event loop, and drains it at the end, thereby releasing any autoreleased objects generated while processing an event. If you use the Application Kit, you therefore typically don’t have to create your own pools. If your application creates a lot of temporary autoreleased objects within the event loop, however, it may be beneficial to create “local” autorelease pools to help to minimize the peak memory footprint.</p>
</blockquote>

<p>意思是说，应用程序在主线程开始的每个事件循环周期中创建一个自动释放池，在这个循环周期结束的时候，把自动释放池排干，即把注册到自动释放池里的对象全部释放掉。之前笔者一直不太明白，自动释放池是怎么释放对象的。说完了来让我们试验一波：</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="c1">//ViewController.m
</span><span class="k">@interface</span> <span class="nc">ViewController</span> <span class="p">()</span>
<span class="c1">//注意label的内存管理语义，用weak也可以，不过weak在赋完值后，输出不了正确结果后面会解释
</span><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">assign</span><span class="p">)</span> <span class="n">UILabel</span> <span class="o">*</span><span class="n">label</span><span class="p">;</span>
<span class="k">@end</span>
<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">viewDidLoad</span>
<span class="p">{</span>
    <span class="p">[</span><span class="n">super</span> <span class="nf">viewDidLoad</span><span class="p">];</span>
    
    <span class="c1">//创建子线程执行任务
</span>    <span class="n">self</span><span class="p">.</span><span class="kr">thread</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSThread</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">initWithTarget</span><span class="p">:</span><span class="n">self</span> <span class="nf">selector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">run</span><span class="p">)</span> <span class="n">object</span><span class="o">:</span><span class="nb">nil</span><span class="p">];</span>
    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="kr">thread</span> <span class="nf">setName</span><span class="p">:</span><span class="s">@"com.thread"</span><span class="p">];</span>
    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="kr">thread</span> <span class="nf">start</span><span class="p">];</span>

<span class="p">}</span>
<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">addRunLoopObserver</span>
<span class="p">{</span>
    
    <span class="c1">//添加RunLoop监听,需要使用CFRunLoop，因为NSRunloop没有这个功能
</span>    
    <span class="c1">//1.获取runloop
</span>    <span class="n">CFRunLoopRef</span> <span class="n">runLoop</span> <span class="o">=</span> <span class="n">CFRunLoopGetCurrent</span><span class="p">();</span>
    
    <span class="c1">//2.1创建上下文
</span>    <span class="n">CFRunLoopObserverContext</span> <span class="n">context</span> <span class="o">=</span> <span class="p">{</span>
        
        <span class="mi">0</span><span class="p">,</span> <span class="c1">//这个context的版本
</span>        <span class="p">(</span><span class="n">__bridge</span> <span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">self</span><span class="p">),</span> <span class="c1">//传入的参数，这里我传入控制器
</span>        <span class="n">CFRetain</span><span class="p">,</span> <span class="c1">//告诉它retain是调用哪个函数
</span>        <span class="n">CFRelease</span><span class="p">,</span> <span class="c1">//告诉它release是调用哪个函数
</span>        <span class="nb">nil</span><span class="p">,</span>
    <span class="p">};</span>
    
    <span class="c1">//2.2创建runloop观察者
</span>    <span class="cm">/*
     CFRunLoopObserverRef CFRunLoopObserverCreate(CFAllocatorRef allocator,
     CFOptionFlags activities,
     Boolean repeats,
     CFIndex order,
     CFRunLoopObserverCallBack callout,
     CFRunLoopObserverContext *context);
     
     @param allocator：这个参数用来分配空间给新的对象。默认情况下使用NULL或者kCFAllocatorDefault。
     @param activities：设置Runloop的运行阶段的标志，当运行到此阶段时，CFRunLoopObserver会被调用
     @param repeats：CFRunLoopObserver是否循环调用，false为单词调用，否则循环调用。
     @param order：CFRunLoopObserver的优先级，当在Runloop同一运行阶段中有多个CFRunLoopObserver时，根据这个来先后调用CFRunLoopObserver。正常情况下使用0。
     @param callout：回调函数
     @param context：CFRunLoopObserver结构体里面的一个结构体，它主要用来给回调函数传递消息的。
     @return CFRunLoopObserverRef：观察者指针对象
     */</span>
    <span class="n">CFRunLoopObserverRef</span> <span class="n">observer</span> <span class="o">=</span> <span class="n">CFRunLoopObserverCreate</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span>
                                                            <span class="n">kCFRunLoopBeforeWaiting</span><span class="p">,</span>
                                                            <span class="nb">YES</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                                                            <span class="n">callBack</span><span class="p">,</span>
                                                            <span class="o">&amp;</span><span class="n">context</span><span class="p">);</span>
    
    <span class="c1">//3.给runloop添加观察者
</span>    <span class="n">CFRunLoopAddObserver</span><span class="p">(</span><span class="n">runLoop</span><span class="p">,</span> <span class="n">observer</span><span class="p">,</span> <span class="n">kCFRunLoopCommonModes</span><span class="p">);</span>
    
<span class="p">}</span>


<span class="cm">/**
 回调函数,在kCFRunLoopBeforeWaiting（runloop等待执行循环之前）情况下调用，因为定时器给的是0.1秒，所以这里调用非常频繁，保证一次循环执行一个任务
 
 @param observer 观察者对象
 @param activity Runloop的运行阶段的标志
 @param info CFRunLoopObserverContext传入的参数
 */</span>
<span class="kt">void</span> <span class="n">callBack</span><span class="p">(</span><span class="n">CFRunLoopObserverRef</span> <span class="n">observer</span><span class="p">,</span> <span class="n">CFRunLoopActivity</span> <span class="n">activity</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
    
    <span class="c1">//1.拿到传过来的参数，再进行转换,因为这是C函数，不能直接调用self，所以在添加观察的时候把self传过来。
</span>    <span class="n">ViewController</span> <span class="o">*</span><span class="n">vc</span> <span class="o">=</span> <span class="p">(</span><span class="n">__bridge</span> <span class="n">ViewController</span> <span class="o">*</span><span class="p">)(</span><span class="n">info</span><span class="p">);</span>
    
    <span class="c1">//2.看看我们刚才设置的label，在这个循环同期内是否有值，可以看到是有值的。
</span>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"%@"</span><span class="p">,</span><span class="n">vc</span><span class="p">.</span><span class="n">label</span><span class="p">.</span><span class="n">text</span><span class="p">);</span>
<span class="p">}</span>
<span class="o">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">run</span>
<span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"跑起来"</span><span class="p">);</span>
    <span class="err">@autoreleasepool</span> <span class="p">{</span>
        <span class="n">self</span><span class="p">.</span><span class="n">label</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UILabel</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">init</span><span class="p">];</span>
        <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">label</span> <span class="nf">setText</span><span class="p">:</span><span class="s">@"这是一个标签"</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="c1">//默认情况下,子线程是不会常驻的
</span>    <span class="c1">//只有子线程中runloop启动,并且runloop中有source或timer,才会常驻
</span>    <span class="c1">//只有常驻线程才能再次执行任务,因为线程中有runloop来处理事件了
</span>    <span class="n">NSRunLoop</span> <span class="o">*</span> <span class="n">rl</span> <span class="o">=</span>  <span class="p">[</span><span class="n">NSRunLoop</span> <span class="nf">currentRunLoop</span><span class="p">];</span>
    
    <span class="c1">//向线程添加一个port，这样可以维持线程，使其成为常驻线程，当然也可以添加一个timer/source像这样
</span>    <span class="c1">//[NSTimer scheduledTimerWithTimeInterval:2 target:self selector:@selector(timerRun) userInfo:nil repeats:YES];
</span>    <span class="p">[</span><span class="n">rl</span> <span class="nf">addPort</span><span class="p">:[</span><span class="n">NSMachPort</span> <span class="nf">port</span><span class="p">]</span> <span class="nf">forMode</span><span class="p">:</span><span class="n">NSDefaultRunLoopMode</span><span class="p">];</span>

    <span class="c1">//添加RunLoopObserver
</span>    <span class="p">[</span><span class="n">self</span> <span class="nf">addRunLoopObserver</span><span class="p">];</span>

    <span class="c1">//启动runloop
</span>    <span class="p">[</span><span class="n">rl</span> <span class="nf">run</span><span class="p">];</span>
    
    <span class="c1">//如果线程成为了常驻线程,你会发现,不会执行到这行代码
</span>    <span class="c1">//也就是说这个方法不会执行完,
</span>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"end"</span><span class="p">);</span>
<span class="p">}</span>
<span class="o">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">timerRun</span>
<span class="p">{</span>
    <span class="c1">//这时不干事，只是用来维持子线程，timer的时间也可以用来设置循环同期的时候，
</span><span class="p">}</span>
<span class="o">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">touchesBegan</span><span class="o">:</span><span class="p">(</span><span class="n">NSSet</span><span class="o">&lt;</span><span class="n">UITouch</span> <span class="o">*&gt;</span> <span class="o">*</span><span class="p">)</span><span class="n">touches</span> <span class="n">withEvent</span><span class="o">:</span><span class="p">(</span><span class="n">UIEvent</span> <span class="o">*</span><span class="p">)</span><span class="n">event</span>
<span class="p">{</span>
    <span class="c1">// 让子线程再次执行任务
</span>    <span class="p">[</span><span class="n">self</span> <span class="nf">performSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">againRun</span><span class="p">)</span> <span class="nf">onThread</span><span class="p">:</span><span class="n">self</span><span class="p">.</span><span class="kr">thread</span> <span class="n">withObject</span><span class="o">:</span><span class="nb">nil</span> <span class="n">waitUntilDone</span><span class="o">:</span><span class="nb">NO</span><span class="p">];</span>
<span class="p">}</span>
<span class="o">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">againRun</span>
<span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"再次跑起来"</span><span class="p">);</span>
    <span class="c1">//下面这行是停止当前线程的RunLoop，这个方法是在我们创建的子线程中不是主线程，加上这一行，再跑一次看看会有什么结果
//    CFRunLoopStop(CFRunLoopGetCurrent());
</span><span class="p">}</span>
</code></pre>
</div>
<p>这把段代码跑一次，输出的结果为：</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="mi">2017</span><span class="o">-</span><span class="mo">05</span><span class="o">-</span><span class="mi">09</span> <span class="mi">11</span><span class="o">:</span><span class="mi">37</span><span class="o">:</span><span class="mi">51</span><span class="p">.</span><span class="mi">134</span> <span class="n">copy</span><span class="p">[</span><span class="mi">92859</span><span class="o">:</span><span class="mi">12314616</span><span class="p">]</span> <span class="err">跑起来</span>
<span class="mi">2017</span><span class="o">-</span><span class="mo">05</span><span class="o">-</span><span class="mi">09</span> <span class="mi">11</span><span class="o">:</span><span class="mi">37</span><span class="o">:</span><span class="mi">51</span><span class="p">.</span><span class="mi">159</span> <span class="n">copy</span><span class="p">[</span><span class="mi">92859</span><span class="o">:</span><span class="mi">12314616</span><span class="p">]</span> <span class="err">这是一个标签</span>
</code></pre>
</div>
<p>当点击屏幕的时候，会在我们创建的线程内执行一次方法<code class="highlighter-rouge">againRun</code>，执行完后，RunLoop就进入了休眠，这时是第二个循环周期，label已经被释放了，所以程序就会因为访问已释放的内存而崩掉。还有一点label的内存管理语义这里设定的为assgin，设置weak的时候也可以但是输也不了正确的结果，通过断点调试的时候确实可以看到当label的内存管理语义为weak的时候，它是有值的，这条语句执行完后<code class="highlighter-rouge">self.label = [[UILabel alloc] init];</code>，label并没有马上释放掉，因为自动释放池延迟了它的释放，正常情况下，赋值完就会立该释放，但这里得不到正确的结果，笔者猜想肯定编译器做了手脚。大家可以将label的内存管理语义改为weak，再跑一次看看。</p>

<h3 id="runloop对timer的影响">RunLoop对timer的影响</h3>

<p>先来看一个例子：</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="c1">//ViewController.m
</span><span class="cp">#import "ViewController.h"
</span>
<span class="k">@interface</span> <span class="nc">ViewController</span> <span class="p">()</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">weak</span><span class="p">,</span> <span class="n">nonatomic</span><span class="p">)</span> <span class="n">IBOutlet</span> <span class="n">UIScrollView</span> <span class="o">*</span><span class="n">scrollView</span><span class="p">;</span>

<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">ViewController</span>

<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">viewDidLoad</span> <span class="p">{</span>
    <span class="p">[</span><span class="n">super</span> <span class="nf">viewDidLoad</span><span class="p">];</span>
    <span class="c1">// Do any additional setup after loading the view, typically from a nib.
</span>    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">scrollView</span> <span class="nf">setContentSize</span><span class="p">:</span><span class="n">CGSizeMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)];</span>
    <span class="n">self</span><span class="p">.</span><span class="n">scrollView</span><span class="p">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>
    <span class="n">NSTimer</span> <span class="o">*</span><span class="n">timer1</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSTimer</span> <span class="nf">timerWithTimeInterval</span><span class="p">:</span><span class="mi">2</span> <span class="nf">target</span><span class="p">:</span><span class="n">self</span> <span class="n">selector</span><span class="o">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">doTimer1</span><span class="p">)</span> <span class="n">userInfo</span><span class="o">:</span><span class="nb">nil</span> <span class="n">repeats</span><span class="o">:</span><span class="nb">YES</span><span class="p">];</span>
    <span class="p">[[</span><span class="n">NSRunLoop</span> <span class="nf">currentRunLoop</span><span class="p">]</span> <span class="nf">addTimer</span><span class="p">:</span><span class="n">timer1</span> <span class="nf">forMode</span><span class="p">:</span><span class="n">NSDefaultRunLoopMode</span><span class="p">];</span>
<span class="p">}</span>
<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">scrollViewDidScroll</span><span class="o">:</span><span class="p">(</span><span class="n">UIScrollView</span> <span class="o">*</span><span class="p">)</span><span class="n">scrollView</span>
<span class="p">{</span>
     <span class="n">NSLog</span><span class="p">(</span><span class="s">@"%@"</span><span class="p">,(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">CFBridgingRelease</span><span class="p">(</span><span class="n">CFRunLoopCopyCurrentMode</span><span class="p">(</span><span class="n">CFRunLoopGetCurrent</span><span class="p">())));</span>
<span class="p">}</span>
<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">touchesBegan</span><span class="o">:</span><span class="p">(</span><span class="n">NSSet</span><span class="o">&lt;</span><span class="n">UITouch</span> <span class="o">*&gt;</span> <span class="o">*</span><span class="p">)</span><span class="n">touches</span> <span class="n">withEvent</span><span class="o">:</span><span class="p">(</span><span class="n">UIEvent</span> <span class="o">*</span><span class="p">)</span><span class="n">event</span>
<span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"%@"</span><span class="p">,(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">CFBridgingRelease</span><span class="p">(</span><span class="n">CFRunLoopCopyCurrentMode</span><span class="p">(</span><span class="n">CFRunLoopGetCurrent</span><span class="p">())));</span>
    
<span class="p">}</span>
<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">touchesMoved</span><span class="o">:</span><span class="p">(</span><span class="n">NSSet</span><span class="o">&lt;</span><span class="n">UITouch</span> <span class="o">*&gt;</span> <span class="o">*</span><span class="p">)</span><span class="n">touches</span> <span class="n">withEvent</span><span class="o">:</span><span class="p">(</span><span class="n">UIEvent</span> <span class="o">*</span><span class="p">)</span><span class="n">event</span>
<span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"%@"</span><span class="p">,(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">CFBridgingRelease</span><span class="p">(</span><span class="n">CFRunLoopCopyCurrentMode</span><span class="p">(</span><span class="n">CFRunLoopGetCurrent</span><span class="p">())));</span>
<span class="p">}</span>
<span class="o">-</span> <span class="p">(</span><span class="n">IBAction</span><span class="p">)</span><span class="n">button</span><span class="o">:</span><span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="n">sender</span>
<span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"%@"</span><span class="p">,(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">CFBridgingRelease</span><span class="p">(</span><span class="n">CFRunLoopCopyCurrentMode</span><span class="p">(</span><span class="n">CFRunLoopGetCurrent</span><span class="p">())));</span>
<span class="p">}</span>
<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">doTimer1</span>
<span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"timer go"</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">@end</span>
</code></pre>
</div>
<p>当程序跑起来什么也不干就会每隔一秒，控制台输入一个timer go，但是如果我们不停的滑动scrollView，控制台就停止输出了。因为这个timer运行在NSDefaultRunLoopMode下，只有当RunLoop在这个mode下才会执行timer，当程序运行的时候，我们没做任何事，Runloop就处在这个mode下，等待用户的输入。但是当我们滑动scrollView时，RunLoop由NSDefaultRunLoopMode转到了UITrackingRunLoopMode下，就不会执行timer了。在点击按钮，滑动scrollView,点击屏幕和移动屏幕中可以看到mode的变化。</p>

<h2 id="总结">总结</h2>

<p>最后以一个RunLoop的应用场景结束本文。在有UITableView的控制器里，滑动UITableView加载图片时，主线程会把图片设置到cell上，如果这时你同时又滑动tableView，会因为主线程同时设置图片和滑动而造成到卡顿的现象。知道了RunLoop后，在滑动的时候，让子线程去处理网络请求，当停止滑动的时候，这时RunLoop进入到了NSDefaultRunLoopMode下，这时让主线程去设置图片。这样实现的话，代码只有一句：</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="n">UIImage</span> <span class="o">*</span><span class="n">downloadImage</span> <span class="o">=</span> <span class="p">.....</span>
<span class="p">[</span><span class="n">self</span> <span class="nf">performSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nf">setImage</span><span class="p">:)</span> <span class="n">withObject</span><span class="o">:</span><span class="n">downloadImage</span> <span class="n">afterDelay</span><span class="o">:</span><span class="mi">0</span> <span class="n">inModes</span><span class="o">:</span><span class="n">NSDefaultRunLoopMode</span><span class="p">];</span>
</code></pre>
</div>

<p>–EOF–
<!-- 下次研究CFRunLoop中的CFRunLoopTimer和CFRunLoopSource --></p>

<h2 id="参考">参考</h2>
<ul>
  <li><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1">Threading Programming Guide – iOS Developer Library</a></li>
  <li><a href="http://v.youku.com/v_show/id_XODgxODkzODI0.html">视频: iOS线下分享《RunLoop》by 孙源@sunnyxx</a></li>
  <li><a href="http://blog.ibireme.com/2015/05/18/runloop/">深入理解RunLoop</a></li>
  <li><a href="http://blog.handy.wang/blog/2014/05/26/runloopxue-xi-bi-ji-1/">RunLoop学习笔记</a></li>
</ul>

                    ]]>
                </content:encoded>
                <guid isPermaLink="false">/objective-c/runloop/2017/05/09/RunLoop%E5%B0%8F%E8%AE%B0/</guid>
                <description>
                    
                    RunLoop实际上是一个消息循环，用于处理消息的，只不过它是一种带条件的循环。
                    
                </description>
                <pubDate>Tue, 09 May 2017 00:00:00 +0800</pubDate>
                <author>冬阳</author>
            </item>
        
    
        
            <item>
                <title>oc中的黑魔法attribute</title>
                <link>http://localhost:4000/objective-c/attribute/2017/05/06/oc%E4%B8%AD%E7%9A%84%E9%BB%91%E9%AD%94%E6%B3%95attribute/</link>
                <content:encoded>
                    <![CDATA[
                    <p>标签： objective-c attribute</p>

<hr />

<h2 id="前言">前言</h2>

<p>__attribute__其实是一个编译器指令，用于指定一些声明中特性包括函数声明和变量声明，这样一来可以编译器可以执行一些错误检查或是进行一些高级的优化。说的直白一点就是对声明加一点限制，拿函数而言，可以用__attribute__来限制形参不为空，这样一来，可以保证在编程的过程，函数调用形参一定是不为空的。这只是其中一个用法。这个指令对于编写框架以及更新框架用的多，在实际的编程中用的不多，下面列出的都是一些用法。</p>

<h2 id="正文">正文</h2>

<p>对这个指令还比较陌生的程序员，那么在编程时候，肯定遇到过这样的情况：当调用一人API时，编译器发出警告说这个API在某某版本中已经被废弃，现在用某某API代替。这其实就是__attribute__的一种用法。</p>

<h4 id="用法">用法</h4>

<p>__attribute__后面是由两组圆括号，括号内的属性由逗号分割，该指令放在函数，变量和类型声明之后。</p>

<p>1.<font color="#FF6100">__attribute__((cleanup(...)))</font>，用于修饰一个变量，在它的作用域结束时可以自动执行一个指定的方法，如：</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="c1">// 指定一个cleanup方法，注意入参是所修饰变量的地址，类型要一样
// 对于指向objc对象的指针(id *)，如果不强制声明__strong默认是__autoreleasing，造成类型不匹配
</span><span class="k">static</span> <span class="kt">void</span> <span class="n">stringCleanUp</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">__strong</span> <span class="o">*</span><span class="n">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"%@"</span><span class="p">,</span> <span class="o">*</span><span class="n">string</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// 在某个方法中：
</span><span class="p">{</span>
     <span class="n">NSString</span> <span class="o">*</span><span class="n">__strong</span> <span class="n">string</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">cleanup</span><span class="p">(</span><span class="n">stringCleanUp</span><span class="p">)))</span> <span class="o">=</span> <span class="s">@"hello"</span><span class="p">;</span>
<span class="p">}</span> <span class="c1">// 当运行到这个作用域结束时，自动调用stringCleanUp
</span></code></pre>
</div>
<p>所谓作用域结束，包括大括号结束、return、goto、break、exception等各种情况。
当然，可以修饰的变量不止NSString，自定义Class或基本类型都是可以的。</p>

<p>这个指令可以修饰变量，当然也就可以修饰block：</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="c1">// void(^block)(void)的指针是void(^*block)(void)
</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">blockCleanUp</span><span class="p">(</span><span class="n">__strong</span> <span class="kt">void</span><span class="p">(</span><span class="o">^*</span><span class="n">block</span><span class="p">)(</span><span class="kt">void</span><span class="p">))</span> <span class="p">{</span>
    <span class="p">(</span><span class="o">*</span><span class="n">block</span><span class="p">)();</span>
<span class="p">}</span>
</code></pre>
</div>
<p>然后我们在一个作用域里来定义一个block变量：</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="p">{</span>
   <span class="c1">// 加了个`unused`的attribute用来消除`unused variable`的warning
</span>    <span class="n">__strong</span> <span class="kt">void</span><span class="p">(</span><span class="o">^</span><span class="n">block</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">cleanup</span><span class="p">(</span><span class="n">blockCleanUp</span><span class="p">),</span> <span class="n">unused</span><span class="p">))</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@"I'm dying..."</span><span class="p">);</span>
    <span class="p">};</span>
<span class="p">}</span> <span class="c1">//执行完这一行后就会输出"I'm dying..."
</span></code></pre>
</div>

<p>2.<font color="#FF6100">__attribute__((noreturn))</font>，它用于指定函数是不允许有返回值的。</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">noReturn</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="n">noreturn</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"hello"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>
<p>这个笔者没用到过。</p>

<p>3.<font color="#FF6100">__attribute__((deprecated))</font>,这个可能是大家见的最多了，苹果也经常干这个事，每隔一两个版本可能就会有那么几个API被废弃，然后提示我们用哪个API代替，在编译的时候就会发出警告。</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">deprecatedMethodWithMessage</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="n">deprecated</span><span class="p">(</span><span class="s">"this method was deprecated in MyApp.app version 5.0.2, use newMethod instead"</span><span class="p">)))</span>
<span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"his method was deprecated in MyApp.app version 5.0.2, use newMethod instead"</span><span class="p">);</span>
<span class="p">}</span><span class="c1">//调用这个方法的时候会发出警告信息，deprecated后面的参数可要可不要。
</span></code></pre>
</div>

<p>4.<font color="#FF6100">__attribute__((warn_unused_result))</font></p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">printMsg</span><span class="p">:(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">str</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">warn_unused_result</span><span class="p">))</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">str</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//这样调用这个函数会报警告信息,提示用户返回值没有被使用，在一些返回值很重要的函数里，这个很有用
</span><span class="p">[</span><span class="n">self</span> <span class="nf">printMsg</span><span class="p">:</span><span class="s">@"msg"</span><span class="p">];</span>
</code></pre>
</div>

<p>5.<font color="#FF6100">__attribute__((unavailable))</font>，这个和deprecated有很大的不一样，如果对函数加上这个，那么这个函数是禁止使用的。</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="n">init</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">unavailable</span><span class="p">(</span><span class="s">"这个函数不能用！"</span><span class="p">)));</span>
</code></pre>
</div>
<p>如果强行使用这个函数，编译是通不过的。这一种做法可禁止使用默认的初始化方法生成类的实例对象，只能使用用户提供的初始化方法。</p>

<p>6.<font color="#FF6100">__attribute__((overloadable))</font>，这个可以用来实现函数的重载。这里先来说一下两个概念：重载和覆盖。</p>
<ol>
  <li>
    <p>重载：它作用域是在一个类里面，函数名相同，参数不同（参数类型不同，或者参数个数不同），virtual关键字可有可无。</p>
  </li>
  <li>
    <p>覆盖：作用域不同，一个是在基类中一个是在派生类中，参数相同（参数个数和类型均相同），基类函数必须有virtual关键字（派生类可有可无，因为基类函数被声明为虚函数，派生类同名函数一定也是虚函数）</p>
  </li>
</ol>

<p>知道这个两个概念的区别，那么来讲讲objective-c，在这门语言中，是没有重载这个机制的，但是可以覆盖。使用overloadable后可以实现重载，但是不能像c++那样重载实例方法，只能重载c/c++的函数：</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="c1">//调用以下函数时和c/c++调用的语法一样
</span><span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">)</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">overloadable</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"Add Int %i"</span><span class="p">,</span><span class="n">num</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span> <span class="n">num</span><span class="p">)</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">overloadable</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"Add NSString %@"</span><span class="p">,</span><span class="n">num</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="n">NSNumber</span> <span class="o">*</span> <span class="n">num</span><span class="p">)</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">overloadable</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"Add NSNumber %@"</span><span class="p">,</span><span class="n">num</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<p>7.<font color="#FF6100">__attribute__((objc_subclassing_restricted))</font>，在类的声明文件中加入这一行，表示这个类，不能被继承，就是java类中的final类。如果试图去继承这个类，编译会报错：</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="c1">//customClass.h
</span><span class="n">__attribute__</span><span class="p">((</span><span class="n">objc_subclassing_restricted</span><span class="p">))</span>
<span class="k">@interface</span> <span class="nc">customClass</span> <span class="p">:</span> <span class="nc">NSObject</span>
</code></pre>
</div>

<p>8.<font color="#FF6100">__attribute__((objc_designated_initializer))</font>,这个用于类的初始化方法。对于对象而言，在生成一个实例的时候，如果需要提供必要的信息来完成初始化，才能使该对象正确的完成后面的工作，这种初始化方法叫”全能初始化方法”(designated initializer)。如果创建一个类的方法有多种，相应的，这个类便会有多个初始化方法。如果这些初始化分别初始化类中不同的属性时，那么在实际使用的过程中，当一使用同一个对象，做同一件事的时候，创建对象使用的是不同的初始化方法，那么问题会视后面具体的事出现不同的问题，有些可能不会造成很大的影响，有些可能会造成重大灾难。在《Effectvie objective-c 2.0》，条款16当中有详细的说明。具体的做法是指定一个全能初始化方法，让其他初始化方法去调用这个全能初始化方法。使用objc_designated_initializer还要注意，当存在继承的时候，子类在初始化时要调用父类的全能初始化方法，完成初始化，否则编译器会给出警告信息。</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="c1">//Rectangle.h
</span><span class="k">@interface</span> <span class="nc">Rectangle</span> <span class="p">:</span> <span class="nc">NSObject</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">assign</span><span class="p">,</span> <span class="n">readonly</span><span class="p">)</span> <span class="kt">float</span> <span class="n">width</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">assign</span><span class="p">,</span> <span class="n">readonly</span><span class="p">)</span> <span class="kt">float</span> <span class="n">heigth</span><span class="p">;</span>
<span class="k">-</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="nf">initWithWidth</span><span class="p">:(</span><span class="kt">float</span><span class="p">)</span> <span class="n">width</span> <span class="n">heigth</span><span class="o">:</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span> <span class="n">heigth</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">objc_designated_initializer</span><span class="p">));</span>
<span class="k">-</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="n">init</span> <span class="p">;</span>
<span class="k">@end</span>
<span class="c1">//Rectangle.m
</span><span class="k">@implementation</span> <span class="nc">Rectangle</span>
<span class="k">-</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="nf">initWithWidth</span><span class="p">:(</span><span class="kt">float</span><span class="p">)</span> <span class="n">width</span> <span class="n">heigth</span><span class="o">:</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span> <span class="n">heigth</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">self</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="nf">init</span><span class="p">])</span> <span class="p">{</span>
        <span class="n">_width</span> <span class="o">=</span> <span class="n">width</span><span class="p">;</span>
        <span class="n">_heigth</span> <span class="o">=</span> <span class="n">heigth</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
<span class="p">}</span>
<span class="o">-</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="n">init</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">self</span> <span class="nf">initWithWidth</span><span class="p">:</span><span class="mi">5</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span> <span class="nf">heigth</span><span class="p">:</span><span class="mi">5</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">];</span>
<span class="p">}</span>
<span class="k">@end</span>
</code></pre>
</div>

<p>9.<font color="#FF6100">__attribute__((objc_requires_super))</font>，这个指令表示在子类重写方法时，必须在调用父类中的方法，不然后会给出警告。</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="c1">//Base.h
</span><span class="k">@interface</span> <span class="nc">Base</span> <span class="p">:</span> <span class="nc">NSObject</span>
<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">method1</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">objc_requires_super</span><span class="p">));</span>
<span class="k">@end</span>
<span class="c1">//Base.m
</span><span class="k">@implementation</span> <span class="nc">Base</span>
<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">method1</span>
<span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"Base"</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">@end</span>
<span class="c1">//Derived.h
</span><span class="k">@interface</span> <span class="nc">Derived</span> <span class="p">:</span> <span class="nc">NSObject</span>

<span class="k">@end</span>
<span class="c1">//Derived.m
</span><span class="k">@implementation</span> <span class="nc">Derived</span>
<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">method1</span>
<span class="p">{</span>
    <span class="p">[</span><span class="n">super</span> <span class="nf">method1</span><span class="p">];</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"Derived"</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">@end</span>
</code></pre>
</div>

<p>10.<font color="#FF6100">__attribute__((nonnull))</font>，这个表示函数参数不为空，由编译器检查。</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">testNonnull</span><span class="p">:(</span><span class="n">id</span><span class="p">)</span><span class="nv">avg1</span> <span class="nf">avg2</span><span class="p">:(</span><span class="n">id</span><span class="p">)</span><span class="nv">avg2</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">nonnull</span><span class="p">))</span>
<span class="p">{</span>
    <span class="c1">//do something
</span><span class="p">}</span>
<span class="c1">//某个作用域内
</span><span class="p">{</span>
    <span class="p">[</span><span class="n">self</span> <span class="nf">testNonnull</span><span class="p">:</span><span class="nb">nil</span> <span class="nf">avg2</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span><span class="c1">//这样使用时编译器会给出警告
</span><span class="p">}</span>
</code></pre>
</div>

<p><a href="http://www.jianshu.com/p/29eb7b5c8b2d"><strong>attribute</strong> 总结</a></p>

<p><a href="http://blog.sunnyxx.com/2016/05/14/clang-attributes/">Clang Attributes 黑魔法小记</a></p>

<p><a href="http://nshipster.com/__attribute__/"><strong>attribute</strong></a></p>

<p><a href="http://www.aopod.com/2016/08/03/attribute-directives/">__attribute__指令</a></p>

<p><a href="http://www.jianshu.com/p/0237c34158f0">Clang 3.8 documentation</a></p>

<p>–EOF–</p>


                    ]]>
                </content:encoded>
                <guid isPermaLink="false">/objective-c/attribute/2017/05/06/oc%E4%B8%AD%E7%9A%84%E9%BB%91%E9%AD%94%E6%B3%95attribute/</guid>
                <description>
                    
                    attribute是编译器为我们提供的一个指令，在编程过程中善用它能为我们带来意想不到的好处。
                    
                </description>
                <pubDate>Sat, 06 May 2017 00:00:00 +0800</pubDate>
                <author>冬阳</author>
            </item>
        
    
        
            <item>
                <title>AFNetworking3.0源码解读之下载请求</title>
                <link>http://localhost:4000/objective-c/afnetworking/2017/05/05/AFNetworking3.0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%95%B0%E6%8D%AE%E4%B8%8B%E8%BD%BD/</link>
                <content:encoded>
                    <![CDATA[
                    <p>标签： objective-c AFNetworking download</p>

<hr />

<h3 id="前言">前言</h3>

<p>上一篇简单介绍了一下AFURLSessionManager类的结构以及发起一个网络请求的函数调用过程。AFURLSessionManager类中有很多属性，还定义了很多的局部全局变量，在数据请求那大部分用不上。比如，AFURLSessionManager类定义了很多的block:</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">AFURLSessionDidBecomeInvalidBlock</span><span class="p">)(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">);</span>
<span class="k">typedef</span> <span class="n">NSURLSessionAuthChallengeDisposition</span> <span class="p">(</span><span class="o">^</span><span class="n">AFURLSessionDidReceiveAuthenticationChallengeBlock</span><span class="p">)(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="n">NSURLAuthenticationChallenge</span> <span class="o">*</span><span class="n">challenge</span><span class="p">,</span> <span class="n">NSURLCredential</span> <span class="o">*</span> <span class="n">__autoreleasing</span> <span class="o">*</span><span class="n">credential</span><span class="p">);</span>

<span class="k">typedef</span> <span class="n">NSURLRequest</span> <span class="o">*</span> <span class="p">(</span><span class="o">^</span><span class="n">AFURLSessionTaskWillPerformHTTPRedirectionBlock</span><span class="p">)(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="n">NSURLSessionTask</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="n">NSURLResponse</span> <span class="o">*</span><span class="n">response</span><span class="p">,</span> <span class="n">NSURLRequest</span> <span class="o">*</span><span class="n">request</span><span class="p">);</span>
<span class="k">typedef</span> <span class="n">NSURLSessionAuthChallengeDisposition</span> <span class="p">(</span><span class="o">^</span><span class="n">AFURLSessionTaskDidReceiveAuthenticationChallengeBlock</span><span class="p">)(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="n">NSURLSessionTask</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="n">NSURLAuthenticationChallenge</span> <span class="o">*</span><span class="n">challenge</span><span class="p">,</span> <span class="n">NSURLCredential</span> <span class="o">*</span> <span class="n">__autoreleasing</span> <span class="o">*</span><span class="n">credential</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">AFURLSessionDidFinishEventsForBackgroundURLSessionBlock</span><span class="p">)(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="n">session</span><span class="p">);</span>

<span class="k">typedef</span> <span class="n">NSInputStream</span> <span class="o">*</span> <span class="p">(</span><span class="o">^</span><span class="n">AFURLSessionTaskNeedNewBodyStreamBlock</span><span class="p">)(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="n">NSURLSessionTask</span> <span class="o">*</span><span class="n">task</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">AFURLSessionTaskDidSendBodyDataBlock</span><span class="p">)(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="n">NSURLSessionTask</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">bytesSent</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">totalBytesSent</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">totalBytesExpectedToSend</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">AFURLSessionTaskDidCompleteBlock</span><span class="p">)(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="n">NSURLSessionTask</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">);</span>

<span class="k">typedef</span> <span class="n">NSURLSessionResponseDisposition</span> <span class="p">(</span><span class="o">^</span><span class="n">AFURLSessionDataTaskDidReceiveResponseBlock</span><span class="p">)(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="n">NSURLSessionDataTask</span> <span class="o">*</span><span class="n">dataTask</span><span class="p">,</span> <span class="n">NSURLResponse</span> <span class="o">*</span><span class="n">response</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">AFURLSessionDataTaskDidBecomeDownloadTaskBlock</span><span class="p">)(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="n">NSURLSessionDataTask</span> <span class="o">*</span><span class="n">dataTask</span><span class="p">,</span> <span class="n">NSURLSessionDownloadTask</span> <span class="o">*</span><span class="n">downloadTask</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">AFURLSessionDataTaskDidReceiveDataBlock</span><span class="p">)(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="n">NSURLSessionDataTask</span> <span class="o">*</span><span class="n">dataTask</span><span class="p">,</span> <span class="n">NSData</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">typedef</span> <span class="n">NSCachedURLResponse</span> <span class="o">*</span> <span class="p">(</span><span class="o">^</span><span class="n">AFURLSessionDataTaskWillCacheResponseBlock</span><span class="p">)(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="n">NSURLSessionDataTask</span> <span class="o">*</span><span class="n">dataTask</span><span class="p">,</span> <span class="n">NSCachedURLResponse</span> <span class="o">*</span><span class="n">proposedResponse</span><span class="p">);</span>

<span class="k">typedef</span> <span class="n">NSURL</span> <span class="o">*</span> <span class="p">(</span><span class="o">^</span><span class="n">AFURLSessionDownloadTaskDidFinishDownloadingBlock</span><span class="p">)(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="n">NSURLSessionDownloadTask</span> <span class="o">*</span><span class="n">downloadTask</span><span class="p">,</span> <span class="n">NSURL</span> <span class="o">*</span><span class="n">location</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">AFURLSessionDownloadTaskDidWriteDataBlock</span><span class="p">)(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="n">NSURLSessionDownloadTask</span> <span class="o">*</span><span class="n">downloadTask</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">bytesWritten</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">totalBytesWritten</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">totalBytesExpectedToWrite</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">AFURLSessionDownloadTaskDidResumeBlock</span><span class="p">)(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="n">NSURLSessionDownloadTask</span> <span class="o">*</span><span class="n">downloadTask</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">fileOffset</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">expectedTotalBytes</span><span class="p">);</span>

<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">AFURLSessionTaskCompletionHandler</span><span class="p">)(</span><span class="n">NSURLResponse</span> <span class="o">*</span><span class="n">response</span><span class="p">,</span> <span class="n">id</span> <span class="n">responseObject</span><span class="p">,</span> <span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">);</span>
</code></pre>
</div>
<p>这里列出了该类所有的block，有没有很吓人，刚开始看的时候，我也看的头疼，后来调试的时候发现在本文接下来要讲的内容中，只用到了两个分别是AFURLSessionTaskCompletionHandler和AFURLSessionDownloadTaskDidFinishDownloadingBlock，这两个block都是delegate在完成代理后调用的。说明AFURLSessionManager中的block属性打酱油了，那我就很好奇了，既然是打酱油的那还要它干吗？其实不是，我们先来仔细观察一下它们的名字——objective-c的命名都是见名知意的，这一点笔者感觉很不错——以本文的下载为例，AFURLSessionDownloadTaskDidFinishDownloadingBlock意：下载任务完成时的block。那我们怎么去使用这个呢？呆会就讲。</p>

<h2 id="正文">正文</h2>

<p>和上一篇一样还是以官方git上的例子看起，源码如下：</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="n">NSURLSessionConfiguration</span> <span class="o">*</span><span class="n">configuration</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSURLSessionConfiguration</span> <span class="nf">defaultSessionConfiguration</span><span class="p">];</span>
<span class="n">AFURLSessionManager</span> <span class="o">*</span><span class="n">manager</span> <span class="o">=</span> <span class="p">[[</span><span class="n">AFURLSessionManager</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">initWithSessionConfiguration</span><span class="p">:</span><span class="n">configuration</span><span class="p">];</span>

<span class="n">NSURL</span> <span class="o">*</span><span class="n">URL</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSURL</span> <span class="nf">URLWithString</span><span class="p">:</span><span class="s">@"http://img04.tooopen.com/images/20130701/tooopen_10055061.jpg"</span><span class="p">];</span>
<span class="n">NSURLRequest</span> <span class="o">*</span><span class="n">request</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSURLRequest</span> <span class="nf">requestWithURL</span><span class="p">:</span><span class="n">URL</span><span class="p">];</span>

<span class="n">NSURLSessionDownloadTask</span> <span class="o">*</span><span class="n">downloadTask</span> <span class="o">=</span> <span class="p">[</span><span class="n">manager</span> <span class="nf">downloadTaskWithRequest</span><span class="p">:</span><span class="n">request</span> <span class="nf">progress</span><span class="p">:</span><span class="nb">nil</span> <span class="n">destination</span><span class="o">:^</span><span class="n">NSURL</span> <span class="o">*</span><span class="p">(</span><span class="n">NSURL</span> <span class="o">*</span><span class="n">targetPath</span><span class="p">,</span> <span class="n">NSURLResponse</span> <span class="o">*</span><span class="n">response</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">NSURL</span> <span class="o">*</span><span class="n">documentsDirectoryURL</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSFileManager</span> <span class="nf">defaultManager</span><span class="p">]</span> <span class="nf">URLForDirectory</span><span class="p">:</span><span class="n">NSDocumentDirectory</span> <span class="nf">inDomain</span><span class="p">:</span><span class="n">NSUserDomainMask</span> <span class="n">appropriateForURL</span><span class="o">:</span><span class="nb">nil</span> <span class="n">create</span><span class="o">:</span><span class="nb">NO</span> <span class="n">error</span><span class="o">:</span><span class="nb">nil</span><span class="p">];</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">documentsDirectoryURL</span> <span class="nf">URLByAppendingPathComponent</span><span class="p">:[</span><span class="n">response</span> <span class="nf">suggestedFilename</span><span class="p">]];</span>
<span class="p">}</span> <span class="n">completionHandler</span><span class="o">:^</span><span class="p">(</span><span class="n">NSURLResponse</span> <span class="o">*</span><span class="n">response</span><span class="p">,</span> <span class="n">NSURL</span> <span class="o">*</span><span class="n">filePath</span><span class="p">,</span> <span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"File downloaded to: %@"</span><span class="p">,</span> <span class="n">filePath</span><span class="p">);</span>
    <span class="n">self</span><span class="p">.</span><span class="n">imgView</span><span class="p">.</span><span class="n">image</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIImage</span> <span class="nf">imageWithData</span><span class="p">:[</span><span class="n">NSData</span> <span class="nf">dataWithContentsOfURL</span><span class="p">:</span><span class="n">filePath</span><span class="p">]];</span>

<span class="p">}];</span>
<span class="c1">//以下三行是我添加的，下面三行设置了下载完成后的回调
</span><span class="k">typedef</span> <span class="n">NSURL</span> <span class="o">*</span> <span class="p">(</span><span class="o">^</span><span class="n">DownloadTaskDidFinishDownloadingBlock</span><span class="p">)(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="n">NSURLSessionDownloadTask</span> <span class="o">*</span><span class="n">downloadTask</span><span class="p">,</span> <span class="n">NSURL</span> <span class="o">*</span><span class="n">location</span><span class="p">);</span>

<span class="n">id</span> <span class="n">block</span> <span class="o">=</span> <span class="o">^</span><span class="p">(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="n">NSURLSessionDownloadTask</span> <span class="o">*</span><span class="n">downloadTask</span><span class="p">,</span> <span class="n">NSURL</span> <span class="o">*</span><span class="n">location</span><span class="p">){</span>
    <span class="c1">//doing something
</span>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"%@"</span><span class="p">,</span><span class="n">location</span><span class="p">);</span>
<span class="cm">/*
 * 将上面的打印语句注释掉，改成下面的，再运行一次看看会有什么结果？
    NSURL *documentsDirectoryURL = [[NSFileManager defaultManager] URLForDirectory:NSDocumentDirectory inDomain:NSUserDomainMask appropriateForURL:nil create:NO error:nil]; 
        
    return [documentsDirectoryURL URLByAppendingPathComponent:[downloadTask.response suggestedFilename]];
    */</span>
<span class="p">};</span>
<span class="p">[</span><span class="n">manager</span> <span class="nf">setDownloadTaskDidFinishDownloadingBlock</span><span class="p">:</span><span class="n">block</span><span class="p">];</span>


<span class="p">[</span><span class="n">downloadTask</span> <span class="nf">resume</span><span class="p">];</span>

</code></pre>
</div>
<p>这里我在网上随便找了一张图片，然后还设置了manager的一个AFURLSessionDownloadTaskDidFinishDownloadingBlock，就是刚才说那些打酱油中的block中的一个。笔者在这里只是简单的打印了一下location，并没有返回一个路径，注意哦，这个block要返回一个路径的哦，这个路径是用来存放我们下载的图片的。</p>

<p>这里通过manager实例方法来创建downloadTask:</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="n">NSURLSessionDownloadTask</span> <span class="o">*</span><span class="p">)</span><span class="nf">downloadTaskWithRequest</span><span class="p">:(</span><span class="n">NSURLRequest</span> <span class="o">*</span><span class="p">)</span><span class="nv">request</span>
                                             <span class="nf">progress</span><span class="p">:(</span><span class="n">NSProgress</span> <span class="o">*</span> <span class="n">__autoreleasing</span> <span class="o">*</span><span class="p">)</span><span class="nv">progress</span>
                                          <span class="nf">destination</span><span class="p">:(</span><span class="n">NSURL</span> <span class="o">*</span> <span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="n">NSURL</span> <span class="o">*</span><span class="n">targetPath</span><span class="p">,</span> <span class="n">NSURLResponse</span> <span class="o">*</span><span class="n">response</span><span class="p">))</span><span class="nv">destination</span>
                                    <span class="nf">completionHandler</span><span class="p">:(</span><span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="n">NSURLResponse</span> <span class="o">*</span><span class="n">response</span><span class="p">,</span> <span class="n">NSURL</span> <span class="o">*</span><span class="n">filePath</span><span class="p">,</span> <span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">))</span><span class="nv">completionHandler</span>
<span class="p">{</span>
    <span class="n">__block</span> <span class="n">NSURLSessionDownloadTask</span> <span class="o">*</span><span class="n">downloadTask</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
    <span class="n">dispatch_sync</span><span class="p">(</span><span class="n">url_session_manager_creation_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
        <span class="n">downloadTask</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">session</span> <span class="nf">downloadTaskWithRequest</span><span class="p">:</span><span class="n">request</span><span class="p">];</span>
    <span class="p">});</span>
    <span class="c1">//这个是用来设置下载代理的
</span>    <span class="p">[</span><span class="n">self</span> <span class="nf">addDelegateForDownloadTask</span><span class="p">:</span><span class="n">downloadTask</span> <span class="nf">progress</span><span class="p">:</span><span class="n">progress</span> <span class="n">destination</span><span class="o">:</span><span class="n">destination</span> <span class="n">completionHandler</span><span class="o">:</span><span class="n">completionHandler</span><span class="p">];</span>

    <span class="k">return</span> <span class="n">downloadTask</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>
<p>然后又进入到[NSURLSessionManager addDelegateForDownloadTask:progress:destination:completionHandler]这个函数设置了具体的代理对象，以及下载完成后设置了图片存储路径的block，上一篇的数据请求也会进行这一步，但下载比数据请求多了一些东西，让我们来看看多了什么：</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">addDelegateForDownloadTask</span><span class="p">:(</span><span class="n">NSURLSessionDownloadTask</span> <span class="o">*</span><span class="p">)</span><span class="nv">downloadTask</span>
                          <span class="nf">progress</span><span class="p">:(</span><span class="n">NSProgress</span> <span class="o">*</span> <span class="n">__autoreleasing</span> <span class="o">*</span><span class="p">)</span><span class="nv">progress</span>
                       <span class="nf">destination</span><span class="p">:(</span><span class="n">NSURL</span> <span class="o">*</span> <span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="n">NSURL</span> <span class="o">*</span><span class="n">targetPath</span><span class="p">,</span> <span class="n">NSURLResponse</span> <span class="o">*</span><span class="n">response</span><span class="p">))</span><span class="nv">destination</span>
                 <span class="nf">completionHandler</span><span class="p">:(</span><span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="n">NSURLResponse</span> <span class="o">*</span><span class="n">response</span><span class="p">,</span> <span class="n">NSURL</span> <span class="o">*</span><span class="n">filePath</span><span class="p">,</span> <span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">))</span><span class="nv">completionHandler</span>
<span class="p">{</span>
    <span class="n">AFURLSessionManagerTaskDelegate</span> <span class="o">*</span><span class="n">delegate</span> <span class="o">=</span> <span class="p">[[</span><span class="n">AFURLSessionManagerTaskDelegate</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">init</span><span class="p">];</span>
    <span class="n">delegate</span><span class="p">.</span><span class="n">manager</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>
    <span class="n">delegate</span><span class="p">.</span><span class="n">completionHandler</span> <span class="o">=</span> <span class="n">completionHandler</span><span class="p">;</span>
<span class="c1">//downloadTaskDidFinishDownloading -&gt; NSURL * (^AFURLSessionDownloadTaskDidFinishDownloadingBlock)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, NSURL *location);
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">destination</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">delegate</span><span class="p">.</span><span class="n">downloadTaskDidFinishDownloading</span> <span class="o">=</span> <span class="o">^</span><span class="n">NSURL</span> <span class="o">*</span> <span class="p">(</span><span class="n">NSURLSession</span> <span class="o">*</span> <span class="n">__unused</span> <span class="n">session</span><span class="p">,</span> <span class="n">NSURLSessionDownloadTask</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="n">NSURL</span> <span class="o">*</span><span class="n">location</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">destination</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">task</span><span class="p">.</span><span class="n">response</span><span class="p">);</span>
        <span class="p">};</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">progress</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">progress</span> <span class="o">=</span> <span class="n">delegate</span><span class="p">.</span><span class="n">progress</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">downloadTask</span><span class="p">.</span><span class="n">taskDescription</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">taskDescriptionForSessionTasks</span><span class="p">;</span>

    <span class="p">[</span><span class="n">self</span> <span class="nf">setDelegate</span><span class="p">:</span><span class="n">delegate</span> <span class="nf">forTask</span><span class="p">:</span><span class="n">downloadTask</span><span class="p">];</span>
<span class="p">}</span>
</code></pre>
</div>
<p>和数据请求相比，这里主要多了两个地方一个是设置了下载完成后的回调，一个是设置了下载的进度。这里设置的是delegate相应的回调。函数的最后一句就是保存delegate，这个和数据请求部分一样，不解释了。最后还会调用这个函数：</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setDownloadTaskDidFinishDownloadingBlock</span><span class="p">:(</span><span class="n">NSURL</span> <span class="o">*</span> <span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="n">NSURLSessionDownloadTask</span> <span class="o">*</span><span class="n">downloadTask</span><span class="p">,</span> <span class="n">NSURL</span> <span class="o">*</span><span class="n">location</span><span class="p">))</span><span class="nv">block</span> <span class="p">{</span>
    <span class="n">self</span><span class="p">.</span><span class="n">downloadTaskDidFinishDownloading</span> <span class="o">=</span> <span class="n">block</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>
<p>因为我们之前设置了manager下载完成后的回调就是这句：</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="n">manager</span> <span class="nf">setDownloadTaskDidFinishDownloadingBlock</span><span class="p">:</span><span class="n">block</span><span class="p">];</span>
</code></pre>
</div>

<p>现在可以启动downloadTask了。</p>

<p>网络正常的情况以及URL没错的情况下，收到下载的数据后就会调用manager实现的代理方法：</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="c1">//AFURLSessionManager-&gt;NSURLSessionDownloadDelegate-&gt;下载时调用，可能调用多次
</span><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">URLSession</span><span class="p">:(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="p">)</span><span class="nv">session</span>
      <span class="nf">downloadTask</span><span class="p">:(</span><span class="n">NSURLSessionDownloadTask</span> <span class="o">*</span><span class="p">)</span><span class="nv">downloadTask</span>
      <span class="nf">didWriteData</span><span class="p">:(</span><span class="kt">int64_t</span><span class="p">)</span><span class="nv">bytesWritten</span>
 <span class="nf">totalBytesWritten</span><span class="p">:(</span><span class="kt">int64_t</span><span class="p">)</span><span class="nv">totalBytesWritten</span>
<span class="nf">totalBytesExpectedToWrite</span><span class="p">:(</span><span class="kt">int64_t</span><span class="p">)</span><span class="nv">totalBytesExpectedToWrite</span>
<span class="p">{</span>
    <span class="n">AFURLSessionManagerTaskDelegate</span> <span class="o">*</span><span class="n">delegate</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nf">delegateForTask</span><span class="p">:</span><span class="n">downloadTask</span><span class="p">];</span>
    <span class="p">[</span><span class="n">delegate</span> <span class="nf">URLSession</span><span class="p">:</span><span class="n">session</span> <span class="nf">downloadTask</span><span class="p">:</span><span class="n">downloadTask</span> <span class="n">didWriteData</span><span class="o">:</span><span class="n">bytesWritten</span> <span class="n">totalBytesWritten</span><span class="o">:</span><span class="n">totalBytesWritten</span> <span class="n">totalBytesExpectedToWrite</span><span class="o">:</span><span class="n">totalBytesExpectedToWrite</span><span class="p">];</span>
<span class="c1">//downloadTaskDidWriteData - &gt; void (^AFURLSessionDownloadTaskDidWriteDataBlock)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, int64_t bytesWritten, int64_t totalBytesWritten, int64_t totalBytesExpectedToWrite);
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">downloadTaskDidWriteData</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">self</span><span class="p">.</span><span class="n">downloadTaskDidWriteData</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">downloadTask</span><span class="p">,</span> <span class="n">bytesWritten</span><span class="p">,</span> <span class="n">totalBytesWritten</span><span class="p">,</span> <span class="n">totalBytesExpectedToWrite</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>
<p>这个函数没什么可以讲主要就是用来计算下载的进度。当下载完成的时候就会进入到这个代理方法中：</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="c1">//AFURLSessionManager-&gt;NSURLSessionDownloadDelegate-&gt;下载完成是调用
</span><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">URLSession</span><span class="p">:(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="p">)</span><span class="nv">session</span>
      <span class="nf">downloadTask</span><span class="p">:(</span><span class="n">NSURLSessionDownloadTask</span> <span class="o">*</span><span class="p">)</span><span class="nv">downloadTask</span>
<span class="nf">didFinishDownloadingToURL</span><span class="p">:(</span><span class="n">NSURL</span> <span class="o">*</span><span class="p">)</span><span class="nv">location</span>
<span class="p">{</span>
    <span class="n">AFURLSessionManagerTaskDelegate</span> <span class="o">*</span><span class="n">delegate</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nf">delegateForTask</span><span class="p">:</span><span class="n">downloadTask</span><span class="p">];</span>
<span class="c1">//downloadTaskDidFinishDownloading -&gt; NSURL * (^AFURLSessionDownloadTaskDidFinishDownloadingBlock)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, NSURL *location);
</span>    <span class="c1">//下载的时候这个block没有用
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">downloadTaskDidFinishDownloading</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">NSURL</span> <span class="o">*</span><span class="n">fileURL</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">downloadTaskDidFinishDownloading</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">downloadTask</span><span class="p">,</span> <span class="n">location</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fileURL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">delegate</span><span class="p">.</span><span class="n">downloadFileURL</span> <span class="o">=</span> <span class="n">fileURL</span><span class="p">;</span>
            <span class="n">NSError</span> <span class="o">*</span><span class="n">error</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
            <span class="p">[[</span><span class="n">NSFileManager</span> <span class="nf">defaultManager</span><span class="p">]</span> <span class="nf">moveItemAtURL</span><span class="p">:</span><span class="n">location</span> <span class="nf">toURL</span><span class="p">:</span><span class="n">fileURL</span> <span class="n">error</span><span class="o">:&amp;</span><span class="n">error</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
                <span class="p">[[</span><span class="n">NSNotificationCenter</span> <span class="nf">defaultCenter</span><span class="p">]</span> <span class="nf">postNotificationName</span><span class="p">:</span><span class="n">AFURLSessionDownloadTaskDidFailToMoveFileNotification</span> <span class="nf">object</span><span class="p">:</span><span class="n">downloadTask</span> <span class="n">userInfo</span><span class="o">:</span><span class="n">error</span><span class="p">.</span><span class="n">userInfo</span><span class="p">];</span>
            <span class="p">}</span>

            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">delegate</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">[</span><span class="n">delegate</span> <span class="nf">URLSession</span><span class="p">:</span><span class="n">session</span> <span class="nf">downloadTask</span><span class="p">:</span><span class="n">downloadTask</span> <span class="n">didFinishDownloadingToURL</span><span class="o">:</span><span class="n">location</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>
<p>这里有一个重点，单步执行的时候会发现，程序会进入到第一个if里面。还记得在开头的例子中我加了三行代码：</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="k">typedef</span> <span class="n">NSURL</span> <span class="o">*</span> <span class="p">(</span><span class="o">^</span><span class="n">DownloadTaskDidFinishDownloadingBlock</span><span class="p">)(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="n">NSURLSessionDownloadTask</span> <span class="o">*</span><span class="n">downloadTask</span><span class="p">,</span> <span class="n">NSURL</span> <span class="o">*</span><span class="n">location</span><span class="p">);</span>

<span class="n">id</span> <span class="n">block</span> <span class="o">=</span> <span class="o">^</span><span class="p">(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="n">NSURLSessionDownloadTask</span> <span class="o">*</span><span class="n">downloadTask</span><span class="p">,</span> <span class="n">NSURL</span> <span class="o">*</span><span class="n">location</span><span class="p">){</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"%@"</span><span class="p">,</span><span class="n">location</span><span class="p">);</span>
<span class="p">};</span>
<span class="p">[</span><span class="n">manager</span> <span class="nf">setDownloadTaskDidFinishDownloadingBlock</span><span class="p">:</span><span class="n">block</span><span class="p">];</span>
</code></pre>
</div>
<p>这三行设置了manager的downloadTaskDidFinishDownloading属性，它是下载完成后的一个回调，它要求返回一个URL用来存放下载的图片，如果在这个block里返回了一个URL那么它会进入到第一个if里去，并且执行完就返回了。图片也就保存到了返回的这个URL了，后面的代码就不会执行了，如果没有返回一个URL的话，程序就是把下载的图片保存到这里：</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="c1">//这是例子开头我们设置的用来保存图片的URL,如果我们设置了managerr的downloadTaskDidFinishDownloading属性并且同时在这个block里返回了一个URL那么下面这两行代码就不会执行了，因为已经有保存图片的URL了。只有block里没有返回URL下面的代码才会执行
</span><span class="n">NSURL</span> <span class="o">*</span><span class="n">documentsDirectoryURL</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSFileManager</span> <span class="nf">defaultManager</span><span class="p">]</span> <span class="nf">URLForDirectory</span><span class="p">:</span><span class="n">NSDocumentDirectory</span> <span class="nf">inDomain</span><span class="p">:</span><span class="n">NSUserDomainMask</span> <span class="n">appropriateForURL</span><span class="o">:</span><span class="nb">nil</span> <span class="n">create</span><span class="o">:</span><span class="nb">NO</span> <span class="n">error</span><span class="o">:</span><span class="nb">nil</span><span class="p">];</span>

<span class="k">return</span> <span class="p">[</span><span class="n">documentsDirectoryURL</span> <span class="nf">URLByAppendingPathComponent</span><span class="p">:[</span><span class="n">response</span> <span class="nf">suggestedFilename</span><span class="p">]];</span>
</code></pre>
</div>
<p>上面的这两行代码是在这个代理方法里调用的：</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="c1">//AFURLSessionManagerTaskDelegate-&gt;NSURLSessionTaskDelegate-&gt;下载完成时调用
</span><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">URLSession</span><span class="p">:(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="p">)</span><span class="nv">session</span>
      <span class="nf">downloadTask</span><span class="p">:(</span><span class="n">NSURLSessionDownloadTask</span> <span class="o">*</span><span class="p">)</span><span class="nv">downloadTask</span>
<span class="nf">didFinishDownloadingToURL</span><span class="p">:(</span><span class="n">NSURL</span> <span class="o">*</span><span class="p">)</span><span class="nv">location</span>
<span class="p">{</span>
    <span class="n">NSError</span> <span class="o">*</span><span class="n">fileManagerError</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
    <span class="n">self</span><span class="p">.</span><span class="n">downloadFileURL</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
<span class="c1">//downloadTaskDidFinishDownloading -&gt; NSURL * (^AFURLSessionDownloadTaskDidFinishDownloadingBlock)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, NSURL *location);
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">downloadTaskDidFinishDownloading</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">//下载完成时调用block
</span>        <span class="n">self</span><span class="p">.</span><span class="n">downloadFileURL</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">downloadTaskDidFinishDownloading</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">downloadTask</span><span class="p">,</span> <span class="n">location</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">downloadFileURL</span><span class="p">)</span> <span class="p">{</span>
            <span class="p">[[</span><span class="n">NSFileManager</span> <span class="nf">defaultManager</span><span class="p">]</span> <span class="nf">moveItemAtURL</span><span class="p">:</span><span class="n">location</span> <span class="nf">toURL</span><span class="p">:</span><span class="n">self</span><span class="p">.</span><span class="n">downloadFileURL</span> <span class="n">error</span><span class="o">:&amp;</span><span class="n">fileManagerError</span><span class="p">];</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">fileManagerError</span><span class="p">)</span> <span class="p">{</span>
                <span class="p">[[</span><span class="n">NSNotificationCenter</span> <span class="nf">defaultCenter</span><span class="p">]</span> <span class="nf">postNotificationName</span><span class="p">:</span><span class="n">AFURLSessionDownloadTaskDidFailToMoveFileNotification</span> <span class="nf">object</span><span class="p">:</span><span class="n">downloadTask</span> <span class="n">userInfo</span><span class="o">:</span><span class="n">fileManagerError</span><span class="p">.</span><span class="n">userInfo</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>
<p>这里需要注意的是这个downloadTaskDidFinishDownloading是delegate里的和manager里的不一样，不要被迷惑了。这个block返回URL，往下执行就是把图片保存在这个URL上了。这个block是不是不知道我们什么时候设置的了。写了这么我，我也差一点忘记了。它是在这个[AFURLSessionMananger addDelegateForDownloadTask:progress:destination:completionHandler:]函数里设置的，注意里面的这一行代码：</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">destination</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">delegate</span><span class="p">.</span><span class="n">downloadTaskDidFinishDownloading</span> <span class="o">=</span> <span class="o">^</span><span class="n">NSURL</span> <span class="o">*</span> <span class="p">(</span><span class="n">NSURLSession</span> <span class="o">*</span> <span class="n">__unused</span> <span class="n">session</span><span class="p">,</span> <span class="n">NSURLSessionDownloadTask</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="n">NSURL</span> <span class="o">*</span><span class="n">location</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">destination</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">task</span><span class="p">.</span><span class="n">response</span><span class="p">);</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre>
</div>
<p>block的用法有没有很神奇它竟然捕获从最外面传进来的destination，并且保存到现在，而且现在要执行它来返回图片要保存的URL。</p>

<p>到这里基本也就快结束了，执行完，就会进入这个[AFURLSessionManagerTaskDelegate URLSession:task:didCompleteWithError:]函数里了，这一步和数据请求没有什么区别。经过这么多调用，图片也就下载完了。前面笔者设置manager的downloadTaskDidFinishDownloading属性，这个笔者认为可以用来返回指定的URL，也可以用来做一些，下载完成后的后续处理工作。</p>

<p>—EOF—</p>


                    ]]>
                </content:encoded>
                <guid isPermaLink="false">/objective-c/afnetworking/2017/05/05/AFNetworking3.0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%95%B0%E6%8D%AE%E4%B8%8B%E8%BD%BD/</guid>
                <description>
                    
                    本文主要分析AFNetworking的下载请求部分。
                    
                </description>
                <pubDate>Fri, 05 May 2017 00:00:00 +0800</pubDate>
                <author>冬阳</author>
            </item>
        
    
        
            <item>
                <title>AFNetworking3.0源码解读之数据请求</title>
                <link>http://localhost:4000/objective-c/afnetworking/2017/05/03/AFNetworking3.0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82/</link>
                <content:encoded>
                    <![CDATA[
                    <p>标签： objective-c AFNetworking</p>

<hr />

<h3 id="前言">前言</h3>

<p>无论做什么开发，都避免不了和网络打交道。在iOS中，网络请求这一块，大家肯定用过AFNetworking库。那么它到底是怎么实现的呢？本文主要讲它的数据请求部分，在以后博客中，会慢慢讲解其他部分。网上其实已经有很多相关的博客了，有些写的更好，写这篇博客的原因也是为了方便记下自己在看一些开源库的代码时学习到的编程技法、编程思想和问题的解决方案。</p>

<h3 id="正文">正文</h3>
<p>先从AFURLSessionManager开始，可以说它是整个库的核心，后面的AFHTTPSessionManager是就继承自AFURLSessionManager类。AFURLSessionManager类主要是对NSURLSession还有相关代理协议的封装。这个类对用户暴露的接口很少，在实现文件里定义了大量的私有方法，此外还对AFURLSessionManager进行了扩展。进行入AFURLSessionManager.m文件内看可以看到这样的结构：
<img src="/images/AFURLSessionManager类的结构图.png" alt="AFURLSessionManager类结构图" /></p>

<p>在实现文件里，AFURLSessionManager.m里定义了两个类，一个类是AFURLSessionManagerTaskDelegate，还有一个就是_AFURLSessionTaskSwizzling。</p>

<p>AFURLSessionManagerTaskDelegate这个类从名字上看就知道，它是用来实现代理的，所有的网络请求回调都是经过它。呆会通过一个实际的例子来的说明。</p>

<p>那么_AFURLSessionTaskSwizzling类是用来干吗的呢？在写这篇博客的时候，笔者还没有能过例子实际的使用过，不过它的源码很少，通过看原码和注释大概知道，它是用来进行方法调配，使用了系统的运行期系统来交换两个方法的实现。注释中提到NSURLSessionTask的实现是通过class cluster来实现的，也就是说我们创建的一个NSURLSessionTask对象，并不是真正的创建这个对象而是创建了一个名字叫__NSCFLocalDataTask。这个类只干了一件了，那就是对任务的<code class="highlighter-rouge">resume</code>和<code class="highlighter-rouge">suspend</code>进行了交换，目的可能就是要实现任务的暂停和恢复的功能。对这个类先说这么点点个人理解吧。</p>

<p>接下来，笔者就以官方给出的例子跟踪一下，它的调用过程以下是源码：</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="n">NSURLSessionConfiguration</span> <span class="o">*</span><span class="n">configuration</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSURLSessionConfiguration</span> <span class="nf">defaultSessionConfiguration</span><span class="p">];</span>
<span class="n">AFURLSessionManager</span> <span class="o">*</span><span class="n">manager</span> <span class="o">=</span> <span class="p">[[</span><span class="n">AFURLSessionManager</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">initWithSessionConfiguration</span><span class="p">:</span><span class="n">configuration</span><span class="p">];</span>

<span class="n">manager</span><span class="p">.</span><span class="n">responseSerializer</span> <span class="o">=</span> <span class="p">[</span><span class="n">AFHTTPResponseSerializer</span> <span class="nf">serializer</span><span class="p">];</span>
<span class="n">NSURL</span> <span class="o">*</span><span class="n">URL</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSURL</span> <span class="nf">URLWithString</span><span class="p">:</span><span class="s">@"http://www.baidu.com"</span><span class="p">];</span>
<span class="n">NSURLRequest</span> <span class="o">*</span><span class="n">request</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSURLRequest</span> <span class="nf">requestWithURL</span><span class="p">:</span><span class="n">URL</span><span class="p">];</span>

<span class="n">NSURLSessionDataTask</span> <span class="o">*</span><span class="n">dataTask</span> <span class="o">=</span> <span class="p">[</span><span class="n">manager</span> <span class="nf">dataTaskWithRequest</span><span class="p">:</span><span class="n">request</span> <span class="nf">completionHandler</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">NSURLResponse</span> <span class="o">*</span><span class="n">response</span><span class="p">,</span> <span class="n">id</span> <span class="n">responseObject</span><span class="p">,</span> <span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@"Error: %@"</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        
        <span class="n">NSString</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSString</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">initWithData</span><span class="p">:</span><span class="n">responseObject</span>  <span class="nf">encoding</span><span class="p">:</span><span class="n">NSUTF8StringEncoding</span><span class="p">];</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@"%@"</span><span class="p">,[</span><span class="n">responseObject</span> <span class="nf">class</span><span class="p">]);</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@"%@"</span><span class="p">,</span><span class="n">result</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}];</span>
<span class="p">[</span><span class="n">dataTask</span> <span class="nf">resume</span><span class="p">];</span>
</code></pre>
</div>
<p>该代码核心只有两句一个是manager的初始化还有一个就是dataTask的创建。先来看看初始化：</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="nf">initWithSessionConfiguration</span><span class="p">:(</span><span class="n">NSURLSessionConfiguration</span> <span class="o">*</span><span class="p">)</span><span class="nv">configuration</span> <span class="p">{</span>
    <span class="n">self</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="nf">init</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">nil</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">configuration</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">configuration</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSURLSessionConfiguration</span> <span class="nf">defaultSessionConfiguration</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="n">self</span><span class="p">.</span><span class="n">sessionConfiguration</span> <span class="o">=</span> <span class="n">configuration</span><span class="p">;</span><span class="c1">//默认配置
</span>
    <span class="n">self</span><span class="p">.</span><span class="n">operationQueue</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSOperationQueue</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">init</span><span class="p">];</span>
    <span class="n">self</span><span class="p">.</span><span class="n">operationQueue</span><span class="p">.</span><span class="n">maxConcurrentOperationCount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="c1">//最大并发数，此处应该当成串行队列来用了
</span>
    <span class="n">self</span><span class="p">.</span><span class="n">session</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSURLSession</span> <span class="nf">sessionWithConfiguration</span><span class="p">:</span><span class="n">self</span><span class="p">.</span><span class="n">sessionConfiguration</span> <span class="nf">delegate</span><span class="p">:</span><span class="n">self</span> <span class="n">delegateQueue</span><span class="o">:</span><span class="n">self</span><span class="p">.</span><span class="n">operationQueue</span><span class="p">];</span><span class="c1">//创建session，设置代理对象
</span>
    <span class="n">self</span><span class="p">.</span><span class="n">responseSerializer</span> <span class="o">=</span> <span class="p">[</span><span class="n">AFJSONResponseSerializer</span> <span class="nf">serializer</span><span class="p">];</span><span class="c1">//默认的解析器
</span>
    <span class="n">self</span><span class="p">.</span><span class="n">securityPolicy</span> <span class="o">=</span> <span class="p">[</span><span class="n">AFSecurityPolicy</span> <span class="nf">defaultPolicy</span><span class="p">];</span>

<span class="cp">#if !TARGET_OS_WATCH
</span>    <span class="n">self</span><span class="p">.</span><span class="n">reachabilityManager</span> <span class="o">=</span> <span class="p">[</span><span class="n">AFNetworkReachabilityManager</span> <span class="nf">sharedManager</span><span class="p">];</span>
<span class="cp">#endif
</span>
    <span class="n">self</span><span class="p">.</span><span class="n">mutableTaskDelegatesKeyedByTaskIdentifier</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSMutableDictionary</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">init</span><span class="p">];</span>

    <span class="n">self</span><span class="p">.</span><span class="n">lock</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSLock</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">init</span><span class="p">];</span>
    <span class="n">self</span><span class="p">.</span><span class="n">lock</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">AFURLSessionManagerLockName</span><span class="p">;</span>

    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">session</span> <span class="nf">getTasksWithCompletionHandler</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">NSArray</span> <span class="o">*</span><span class="n">dataTasks</span><span class="p">,</span> <span class="n">NSArray</span> <span class="o">*</span><span class="n">uploadTasks</span><span class="p">,</span> <span class="n">NSArray</span> <span class="o">*</span><span class="n">downloadTasks</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">NSURLSessionDataTask</span> <span class="o">*</span><span class="n">task</span> <span class="k">in</span> <span class="n">dataTasks</span><span class="p">)</span> <span class="p">{</span>
            <span class="p">[</span><span class="n">self</span> <span class="nf">addDelegateForDataTask</span><span class="p">:</span><span class="n">task</span> <span class="nf">completionHandler</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">NSURLSessionUploadTask</span> <span class="o">*</span><span class="n">uploadTask</span> <span class="k">in</span> <span class="n">uploadTasks</span><span class="p">)</span> <span class="p">{</span>
            <span class="p">[</span><span class="n">self</span> <span class="nf">addDelegateForUploadTask</span><span class="p">:</span><span class="n">uploadTask</span> <span class="nf">progress</span><span class="p">:</span><span class="nb">nil</span> <span class="n">completionHandler</span><span class="o">:</span><span class="nb">nil</span><span class="p">];</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">NSURLSessionDownloadTask</span> <span class="o">*</span><span class="n">downloadTask</span> <span class="k">in</span> <span class="n">downloadTasks</span><span class="p">)</span> <span class="p">{</span>
            <span class="p">[</span><span class="n">self</span> <span class="nf">addDelegateForDownloadTask</span><span class="p">:</span><span class="n">downloadTask</span> <span class="nf">progress</span><span class="p">:</span><span class="nb">nil</span> <span class="n">destination</span><span class="o">:</span><span class="nb">nil</span> <span class="n">completionHandler</span><span class="o">:</span><span class="nb">nil</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}];</span>

    <span class="p">[[</span><span class="n">NSNotificationCenter</span> <span class="nf">defaultCenter</span><span class="p">]</span> <span class="nf">addObserver</span><span class="p">:</span><span class="n">self</span> <span class="nf">selector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">taskDidResume</span><span class="o">:</span><span class="p">)</span> <span class="n">name</span><span class="o">:</span><span class="n">AFNSURLSessionTaskDidResumeNotification</span> <span class="n">object</span><span class="o">:</span><span class="nb">nil</span><span class="p">];</span>
    <span class="p">[[</span><span class="n">NSNotificationCenter</span> <span class="nf">defaultCenter</span><span class="p">]</span> <span class="nf">addObserver</span><span class="p">:</span><span class="n">self</span> <span class="nf">selector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">taskDidSuspend</span><span class="o">:</span><span class="p">)</span> <span class="n">name</span><span class="o">:</span><span class="n">AFNSURLSessionTaskDidSuspendNotification</span> <span class="n">object</span><span class="o">:</span><span class="nb">nil</span><span class="p">];</span>

    <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>
<p>看起来好多，对我们本次的目的其实需要关心的东西很少，我都给出来了注释。</p>

<p>第二处是dataTask的创建，为了说明，先把程序跑起来看看函数的调用栈。任务一启动，首先进入到了[AFURLSessionManager dataTaskWithRequest:completionHandler:]函数中：</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="n">NSURLSessionDataTask</span> <span class="o">*</span><span class="p">)</span><span class="nf">dataTaskWithRequest</span><span class="p">:(</span><span class="n">NSURLRequest</span> <span class="o">*</span><span class="p">)</span><span class="nv">request</span>
                            <span class="nf">completionHandler</span><span class="p">:(</span><span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="n">NSURLResponse</span> <span class="o">*</span><span class="n">response</span><span class="p">,</span> <span class="n">id</span> <span class="n">responseObject</span><span class="p">,</span> <span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">))</span><span class="nv">completionHandler</span>
<span class="p">{</span>
    <span class="n">__block</span> <span class="n">NSURLSessionDataTask</span> <span class="o">*</span><span class="n">dataTask</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
    <span class="n">dispatch_sync</span><span class="p">(</span><span class="n">url_session_manager_creation_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
        <span class="n">dataTask</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">session</span> <span class="nf">dataTaskWithRequest</span><span class="p">:</span><span class="n">request</span><span class="p">];</span>
    <span class="p">});</span>

    <span class="p">[</span><span class="n">self</span> <span class="nf">addDelegateForDataTask</span><span class="p">:</span><span class="n">dataTask</span> <span class="nf">completionHandler</span><span class="p">:</span><span class="n">completionHandler</span><span class="p">];</span>

    <span class="k">return</span> <span class="n">dataTask</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>
<p>函数体内主要是在一个GCD队列里创建dataTask，此处用到的是GCD同步API。然后调用了第一个私有方法[AFURLSessionManager addDelegateForDataTask:completionHandler:]来设置dataTask的代理和回调的block:</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">addDelegateForDataTask</span><span class="p">:(</span><span class="n">NSURLSessionDataTask</span> <span class="o">*</span><span class="p">)</span><span class="nv">dataTask</span>
             <span class="nf">completionHandler</span><span class="p">:(</span><span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="n">NSURLResponse</span> <span class="o">*</span><span class="n">response</span><span class="p">,</span> <span class="n">id</span> <span class="n">responseObject</span><span class="p">,</span> <span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">))</span><span class="nv">completionHandler</span>
<span class="p">{</span>
    <span class="n">AFURLSessionManagerTaskDelegate</span> <span class="o">*</span><span class="n">delegate</span> <span class="o">=</span> <span class="p">[[</span><span class="n">AFURLSessionManagerTaskDelegate</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">init</span><span class="p">];</span>
    <span class="n">delegate</span><span class="p">.</span><span class="n">manager</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>
    <span class="n">delegate</span><span class="p">.</span><span class="n">completionHandler</span> <span class="o">=</span> <span class="n">completionHandler</span><span class="p">;</span>

    <span class="n">dataTask</span><span class="p">.</span><span class="n">taskDescription</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">taskDescriptionForSessionTasks</span><span class="p">;</span>
    
    <span class="p">[</span><span class="n">self</span> <span class="nf">setDelegate</span><span class="p">:</span><span class="n">delegate</span> <span class="nf">forTask</span><span class="p">:</span><span class="n">dataTask</span><span class="p">];</span>
<span class="p">}</span>
</code></pre>
</div>
<p>在这个函数内真正的设置了网络的代理，就是刚才提到的AFURLSessionManagerTaskDelegate类，这里有一个小细节需要注意一下，就是这一行<code class="highlighter-rouge">delegate.manager = self</code>，在该函数内定义了一个delegate并且持有了manager,而在AFURLSessionManagerTaskDelegate定义中声明了一个AFURLSessionManager对象manager。这就是说delegate持有了manager，manager持有了delegate，循环引用的问题就出来了，这里的解决方法是通过将AFURLSessionManagerTaskDelegate中的manager属性的内存管理语义声明为weak。我们看一下，该类的声明就知道了。</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="k">@interface</span> <span class="nc">AFURLSessionManagerTaskDelegate</span> <span class="p">:</span> <span class="nc">NSObject</span> <span class="o">&lt;</span><span class="n">NSURLSessionTaskDelegate</span><span class="p">,</span> <span class="n">NSURLSessionDataDelegate</span><span class="p">,</span> <span class="n">NSURLSessionDownloadDelegate</span><span class="o">&gt;</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">weak</span><span class="p">)</span> <span class="n">AFURLSessionManager</span> <span class="o">*</span><span class="n">manager</span><span class="p">;</span><span class="c1">//内存管理语义为weak
</span><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">strong</span><span class="p">)</span> <span class="n">NSMutableData</span> <span class="o">*</span><span class="n">mutableData</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">strong</span><span class="p">)</span> <span class="n">NSProgress</span> <span class="o">*</span><span class="n">progress</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">copy</span><span class="p">)</span> <span class="n">NSURL</span> <span class="o">*</span><span class="n">downloadFileURL</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">copy</span><span class="p">)</span> <span class="n">AFURLSessionDownloadTaskDidFinishDownloadingBlock</span> <span class="n">downloadTaskDidFinishDownloading</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">copy</span><span class="p">)</span> <span class="n">AFURLSessionTaskCompletionHandler</span> <span class="n">completionHandler</span><span class="p">;</span>
<span class="k">@end</span>
</code></pre>
</div>

<p>接着上面的说，接下来函数的调用栈就进入了[AFURLSessionManager setDelegate:dataTask:]。</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setDelegate</span><span class="p">:(</span><span class="n">AFURLSessionManagerTaskDelegate</span> <span class="o">*</span><span class="p">)</span><span class="nv">delegate</span>
            <span class="nf">forTask</span><span class="p">:(</span><span class="n">NSURLSessionTask</span> <span class="o">*</span><span class="p">)</span><span class="nv">task</span>
<span class="p">{</span>
    <span class="n">NSParameterAssert</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
    <span class="n">NSParameterAssert</span><span class="p">(</span><span class="n">delegate</span><span class="p">);</span>

    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">lock</span> <span class="nf">lock</span><span class="p">];</span>
    <span class="n">self</span><span class="p">.</span><span class="n">mutableTaskDelegatesKeyedByTaskIdentifier</span><span class="p">[</span><span class="err">@</span><span class="p">(</span><span class="n">task</span><span class="p">.</span><span class="n">taskIdentifier</span><span class="p">)]</span> <span class="o">=</span> <span class="n">delegate</span><span class="p">;</span>
    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">lock</span> <span class="nf">unlock</span><span class="p">];</span>
<span class="p">}</span>
</code></pre>
</div>
<p>这个函数是用来干吗的呢？还加了锁。从代码上看，就是保存task的代理。</p>

<p>至此，所有的准备工作都做完了只等我们去启动这个任务了。没错，就是通过这一句<code class="highlighter-rouge">[dataTask resume]</code>。写到这，先来总结一下，这些准备工作的函数调用过程，直接甩图了：
<img src="/images/调用过程.png" alt="调用过程" /></p>

<p>接下来就是代理了，代理的过程是这样的，AFURLSessionManager自己实现了代理协议，但是在代理协议方法中，根据dataTask的taskIdentifier找到相应的delegate对象，把具体代理该做的事，交给这个delegate。任务启动后第一个调用的是AFURLSessionManager这个函数：</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="c1">//这是AFURLSessionManager类的方法
</span><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">URLSession</span><span class="p">:(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="p">)</span><span class="nv">session</span>
          <span class="nf">dataTask</span><span class="p">:(</span><span class="n">NSURLSessionDataTask</span> <span class="o">*</span><span class="p">)</span><span class="nv">dataTask</span>
    <span class="nf">didReceiveData</span><span class="p">:(</span><span class="n">NSData</span> <span class="o">*</span><span class="p">)</span><span class="nv">data</span>
<span class="p">{</span>
    <span class="n">AFURLSessionManagerTaskDelegate</span> <span class="o">*</span><span class="n">delegate</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nf">delegateForTask</span><span class="p">:</span><span class="n">dataTask</span><span class="p">];</span>
    <span class="p">[</span><span class="n">delegate</span> <span class="nf">URLSession</span><span class="p">:</span><span class="n">session</span> <span class="nf">dataTask</span><span class="p">:</span><span class="n">dataTask</span> <span class="n">didReceiveData</span><span class="o">:</span><span class="n">data</span><span class="p">];</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">dataTaskDidReceiveData</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">self</span><span class="p">.</span><span class="n">dataTaskDidReceiveData</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">dataTask</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>
<p>可以看出它把delegate取出来之后就转到AFURLSessionManagerTaskDelegate类中去了，调用了AFURLSessionManagerTaskDelegate同名方法。</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="c1">//这是AFURLSessionManagerTaskDelegate类的方法
</span><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">URLSession</span><span class="p">:(</span><span class="n">__unused</span> <span class="n">NSURLSession</span> <span class="o">*</span><span class="p">)</span><span class="nv">session</span>
          <span class="nf">dataTask</span><span class="p">:(</span><span class="n">__unused</span> <span class="n">NSURLSessionDataTask</span> <span class="o">*</span><span class="p">)</span><span class="nv">dataTask</span>
    <span class="nf">didReceiveData</span><span class="p">:(</span><span class="n">NSData</span> <span class="o">*</span><span class="p">)</span><span class="nv">data</span>
<span class="p">{</span>
    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">mutableData</span> <span class="nf">appendData</span><span class="p">:</span><span class="n">data</span><span class="p">];</span>
<span class="p">}</span>
</code></pre>
</div>
<p>上面的这个函数才是真正干事的，AFURLSessionManager类中的同名方法只是打了一个酱油。当请求结束的时候，同样首先会调用AFURLSessionManager中的方法：</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="c1">//这是AFURLSessionManager类的方法
</span><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">URLSession</span><span class="p">:(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="p">)</span><span class="nv">session</span>
              <span class="nf">task</span><span class="p">:(</span><span class="n">NSURLSessionTask</span> <span class="o">*</span><span class="p">)</span><span class="nv">task</span>
<span class="nf">didCompleteWithError</span><span class="p">:(</span><span class="n">NSError</span> <span class="o">*</span><span class="p">)</span><span class="nv">error</span>
<span class="p">{</span>
    <span class="n">AFURLSessionManagerTaskDelegate</span> <span class="o">*</span><span class="n">delegate</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nf">delegateForTask</span><span class="p">:</span><span class="n">task</span><span class="p">];</span>

    <span class="c1">// delegate may be nil when completing a task in the background
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">delegate</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">[</span><span class="n">delegate</span> <span class="nf">URLSession</span><span class="p">:</span><span class="n">session</span> <span class="nf">task</span><span class="p">:</span><span class="n">task</span> <span class="n">didCompleteWithError</span><span class="o">:</span><span class="n">error</span><span class="p">];</span>

        <span class="p">[</span><span class="n">self</span> <span class="nf">removeDelegateForTask</span><span class="p">:</span><span class="n">task</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">taskDidComplete</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">self</span><span class="p">.</span><span class="n">taskDidComplete</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
    <span class="p">}</span>

<span class="p">}</span>
</code></pre>
</div>
<p>真正干事的还是AFURLSessionManagerTaskDelegate类中的同名方法。这里给出这个方法的部分代码：</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="c1">//在没有错误的时候就执行这一段代码
</span><span class="n">dispatch_async</span><span class="p">(</span><span class="n">url_session_manager_processing_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
    <span class="n">NSError</span> <span class="o">*</span><span class="n">serializationError</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
    <span class="n">responseObject</span> <span class="o">=</span> <span class="p">[</span><span class="n">manager</span><span class="p">.</span><span class="n">responseSerializer</span> <span class="nf">responseObjectForResponse</span><span class="p">:</span><span class="n">task</span><span class="p">.</span><span class="n">response</span> <span class="nf">data</span><span class="p">:</span><span class="n">data</span> <span class="n">error</span><span class="o">:&amp;</span><span class="n">serializationError</span><span class="p">];</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">downloadFileURL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">responseObject</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">downloadFileURL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">responseObject</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">userInfo</span><span class="p">[</span><span class="nf">AFNetworkingTaskDidCompleteSerializedResponseKey</span><span class="p">]</span> <span class="o">=</span> <span class="n">responseObject</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">serializationError</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">userInfo</span><span class="p">[</span><span class="nf">AFNetworkingTaskDidCompleteErrorKey</span><span class="p">]</span> <span class="o">=</span> <span class="n">serializationError</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//这是真正干事的
</span>    <span class="n">dispatch_group_async</span><span class="p">(</span><span class="n">manager</span><span class="p">.</span><span class="n">completionGroup</span> <span class="p">?:</span> <span class="n">url_session_manager_completion_group</span><span class="p">(),</span> <span class="n">manager</span><span class="p">.</span><span class="n">completionQueue</span> <span class="p">?:</span> <span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
    	<span class="c1">//执行completionHandler，把取到的数据传到外面去，这里的responseObject就是我们请求到的数据
</span>        <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">completionHandler</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">self</span><span class="p">.</span><span class="n">completionHandler</span><span class="p">(</span><span class="n">task</span><span class="p">.</span><span class="n">response</span><span class="p">,</span> <span class="n">responseObject</span><span class="p">,</span> <span class="n">serializationError</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
            <span class="p">[[</span><span class="n">NSNotificationCenter</span> <span class="nf">defaultCenter</span><span class="p">]</span> <span class="nf">postNotificationName</span><span class="p">:</span><span class="n">AFNetworkingTaskDidCompleteNotification</span> <span class="nf">object</span><span class="p">:</span><span class="n">task</span> <span class="n">userInfo</span><span class="o">:</span><span class="n">userInfo</span><span class="p">];</span>
        <span class="p">});</span>
    <span class="p">});</span>
<span class="p">});</span>

</code></pre>
</div>
<p>至此整个代理过程就结束了。其中有一个地方值得注意一下，那就是每用manager创建一个task时，manager都会以task的taskIdentifier属性为key，以delegate为value存入字典中。这样的做的目的应该是一个manager可以管理多个task。</p>

<p>—EOF—</p>


                    ]]>
                </content:encoded>
                <guid isPermaLink="false">/objective-c/afnetworking/2017/05/03/AFNetworking3.0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82/</guid>
                <description>
                    
                    本文主要分析AFNetworking的数据请求部分。
                    
                </description>
                <pubDate>Wed, 03 May 2017 00:00:00 +0800</pubDate>
                <author>冬阳</author>
            </item>
        
    
        
            <item>
                <title>github-pages-搭建成功</title>
                <link>http://localhost:4000/overview/2017/04/27/github-pages-%E6%90%AD%E5%BB%BA%E6%88%90%E5%8A%9F/</link>
                <content:encoded>
                    <![CDATA[
                    <p>早就有想把平时遇到的问题，还有把自己的知识积累做个总结，但是一直懒于动手，结果是，一些知识时间一长，如果用的不是很频繁的话就比较容易忘记，到写这篇博客的时候好像就有一些知识点就忘记了。前一段时间知道了github pages后就，就在网上找了个模板，修修改改，搞了一两天，笔都对前端不太了解，平时做的都是iOS，看来得找个时间看看前端了。好吧，今天就写这么点了，本来还想写写怎么建立自己的博客，不过网上已有很多相关的博客，这里我发一两篇我参考的吧。</p>

<p><a href="https://github.com/uolcano/blog/issues/11">利用GitHub Pages建立项目或个人网站</a></p>

<p><a href="http://www.zhanxin.info/jekyll/2013-08-07-jekyll-doc-installation.html">Jekyll教程</a></p>

<p>–EOF–</p>

                    ]]>
                </content:encoded>
                <guid isPermaLink="false">/overview/2017/04/27/github-pages-%E6%90%AD%E5%BB%BA%E6%88%90%E5%8A%9F/</guid>
                <description>
                    
                    折腾了一两天，终于把博客搭的差不多了。
                    
                </description>
                <pubDate>Thu, 27 Apr 2017 00:00:00 +0800</pubDate>
                <author>冬阳</author>
            </item>
        
    
  </channel>
</rss>
