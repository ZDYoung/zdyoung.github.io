<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title></title>
    <link>http://localhost:4000</link>
    <description>
      A simple, beautiful theme for Jekyll that emphasizes content rather than aesthetic fluff.
    </description>
    
        
            <item>
                <title>AFNetworking3.0之HTTP请求</title>
                <link>http://localhost:4000/objective-c/http/2017/05/19/AFNetworking3.0%E4%B9%8BHTTP%E8%AF%B7%E6%B1%82/</link>
                <content:encoded>
                    <![CDATA[
                    <p>标签： objective-c HTTP</p>

<h2 id="前言">前言</h2>

<p>前面写过了AFNetworking的数据请求和下载的部分，也对AFNetworking有了一个基本的了解，这部分讲一下它是如何实现HTTP请求的，同时也剖析一下AFNetworking整个类的构成。</p>

<h2 id="正文">正文</h2>

<p>AFNetworking3.0的代码比起以前的版本，精简了很多，对于笔者来说可读性也大大的提高了。在这版本中，它的实现是对苹果给出的两套有关于网络请求的API及其代理的封装分别为:NSURLSession和NSURLConnection。其中NSURLSession是在iOS 7 或 Mac OS X 10.9以后才出现的API旨在用来替代NSURLConnection。为了兼容以前的代码，库里面还是把NSURLConnection加进来了。之前写关于AFNetworking的博客都是基于NSURLSession实现的，笔者也不打算讲AFNetworking基于NSURLConnection实现的部分，必竟现在都不太用了。</p>

<p>提到HTTP，就叉开一下，复习一下关于HTTP请求的东西。</p>

<h3 id="http请求">HTTP请求</h3>
<p>当浏览器向Web服务器发出请求时，它向服务器传递了一个数据块，也就是请求信息，它由3个部分组成：</p>
<ol>
  <li>请求方法URI协议/版本</li>
  <li>请求头(Request Header)</li>
  <li>请求正文</li>
</ol>

<p>请求格式：<br />
&lt;request-line&gt;<br />
&lt;headers&gt;<br />
&lt;blank line&gt;<br />
[&lt;request-body&gt;]</p>

<p>一个典型的例子：</p>

<p>GET / HTTP/1.1<br />
Host: youku.com<br />
Upgrade-Insecure-Requests: 1<br />
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36<br />
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,<em>/</em>;q=0.8<br />
Accept-Encoding: gzip, deflate, sdch<br />
Accept-Language: zh-CN,zh;q=0.8,en;q=0.6<br /></p>

<p>这是刚刚抓的请求包头。
第一行GET / HTTP/1.1分别为请求方法，URL（这里是根路径），协议版本1.1。从第二行开始都是请求头，请求头包含许多有关的客户端环境和请求正文的有用信息。例如，请求头可以声明浏览器所用的语言，请求正文的长度等。最后是是请求正文，这里没有。请求头和请求正文之间是一个空行，这个行非常重要，它表示请求头已经结束，接下来的是请求正文。请求正文中可以包含客户提交的查询字符。</p>

<p>HTTP请求方法用的最多的为GET方法与POST方法。</p>
<ol>
  <li>
    <div><font color="#FF6100">GET方法</font>：默认的HTTP请求方法，我们日常用GET方法来提交表单数据，然而用GET方法提交的表单数据只经过了简单的编码，同时它将作为URL的一部分向Web服务器发送，因此，如果使用GET方法来提交表单数据就存在着安全隐患上。例如Http://127.0.0.1/login.jsp?Name=zhangshi&amp;Age=30&amp;Submit=%cc%E+%BD%BB从上面的URL请求中，很容易就可以辩认出表单提交的内容。（？之后的内容）另外由于GET方法提交的数据是作为URL请求的一部分所以提交的数据量不能太大。</div>
  </li>
  <li>
    <div><font color="#FF6100">POST方法</font>：POST方法是GET方法的一个替代方法，它主要是向Web服务器提交表单数据，尤其是大批量的数据。POST方法克服了GET方法的一些缺点。通过POST方法提交表单数据时，数据不是作为URL请求的一部分而是作为标准数据传送给Web服务器，这就克服了GET方法中的信息无法保密和数据量太小的缺点。因此，出于安全的考虑以及对用户隐私的尊重，通常表单提交时采用POST方法。</div>
  </li>
</ol>

<p>HTTP响应也由三个部分组成，分别是：</p>
<ol>
  <li>状态行</li>
  <li>消息报头</li>
  <li>响应正文。</li>
</ol>

<p>响应格式：<br />
＜status-line＞<br />
＜headers＞<br />
＜blank line＞<br />
[＜response-body＞]</p>

<p>一个典型的例子：<br />
HTTP/1.1 200 OK<br />
Date: Thu, 18 May 2017 12:38:15 GMT<br />
Content-Type: text/html; charset=utf-8<br />
Content-Encoding: gzip<br /></p>

<p>第二行为协议状态版本代码描述，这里应答码为200，接下来都是响应头。<br />
HTTP应答码也称为状态码，它反映了Web服务器处理HTTP请求状态。HTTP应答码由3位数字构成，其中首位数字定义了应答码的类型：</p>
<ol>
  <li>
    <div><font color="#FF6100">1XX－信息类（Information）</font>：表示收到Web浏览器请求，正在进一步的处理中。</div>
  </li>
  <li>
    <div><font color="#FF6100">2XX－成功类（Successful）</font>:表示用户请求被正确接收，理解和处理例如：200 OK。</div>
  </li>
  <li>
    <div><font color="#FF6100">3XX-重定向类（Redirection）</font>:表示请求没有成功，客户必须采取进一步的动作。</div>
  </li>
  <li>
    <div><font color="#FF6100">4XX-客户端错误（Client Error）</font>:表示客户端提交的请求有错误。例如：404 NOTFound，意味着请求中所引用的文档不存在。</div>
  </li>
  <li>
    <div><font color="#FF6100">5XX-服务器错误（Server Error）</font>:表示服务器不能完成对请求的处理：如 500。</div>
  </li>
</ol>

<p>好了，现在叉回来。前面讲过AFURLSessionManager是整个库的核心，因为在HTTP这一部分，都是在这个类的基础上实现的。通过源码也可以看到AFURLSessionManager这个类有1000多行代码而接下来要讲的AFHTTPSessionManager类，只有300行多一点，而且AFHTTPSessionManager是继承自AFURLSessionManager的，因此HTTP请求部分的绝大多数工作都交给了AFHTTPSessionManager的父类那部分。来看看整个库的类的构成：<img src="/images/AFNetworking结构图.png" alt="AFNetworking结构图" /></p>

<p>简单介绍一下这张图上的每个类吧，其实
有些类的功能，笔者也没用过，不过往后可以试试：</p>
<ul>
  <li>
    <div><font color="#FF6100">AFURLSessionManager:</font>这个类前面讲过，它对NSURLSession及NSURLSessionTaskDelegate、NSURLSessionDataDelegate、NSURLSessionDownloadDelegate和NSURLSessionDelegate进行了封装，实现了诸如数据请求，下载和上传任务。</div>
  </li>
  <li>
    <div><font color="#FF6100">AFURLConnectionOperation:</font>它是NSOperation的子类，实现了NSURLConnection代理方法，这是iOS 6 或 Mac OS X 10.8以前用的API，现在基本不用了。</div>
  </li>
  <li>
    <div><font color="#FF6100">AFHTTPSessionManager:</font>这是基于NSURLSession实现的用于HTTP的GET、POST等类，也是本文主要讲的东西。</div>
  </li>
  <li>
    <div><font color="#FF6100">AFHTTPRequestOperation:</font>这是基于AFURLConnectionOperation子类，它和AFHTTPRequestOperationManager是一起配套使用的。这个类封装了可接受的状态码和可接受的内容类型。</div>
  </li>
  <li>
    <div><font color="#FF6100">AFHTTPRequestOperationManager:</font>这个是实现HTTP各个请求方法的和AFHTTPRequestOperation配套使用的。</div>
  </li>
  <li>
    <div><font color="#FF6100">AFURLRequestSerialization:</font>用来封装参数的，也可以用来设置请求头，请求的正文的格式等。比如，可以将请求的HTTP的body设置成JSON并在请求头部分将Content-Type字段的值设成application/json。</div>
  </li>
  <li>
    <div><font color="#FF6100">AFURLResponseSerialization:</font>根据服务器的响应细节来解析响应的数据，此外还可以对响应的数据进行验证。例如，如果期待得到的是JSON格式的数据，那么它会检查响应码是否是2xx开头的，同时还会检查响应头的Content-Type字段是否为application/json，从而将响应的数据正解的解析成对象。</div>
  </li>
  <li>
    <div><font color="#FF6100">AFNetworkReachabilityManager:</font>用来监控网络状态。</div>
  </li>
  <li>
    <div><font color="#FF6100">AFSecurityPolicy:</font>用来管控网络安全的。</div>
  </li>
</ul>

<p>抛开基于NSURLConnection那一部分，真正核心的就两个两类了AFHTTPSessionManager和AFURLSessionManager。</p>

<p>还是以官方给的例子讲吧，这里从网上找了一张图片，使用了GET方法，获取图片并且显示在一个UIImageView上：</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="n">AFHTTPSessionManager</span> <span class="o">*</span><span class="n">manager</span> <span class="o">=</span> <span class="p">[</span><span class="n">AFHTTPSessionManager</span> <span class="nf">manager</span><span class="p">];</span>

<span class="c1">//使用了默认的序列化器
</span><span class="n">manager</span><span class="p">.</span><span class="n">responseSerializer</span> <span class="o">=</span> <span class="p">[</span><span class="n">AFHTTPResponseSerializer</span> <span class="nf">serializer</span><span class="p">];</span>

<span class="c1">//发起一个GET请求还是巨方便的。
</span><span class="p">[</span><span class="n">manager</span> <span class="nf">GET</span><span class="p">:</span><span class="s">@"http://img04.tooopen.com/images/20130701/tooopen_10055061.jpg"</span>  <span class="nf">parameters</span><span class="p">:</span><span class="nb">nil</span> <span class="n">success</span><span class="o">:^</span><span class="p">(</span><span class="n">NSURLSessionDataTask</span> <span class="o">*</span> <span class="n">_Nonnull</span> <span class="n">task</span><span class="p">,</span> <span class="n">id</span>  <span class="n">_Nonnull</span> <span class="n">responseObject</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//这里知道得到的数据是一张图片，所以就直接这样生成图片了
</span>    <span class="n">self</span><span class="p">.</span><span class="n">imgView</span><span class="p">.</span><span class="n">image</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIImage</span> <span class="nf">imageWithData</span><span class="p">:</span><span class="n">responseObject</span><span class="p">];</span>
    
<span class="p">}</span> <span class="n">failure</span><span class="o">:^</span><span class="p">(</span><span class="n">NSURLSessionDataTask</span> <span class="o">*</span> <span class="n">_Nonnull</span> <span class="n">task</span><span class="p">,</span> <span class="n">NSError</span> <span class="o">*</span> <span class="n">_Nonnull</span> <span class="n">error</span><span class="p">)</span> <span class="p">{</span>
    
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"%@"</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
    
<span class="p">}];</span>
</code></pre>
</div>
<p>从[AFHTTPSessionManager GET:parameters:success:failure:]方法来一步一步看看，manager都什么了什么。</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="n">NSURLSessionDataTask</span> <span class="o">*</span><span class="p">)</span><span class="nf">GET</span><span class="p">:(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">URLString</span>
                   <span class="nf">parameters</span><span class="p">:(</span><span class="n">id</span><span class="p">)</span><span class="nv">parameters</span>
                      <span class="nf">success</span><span class="p">:(</span><span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="n">NSURLSessionDataTask</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="n">id</span> <span class="n">responseObject</span><span class="p">))</span><span class="nv">success</span>
                      <span class="nf">failure</span><span class="p">:(</span><span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="n">NSURLSessionDataTask</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">))</span><span class="nv">failure</span>
<span class="p">{</span>
    <span class="n">NSURLSessionDataTask</span> <span class="o">*</span><span class="n">dataTask</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nf">dataTaskWithHTTPMethod</span><span class="p">:</span><span class="s">@"GET"</span> <span class="nf">URLString</span><span class="p">:</span><span class="n">URLString</span> <span class="n">parameters</span><span class="o">:</span><span class="n">parameters</span> <span class="n">success</span><span class="o">:</span><span class="n">success</span> <span class="n">failure</span><span class="o">:</span><span class="n">failure</span><span class="p">];</span>

    <span class="p">[</span><span class="n">dataTask</span> <span class="nf">resume</span><span class="p">];</span>

    <span class="k">return</span> <span class="n">dataTask</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>代码还是很少的，就是根据给定的URL地址调用本类的[AFHTTPSessionManager:dataTaskWithHTTPMethod:URLString:parameters:success:failure]方法生成一个dataTask然后启动它。这方法比较关键，一起来看看：</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="n">NSURLSessionDataTask</span> <span class="o">*</span><span class="p">)</span><span class="nf">dataTaskWithHTTPMethod</span><span class="p">:(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">method</span>
                                       <span class="nf">URLString</span><span class="p">:(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">URLString</span>
                                      <span class="nf">parameters</span><span class="p">:(</span><span class="n">id</span><span class="p">)</span><span class="nv">parameters</span>
                                         <span class="nf">success</span><span class="p">:(</span><span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="n">NSURLSessionDataTask</span> <span class="o">*</span><span class="p">,</span> <span class="n">id</span><span class="p">))</span><span class="nv">success</span>
                                         <span class="nf">failure</span><span class="p">:(</span><span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="n">NSURLSessionDataTask</span> <span class="o">*</span><span class="p">,</span> <span class="n">NSError</span> <span class="o">*</span><span class="p">))</span><span class="nv">failure</span>
<span class="p">{</span>
    <span class="n">NSError</span> <span class="o">*</span><span class="n">serializationError</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
    <span class="c1">//设置request，根据HTTP的请求方法添加参数
</span>    <span class="n">NSMutableURLRequest</span> <span class="o">*</span><span class="n">request</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">requestSerializer</span> <span class="nf">requestWithMethod</span><span class="p">:</span><span class="n">method</span> <span class="nf">URLString</span><span class="p">:[[</span><span class="n">NSURL</span> <span class="nf">URLWithString</span><span class="p">:</span><span class="n">URLString</span> <span class="nf">relativeToURL</span><span class="p">:</span><span class="n">self</span><span class="p">.</span><span class="nf">baseURL</span><span class="p">]</span> <span class="n">absoluteString</span><span class="p">]</span> <span class="n">parameters</span><span class="o">:</span><span class="n">parameters</span> <span class="n">error</span><span class="o">:&amp;</span><span class="n">serializationError</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">serializationError</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">failure</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">dispatch_async</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">completionQueue</span> <span class="p">?:</span> <span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
                <span class="n">failure</span><span class="p">(</span><span class="nb">nil</span><span class="p">,</span> <span class="n">serializationError</span><span class="p">);</span>
            <span class="p">});</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="nb">nil</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">__block</span> <span class="n">NSURLSessionDataTask</span> <span class="o">*</span><span class="n">dataTask</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
    <span class="c1">//这个方法调用的是父类的方法
</span>    <span class="n">dataTask</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nf">dataTaskWithRequest</span><span class="p">:</span><span class="n">request</span> <span class="nf">completionHandler</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">NSURLResponse</span> <span class="o">*</span> <span class="n">__unused</span> <span class="n">response</span><span class="p">,</span> <span class="n">id</span> <span class="n">responseObject</span><span class="p">,</span> <span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">failure</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">failure</span><span class="p">(</span><span class="n">dataTask</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">success</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">success</span><span class="p">(</span><span class="n">dataTask</span><span class="p">,</span> <span class="n">responseObject</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}];</span>

    <span class="k">return</span> <span class="n">dataTask</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>
<p>之所以说很关键，是因为它做了两次事，一是生成request，二是调用了父类的方法，用于设置代理，回调之类的，前面说过AFHTTPSessionManager继承自AFURLSessionManager的。这样AFHTTPSessionManager把剩下的部分全部分交给了AFURLSessionManager部分。对于AFURLSessionManager不熟悉的请求出门左拐。库中的AFURLRequestSerialization和AFHTTPResponseSerializer也挺重要的，找个时间看看。到这里整个库也差不多看了一半多吧。写的这些都是根据官方给出的用法，去一点一点看探究它的实现。刚开始的时候，笔者也想造个轮子，但是慢慢地发现造轮子考虑的东西太多，费时费力，而且又有写好开源的轮子，何不拿来用呢。世界这么大，得把时间用到别的地方去。用归用，但是也得看看源码，看看人家是怎么实现的，不是一个好的使用者，肯定不适合造轮子。</p>

<p>–EOF–</p>

                    ]]>
                </content:encoded>
                <guid isPermaLink="false">/objective-c/http/2017/05/19/AFNetworking3.0%E4%B9%8BHTTP%E8%AF%B7%E6%B1%82/</guid>
                <description>
                    
                    本文主要分析AFNetworking的HTTP请求部分。
                    
                </description>
                <pubDate>Fri, 19 May 2017 00:00:00 +0800</pubDate>
                <author>冬阳</author>
            </item>
        
    
        
            <item>
                <title>POSIX线程之条件变量</title>
                <link>http://localhost:4000/posix%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/2017/05/16/POSIX%E7%BA%BF%E7%A8%8B%E4%B9%8B%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/</link>
                <content:encoded>
                    <![CDATA[
                    <p>标签： POSIX多线程 条件变量</p>

<h2 id="前言">前言</h2>

<p>这两天看POSIX线程的时候，看到了一道题。问题大概这样的：启动三个线程，线程1打印A，线程2打印B，线程3打印C，三个线程打印的顺序要求为ABC，循环打印10次，也就是ABCABCABC….。这里的关键是要实现三个线程的协作，每次循环都要控制，只有线程1打印A，线程2再打印，然后再是线程3。这里涉及到了线程的同步问题，分别用到了互斥量和条件变量。</p>

<h2 id="正文">正文</h2>

<h3 id="线程同步">线程同步</h3>

<p>在多个控制线程共享内存的时候，需要确保每个线程看到的数据都是一致的。如果每个线程使用的变量，其他线程都不会修改，或者当变量是只读的时候，不会存在不一致的问题。但是当一个线程使用变量的时候，其他线程也可以读取或者修改的时候，就会出现数据不一致的问题。</p>

<!-- 存取时间是指启动一次存储器操作到完成该操作所需的时间。具体地说，读出时为取数时间，写入时为存数时间。取数时间就是指存储器从接受读命令到信息被读出并稳定在存储器数据寄存器中所需的时间；存数时间就是指存储器从接受写命令到把数据从存储器数据寄存器的输出端传送到存储单元所需的时间。 -->

<p>在变量修改时间多于一个存储器访问周期的处理器结构中，当存储器读与存储器写这两个周期交叉时，这种不一致就会出现。存储器访问周期是指连续启动两次独立的存储操作所需间隔的最小时间，存储器的两个基本的操作为读入和写出，指将数据在存储单元与存储寄存器（MDR）之间进行读和写。在读取变量的时候，只有要一个存储器周期，但是修改变量的时候需要两个存储器周期。以n++为例，这条语句并非原子操作，它可以分解为以下三个操作：</p>
<ol>
  <li>从内存单元读入寄存器</li>
  <li>在寄存器中对变量++</li>
  <li>将新的值写回内存单元</li>
</ol>

<p>PS：原子操作是一旦开始就一直运行到结束，中间不会有任何的上下文切换，因此不需要同步。</p>

<p>如果两线程几乎在同一时间对同一个变量做增量操作而不进行同步的话，结果可能出现比原来增加了1也可能增加了2，具体要看第二个线程的开始操作获取的数值。</p>

<h3 id="互斥量">互斥量</h3>

<p>互斥量可以确保在同一时间内只有一个线程访问数据，本质上讲就是一把锁。对于使用了互斥量保护的数据而言，谁先得到这把锁谁就先访问到数据，并且把数据锁住不让其他线程访问，如果此时有其他线程想要访问数据会因没有得到锁而进行阻塞状态，在处理完数据之后，把锁解开，这时其他线程才可以访问。这时间其他线程看到锁解开了，就会由阻塞变为可运行状态。</p>

<p>这里由此也引出了，互斥量使用不当的情况下，容易产生死锁。例如，如果线程试图对同一个互斥量加锁两次，那么它自身就会陷入死锁状态。还有程序中使用一个以上的互斥量时，如果一个线程一直占有第一个互斥量，并且试图锁住第二个互斥量时处于阻塞状态，但此时有一个线程在拥有了第二个互斥量时也在试图锁住第一个互斥量时，会因为两个线程都在相互请求另一个线程拥有的资源而无法前进，于是就产生死锁。</p>

<h3 id="条件变量">条件变量</h3>

<p>条件变量是线程的另一种同步机制，与互斥一起使用时，允许线程以无竞争的等待方式等待特定的条件发生。它由互斥量保护，在线程改变条件之前必须首先锁住互斥量。</p>

<p>回到前面提到的问题。前面说了，解法用到了互斥量和条件变量，来看看怎么用的：</p>
<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="cp">#include&lt;iostream&gt;
#include &lt;pthread.h&gt;
</span>
<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">flag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">pthread_cond_t</span> <span class="n">printReady</span> <span class="o">=</span> <span class="n">PTHREAD_COND_INITIALIZER</span><span class="p">;</span>
<span class="n">pthread_mutex_t</span> <span class="n">printLock</span> <span class="o">=</span> <span class="n">PTHREAD_MUTEX_INITIALIZER</span><span class="p">;</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">printA</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        
        <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">printLock</span><span class="p">);</span>
        
        <span class="k">while</span> <span class="p">(</span><span class="n">flag</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">printReady</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">printLock</span><span class="p">);</span>
            
        <span class="p">}</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">);</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
        <span class="n">pthread_cond_broadcast</span><span class="p">(</span><span class="o">&amp;</span><span class="n">printReady</span><span class="p">);</span>
        
        <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">printLock</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">printB</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>

        <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">printLock</span><span class="p">);</span>
        
        <span class="k">while</span> <span class="p">(</span><span class="n">flag</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">printReady</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">printLock</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">);</span>

        <span class="n">flag</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
        <span class="n">pthread_cond_broadcast</span><span class="p">(</span><span class="o">&amp;</span><span class="n">printReady</span><span class="p">);</span>
        
        <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">printLock</span><span class="p">);</span>
        
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">printC</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>

        <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">printLock</span><span class="p">);</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">flag</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">printReady</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">printLock</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">);</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="n">pthread_cond_broadcast</span><span class="p">(</span><span class="o">&amp;</span><span class="n">printReady</span><span class="p">);</span>
        
        <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">printLock</span><span class="p">);</span>
        
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mi">3</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>

    <span class="n">pthread_t</span> <span class="n">tid1</span><span class="p">,</span> <span class="n">tid2</span><span class="p">,</span> <span class="n">tid3</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">ret</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
    <span class="n">err</span> <span class="o">=</span> <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">printA</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="s">"A"</span><span class="p">);</span>

    <span class="n">err</span> <span class="o">=</span> <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid2</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">printB</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="s">"B"</span><span class="p">);</span>
    
    <span class="n">err</span> <span class="o">=</span> <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid3</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">printC</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="s">"C"</span><span class="p">);</span>
    
    
    <span class="n">err</span> <span class="o">=</span> <span class="n">pthread_join</span><span class="p">(</span><span class="n">tid1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ret</span><span class="p">);</span>
    <span class="n">err</span> <span class="o">=</span> <span class="n">pthread_join</span><span class="p">(</span><span class="n">tid2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ret</span><span class="p">);</span>
    <span class="n">err</span> <span class="o">=</span> <span class="n">pthread_join</span><span class="p">(</span><span class="n">tid3</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ret</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>这里先来解释几个关于条件变量的函数：</p>
<ul>
  <li><code class="highlighter-rouge">pthread_cond_signal()</code>:发送一个信号给正在当前条件变量的线程队列中处于阻塞等待状态的线程，使其脱离阻塞状态，唤醒后继续执行。如果没有线程处在阻塞等待状态，pthread_cond_signal也会成功返回。一般只给一个阻塞状态的线程发信号。假如有多个线程正在阻塞等待当前条件变量，则根据各等待线程优先级的高低确定哪个线程接收到信号开始继续执行。如果各线程优先级相同，则根据等待时间的长短来确定哪个线程获得信号。但pthread_cond_signal在多处理器上可能同时唤醒多个线程，当只能让一个被唤醒的线程处理某个任务时，其它被唤醒的线程就需要继续wait。POSIX规范要求pthread_cond_signal至少唤醒一个pthread_cond_wait上的线程，有些实现为了简便，在单处理器上也会唤醒多个线程。</li>
  <li><code class="highlighter-rouge">pthread_cond_wait()</code>:等待条件变量的特殊条件发生；pthread_cond_wait() 必须与一个pthread_mutex配套使用。该函数调用实际上依次做了3件事：对当前pthread_mutex解锁、把当前线程挂起到当前条件变量的线程队列、被其它线程的信号唤醒后对当前pthread_mutex申请加锁。如果线程收到一个信号被唤醒，将被配套的互斥锁重新锁住，pthread_cond_wait() 函数将不返回直到线程获得配套的互斥锁。需要注意的是，一个条件变量不应该与多个互斥锁配套使用。</li>
  <li><code class="highlighter-rouge">pthread_cond_broadcast()</code>:某些应用，如线程池，pthread_cond_broadcast唤醒全部线程，但我们通常只需要一部分线程去做执行任务，所以其它的线程需要继续wait。</li>
</ul>

<p>在上面的代码中有一处比较重要，就是<code class="highlighter-rouge">pthread_cond_wait()</code>调用包裹在一个while循环里面，我刚开始的时候是用if来判断的。以printA为例，当flag不满足时，会释放互斥量进入阻塞状态并等待条件发生。其他线程修改了flag之后，随即调用<code class="highlighter-rouge">pthread_cond_broadcast()</code>唤醒其他正在等待条件变量的线程，这时其他两个线程都会从<code class="highlighter-rouge">pthread_cond_wait()</code>调用处返回。但满足flag条件的线程只有一个，这时while循环会再次判断flag条件，满足条件的线程会被唤醒，不满足的会继续阻塞。如果将while改为if，那么那个不满足flag条件的线程也会被唤醒。这里while循环实际上的作用就是只将满足条件的线程唤醒，不满足的继续等待。while还有一个另外一个作用，即线程可能不是由<code class="highlighter-rouge">pthread_cond_signal</code>和<code class="highlighter-rouge">pthread_cond_broadcast</code>唤醒，而是被中断唤醒。这种情况下，也需要重新对flag进行判断。</p>

<p>–EOF–</p>

<h2 id="参考">参考</h2>

<ul>
  <li><a href="http://blog.vladimirprus.com/2005/07/spurious-wakeups.html">Spurious wakeups</a></li>
</ul>

                    ]]>
                </content:encoded>
                <guid isPermaLink="false">/posix%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/2017/05/16/POSIX%E7%BA%BF%E7%A8%8B%E4%B9%8B%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/</guid>
                <description>
                    
                    条件变量是线程可用的另一种同步机制。条件变量给多个线程提供了一个会合的场所。
                    
                </description>
                <pubDate>Tue, 16 May 2017 00:00:00 +0800</pubDate>
                <author>冬阳</author>
            </item>
        
    
        
            <item>
                <title>RunLoop小记</title>
                <link>http://localhost:4000/objective-c/runloop/2017/05/09/RunLoop%E5%B0%8F%E8%AE%B0/</link>
                <content:encoded>
                    <![CDATA[
                    <p>标签： objective-c RunLoop</p>

<hr />

<h2 id="前言">前言</h2>

<p>本文主要从RunLoop是什么，如何使用RunLoop，它和线程之间的关系以及在编程中可能用到的地方来介绍RunLoop。现在CoreFoundation开源了，你可以在<a href="http://opensource.apple.com/tarballs/CF/">这里</a>下载源码。</p>

<h2 id="正文">正文</h2>

<p>RunLoop是什么？在windows下用MFC做过开发的人对于基于消息循环的事件处理机制应该不会陌生，RunLoop和其差不多。从名字上看，它是一个loop而且是一个带条件的，同时又是一个”死循环”，但是它又很特殊，在没有事干的时候，这个循环处于闲等待的状态。写一个死循环容易：</p>
<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="p">{</span>

<span class="p">}</span>
</code></pre>
</div>
<p>如果RunLoop是这样做的话，那么也就没什么值研究的了。所以说它是一种带条件的循环，那么又是什么条件呢？那就是消息或者事件，RunLoop是一个基于消息的循环。当没有消息的时候，它就会进入休眠，内核会将其挂起也就是：我睡觉了，没事别叫我。当有消息来的时候就加入到这个循环里时，内核就会将其唤醒，然后对消息进行处理，也就是：睡你XX，起来嗨。形象一点就是：</p>
<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="err">程序员</span> <span class="o">=</span> <span class="err">死了没</span><span class="p">();</span>
<span class="k">while</span><span class="p">(</span><span class="err">程序员</span><span class="p">)</span>
<span class="p">{</span>
    <span class="err">有事干了</span> <span class="o">=</span> <span class="err">我睡觉了没事别叫我</span><span class="p">();</span>
    <span class="k">if</span><span class="p">(</span><span class="err">该搬砖了</span><span class="p">){</span>
        <span class="err">搬砖</span><span class="p">();</span>
    <span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="err">该吃饭了</span><span class="p">){</span>
        <span class="err">吃饭</span><span class="p">();</span>
    <span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="err">该陪妹子了</span><span class="p">){</span>
        <span class="err">@</span><span class="n">throw</span><span class="p">(</span><span class="err">你没妹子</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>RunLoop是和线程配合使用的，一般来说一个线程执行用来执行一个任务，执行完之后就会退出。当我们启动应用程序的时候，默认启动了一个主线程，所有的UI界面都是运行在主线程里的。但是启动后应用程序并不会马上就退出，而是一直运行在那里，等待用户的输入。正常情况下，应该是启动完成后，就会退出。正是RunLoop，才使得应用程序一直运行着。线程刚创建的时候并没有RunLoop（主线程除外），如果不去主动获取。RunLoop的创建发生在第一次获取时，销毁发生在线程结束时。用户只能在一个线程内部获取其RunLoop（主线程除外）。</p>

<p>如何像主线程一样，让我们创建的线程成为常驻线程，当有任务的时候，就交线这个线程去执行。后面的例子中会提到。</p>

<h3 id="runloop工作">RunLoop工作</h3>

<p>先来看看，在我们启动一个应用程序的时候，观察一下主线程的RunLoop的状态。首先说一下，RunLoop的工作的mode：</p>
<ul>
  <li>
    <div><font color="#FF6100">NSDefaultRunLoopMode</font>：RunLoop的默认Mode，空闲状态，也就是什么也不干的时候。</div>
  </li>
  <li>
    <div><font color="#FF6100">UITrackingRunLoopMode</font>：有滑动等其它需要追踪的事件发生时，RunLoop处于此Mode，比如在滚动scrollView时。</div>
  </li>
  <li>
    <div><font color="#FF6100">NSInitializationRunLoopMode</font>：这是一个Private RunLoopMode，App启动时处于此Mode，启动完成进入App主界面后App处于NSDefaultRunLoopMode。</div>
  </li>
  <li>
    <div><font color="#FF6100">NSRunLoopCommonModes</font>：此Mode默认包含了NSDefaultRunLoopMode和UITrackingRunLoopMode。所以，当RunLoop运行在NSDefaultRunLoopMode或UITrackingRunLoopMode时，监听NSRunLoopCommonModes的Observer都会被回调。另外，还可以向NSRunLoopCommonModes里添加其它自定义的Mode。</div>
  </li>
</ul>

<p>每个mode下面又有timer，source和observer。timer是基于时间的触发器，我们在创建timer完的时候一定要把timer放进当前线程的RunLoop中，如果不是主线程还要将这个RunLoop启动，不然这个timer是不会触发的。source是事件产生的地方，系统提供了两个版本，也可以自定义source：</p>
<ul>
  <li>
    <div><font color="#FF6100">source0</font>：处理App内部事件(特指non-port-based事件，这里的事件是一个广义的事件，包括但不限于UI事件)，App负责管理自己的事件触发，如：UIEvent(Touch事件等，GS发起到RunLoop运行再到事件回调到UI)、CFSocketRef。</div>
  </li>
  <li>
    <div><font color="#FF6100">source1</font>：由RunLoop和内核管理，由Mach port驱动（特指port-based事件），如CFMachPort、CFMessagePort、NSSocketPort。特别要注意一下Mach port的概念，它是一个轻量级的进程间通讯的方式，可以理解为它是一个通讯通道，假如同时有几个进程都挂在这个通道上，那么其它进程向这个通道发送消息后，这些挂在这个通道上的进程都可以收到相应的消息。这个Port的概念非常重要，因为它是RunLoop休眠和被唤醒的关键，它是RunLoop与系统内核进行消息通讯的窗口。</div>
  </li>
</ul>

<p>observe是用来监听RunLoop的状态的，RunLoop有以下几种状态：</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="cm">/* Run Loop Observer Activities */</span>
<span class="k">typedef</span> <span class="nf">CF_OPTIONS</span><span class="p">(</span><span class="n">CFOptionFlags</span><span class="p">,</span> <span class="n">CFRunLoopActivity</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">kCFRunLoopEntry</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span> <span class="c1">//InputSource/Timer已经加入到RunLoop了
</span>    <span class="n">kCFRunLoopBeforeTimers</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span> <span class="c1">//Timer即将要被执行了
</span>    <span class="n">kCFRunLoopBeforeSources</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">),</span> <span class="c1">//InputSource即将要被执行了
</span>    <span class="n">kCFRunLoopBeforeWaiting</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">),</span> <span class="c1">//RunLoop即将休眠了
</span>    <span class="n">kCFRunLoopAfterWaiting</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">),</span> <span class="c1">//RunLoop即将被唤醒
</span>    <span class="n">kCFRunLoopExit</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">),</span> <span class="c1">//RunLoop停止运转了
</span>    <span class="n">kCFRunLoopAllActivities</span> <span class="o">=</span> <span class="mh">0x0FFFFFFFU</span>
<span class="p">}</span>
</code></pre>
</div>
<p>可以看到前四个描述了一个RunLoop的循环周期。</p>
<h3 id="runloop和nsautoreleasepool的关系">RunLoop和NSAutoreleasePool的关系</h3>

<p>这里得说一下NSAutoreleasePool，先来看看官方文档中怎么说的：</p>
<blockquote>
  <p>The Application Kit creates an autorelease pool on the main thread at the beginning of every cycle of the event loop, and drains it at the end, thereby releasing any autoreleased objects generated while processing an event. If you use the Application Kit, you therefore typically don’t have to create your own pools. If your application creates a lot of temporary autoreleased objects within the event loop, however, it may be beneficial to create “local” autorelease pools to help to minimize the peak memory footprint.</p>
</blockquote>

<p>意思是说，应用程序在主线程每个事件循环周期的开始中创建一个自动释放池，在这个循环周期结束的时候，把自动释放池排干，即把注册到自动释放池里的对象全部释放掉。之前笔者一直不太明白，自动释放池是怎么释放对象的。说完了来让我们试验一波：</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="c1">//ViewController.m
</span><span class="k">@interface</span> <span class="nc">ViewController</span> <span class="p">()</span>
<span class="c1">//注意label的内存管理语义，用weak也可以，不过weak在赋完值后，输出不了正确结果后面会解释
</span><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">assign</span><span class="p">)</span> <span class="n">UILabel</span> <span class="o">*</span><span class="n">label</span><span class="p">;</span>
<span class="k">@end</span>
<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">viewDidLoad</span>
<span class="p">{</span>
    <span class="p">[</span><span class="n">super</span> <span class="nf">viewDidLoad</span><span class="p">];</span>
    
    <span class="c1">//创建子线程执行任务
</span>    <span class="n">self</span><span class="p">.</span><span class="kr">thread</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSThread</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">initWithTarget</span><span class="p">:</span><span class="n">self</span> <span class="nf">selector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">run</span><span class="p">)</span> <span class="n">object</span><span class="o">:</span><span class="nb">nil</span><span class="p">];</span>
    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="kr">thread</span> <span class="nf">setName</span><span class="p">:</span><span class="s">@"com.thread"</span><span class="p">];</span>
    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="kr">thread</span> <span class="nf">start</span><span class="p">];</span>

<span class="p">}</span>
<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">addRunLoopObserver</span>
<span class="p">{</span>
    
    <span class="c1">//添加RunLoop监听,需要使用CFRunLoop，因为NSRunloop没有这个功能
</span>    
    <span class="c1">//1.获取runloop
</span>    <span class="n">CFRunLoopRef</span> <span class="n">runLoop</span> <span class="o">=</span> <span class="n">CFRunLoopGetCurrent</span><span class="p">();</span>
    
    <span class="c1">//2.1创建上下文
</span>    <span class="n">CFRunLoopObserverContext</span> <span class="n">context</span> <span class="o">=</span> <span class="p">{</span>
        
        <span class="mi">0</span><span class="p">,</span> <span class="c1">//这个context的版本
</span>        <span class="p">(</span><span class="n">__bridge</span> <span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">self</span><span class="p">),</span> <span class="c1">//传入的参数，这里我传入控制器
</span>        <span class="n">CFRetain</span><span class="p">,</span> <span class="c1">//告诉它retain是调用哪个函数
</span>        <span class="n">CFRelease</span><span class="p">,</span> <span class="c1">//告诉它release是调用哪个函数
</span>        <span class="nb">nil</span><span class="p">,</span>
    <span class="p">};</span>
    
    <span class="c1">//2.2创建runloop观察者
</span>    <span class="cm">/*
     CFRunLoopObserverRef CFRunLoopObserverCreate(CFAllocatorRef allocator,
     CFOptionFlags activities,
     Boolean repeats,
     CFIndex order,
     CFRunLoopObserverCallBack callout,
     CFRunLoopObserverContext *context);
     
     @param allocator：这个参数用来分配空间给新的对象。默认情况下使用NULL或者kCFAllocatorDefault。
     @param activities：设置Runloop的运行阶段的标志，当运行到此阶段时，CFRunLoopObserver会被调用
     @param repeats：CFRunLoopObserver是否循环调用，false为单词调用，否则循环调用。
     @param order：CFRunLoopObserver的优先级，当在Runloop同一运行阶段中有多个CFRunLoopObserver时，根据这个来先后调用CFRunLoopObserver。正常情况下使用0。
     @param callout：回调函数
     @param context：CFRunLoopObserver结构体里面的一个结构体，它主要用来给回调函数传递消息的。
     @return CFRunLoopObserverRef：观察者指针对象
     */</span>
    <span class="n">CFRunLoopObserverRef</span> <span class="n">observer</span> <span class="o">=</span> <span class="n">CFRunLoopObserverCreate</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span>
                                                            <span class="n">kCFRunLoopBeforeWaiting</span><span class="p">,</span>
                                                            <span class="nb">YES</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                                                            <span class="n">callBack</span><span class="p">,</span>
                                                            <span class="o">&amp;</span><span class="n">context</span><span class="p">);</span>
    
    <span class="c1">//3.给runloop添加观察者
</span>    <span class="n">CFRunLoopAddObserver</span><span class="p">(</span><span class="n">runLoop</span><span class="p">,</span> <span class="n">observer</span><span class="p">,</span> <span class="n">kCFRunLoopCommonModes</span><span class="p">);</span>
    
<span class="p">}</span>


<span class="cm">/**
 回调函数,在kCFRunLoopBeforeWaiting（runloop等待执行循环之前）情况下调用，因为定时器给的是0.1秒，所以这里调用非常频繁，保证一次循环执行一个任务
 
 @param observer 观察者对象
 @param activity Runloop的运行阶段的标志
 @param info CFRunLoopObserverContext传入的参数
 */</span>
<span class="kt">void</span> <span class="n">callBack</span><span class="p">(</span><span class="n">CFRunLoopObserverRef</span> <span class="n">observer</span><span class="p">,</span> <span class="n">CFRunLoopActivity</span> <span class="n">activity</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
    
    <span class="c1">//1.拿到传过来的参数，再进行转换,因为这是C函数，不能直接调用self，所以在添加观察的时候把self传过来。
</span>    <span class="n">ViewController</span> <span class="o">*</span><span class="n">vc</span> <span class="o">=</span> <span class="p">(</span><span class="n">__bridge</span> <span class="n">ViewController</span> <span class="o">*</span><span class="p">)(</span><span class="n">info</span><span class="p">);</span>
    
    <span class="c1">//2.看看我们刚才设置的label，在这个循环同期内是否有值，可以看到是有值的。
</span>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"%@"</span><span class="p">,</span><span class="n">vc</span><span class="p">.</span><span class="n">label</span><span class="p">.</span><span class="n">text</span><span class="p">);</span>
<span class="p">}</span>
<span class="o">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">run</span>
<span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"跑起来"</span><span class="p">);</span>
    <span class="err">@autoreleasepool</span> <span class="p">{</span>
        <span class="c1">//这里生成的UILabel就注册到一个自动释放池里了，并且生成后并没有马上释放，也就是说self.label还是有值的哦，可以正常使用，但是编译器给出警告
</span>        <span class="n">self</span><span class="p">.</span><span class="n">label</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UILabel</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">init</span><span class="p">];</span>
        <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">label</span> <span class="nf">setText</span><span class="p">:</span><span class="s">@"这是一个标签"</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="c1">//默认情况下,子线程是不会常驻的
</span>    <span class="c1">//只有子线程中runloop启动,并且runloop中有source或timer,才会常驻
</span>    <span class="c1">//只有常驻线程才能再次执行任务,因为线程中有runloop来处理事件了
</span>    <span class="n">NSRunLoop</span> <span class="o">*</span> <span class="n">rl</span> <span class="o">=</span>  <span class="p">[</span><span class="n">NSRunLoop</span> <span class="nf">currentRunLoop</span><span class="p">];</span>
    
    <span class="c1">//向线程添加一个port，这样可以维持线程，使其成为常驻线程，当然也可以添加一个timer/source像这样
</span>    <span class="c1">//[NSTimer scheduledTimerWithTimeInterval:2 target:self selector:@selector(timerRun) userInfo:nil repeats:YES];
</span>    <span class="p">[</span><span class="n">rl</span> <span class="nf">addPort</span><span class="p">:[</span><span class="n">NSMachPort</span> <span class="nf">port</span><span class="p">]</span> <span class="nf">forMode</span><span class="p">:</span><span class="n">NSDefaultRunLoopMode</span><span class="p">];</span>

    <span class="c1">//添加RunLoopObserver
</span>    <span class="p">[</span><span class="n">self</span> <span class="nf">addRunLoopObserver</span><span class="p">];</span>

    <span class="c1">//启动runloop
</span>    <span class="p">[</span><span class="n">rl</span> <span class="nf">run</span><span class="p">];</span>
    
    <span class="c1">//如果线程成为了常驻线程,你会发现,不会执行到这行代码
</span>    <span class="c1">//也就是说这个方法不会执行完,
</span>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"end"</span><span class="p">);</span>
<span class="p">}</span>
<span class="o">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">timerRun</span>
<span class="p">{</span>
    <span class="c1">//这时不干事，只是用来维持子线程，timer的时间也可以用来设置循环同期的时候，
</span><span class="p">}</span>
<span class="o">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">touchesBegan</span><span class="o">:</span><span class="p">(</span><span class="n">NSSet</span><span class="o">&lt;</span><span class="n">UITouch</span> <span class="o">*&gt;</span> <span class="o">*</span><span class="p">)</span><span class="n">touches</span> <span class="n">withEvent</span><span class="o">:</span><span class="p">(</span><span class="n">UIEvent</span> <span class="o">*</span><span class="p">)</span><span class="n">event</span>
<span class="p">{</span>
    <span class="c1">// 让子线程再次执行任务
</span>    <span class="p">[</span><span class="n">self</span> <span class="nf">performSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">againRun</span><span class="p">)</span> <span class="nf">onThread</span><span class="p">:</span><span class="n">self</span><span class="p">.</span><span class="kr">thread</span> <span class="n">withObject</span><span class="o">:</span><span class="nb">nil</span> <span class="n">waitUntilDone</span><span class="o">:</span><span class="nb">NO</span><span class="p">];</span>
<span class="p">}</span>
<span class="o">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">againRun</span>
<span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"再次跑起来"</span><span class="p">);</span>
    <span class="c1">//下面这行是停止当前线程的RunLoop，这个方法是在我们创建的子线程中不是主线程，加上这一行，再跑一次看看会有什么结果
//    CFRunLoopStop(CFRunLoopGetCurrent());
</span><span class="p">}</span>
</code></pre>
</div>
<p>这把段代码跑一次，输出的结果为：</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="mi">2017</span><span class="o">-</span><span class="mo">05</span><span class="o">-</span><span class="mi">09</span> <span class="mi">11</span><span class="o">:</span><span class="mi">37</span><span class="o">:</span><span class="mi">51</span><span class="p">.</span><span class="mi">134</span> <span class="n">copy</span><span class="p">[</span><span class="mi">92859</span><span class="o">:</span><span class="mi">12314616</span><span class="p">]</span> <span class="err">跑起来</span>
<span class="mi">2017</span><span class="o">-</span><span class="mo">05</span><span class="o">-</span><span class="mi">09</span> <span class="mi">11</span><span class="o">:</span><span class="mi">37</span><span class="o">:</span><span class="mi">51</span><span class="p">.</span><span class="mi">159</span> <span class="n">copy</span><span class="p">[</span><span class="mi">92859</span><span class="o">:</span><span class="mi">12314616</span><span class="p">]</span> <span class="err">这是一个标签</span>
</code></pre>
</div>
<p>当点击屏幕的时候，会在我们创建的线程内执行一次方法<code class="highlighter-rouge">againRun</code>，执行完后，RunLoop就进入了休眠，这时是第二个循环周期，label已经被释放了，所以程序就会因为访问已释放的内存而崩掉。还有一点label的内存管理语义这里设定的为assgin，设置weak的时候也可以但是输也不了正确的结果，通过断点调试的时候确实可以看到当label的内存管理语义为weak的时候，它是有值的，这条语句执行完后<code class="highlighter-rouge">self.label = [[UILabel alloc] init];</code>，label并没有马上释放掉，因为自动释放池延迟了它的释放，正常情况下，赋值完就会立该释放，但这里得不到正确的结果，笔者猜想肯定编译器做了手脚。大家可以将label的内存管理语义改为weak，再跑一次看看。</p>

<h3 id="runloop对timer的影响">RunLoop对timer的影响</h3>

<p>先来看一个例子：</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="c1">//ViewController.m
</span><span class="cp">#import "ViewController.h"
</span>
<span class="k">@interface</span> <span class="nc">ViewController</span> <span class="p">()</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">weak</span><span class="p">,</span> <span class="n">nonatomic</span><span class="p">)</span> <span class="n">IBOutlet</span> <span class="n">UIScrollView</span> <span class="o">*</span><span class="n">scrollView</span><span class="p">;</span>

<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">ViewController</span>

<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">viewDidLoad</span> <span class="p">{</span>
    <span class="p">[</span><span class="n">super</span> <span class="nf">viewDidLoad</span><span class="p">];</span>
    <span class="c1">// Do any additional setup after loading the view, typically from a nib.
</span>    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">scrollView</span> <span class="nf">setContentSize</span><span class="p">:</span><span class="n">CGSizeMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)];</span>
    <span class="n">self</span><span class="p">.</span><span class="n">scrollView</span><span class="p">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>
    <span class="n">NSTimer</span> <span class="o">*</span><span class="n">timer1</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSTimer</span> <span class="nf">timerWithTimeInterval</span><span class="p">:</span><span class="mi">2</span> <span class="nf">target</span><span class="p">:</span><span class="n">self</span> <span class="n">selector</span><span class="o">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">doTimer1</span><span class="p">)</span> <span class="n">userInfo</span><span class="o">:</span><span class="nb">nil</span> <span class="n">repeats</span><span class="o">:</span><span class="nb">YES</span><span class="p">];</span>
    <span class="p">[[</span><span class="n">NSRunLoop</span> <span class="nf">currentRunLoop</span><span class="p">]</span> <span class="nf">addTimer</span><span class="p">:</span><span class="n">timer1</span> <span class="nf">forMode</span><span class="p">:</span><span class="n">NSDefaultRunLoopMode</span><span class="p">];</span>
<span class="p">}</span>
<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">scrollViewDidScroll</span><span class="o">:</span><span class="p">(</span><span class="n">UIScrollView</span> <span class="o">*</span><span class="p">)</span><span class="n">scrollView</span>
<span class="p">{</span>
     <span class="n">NSLog</span><span class="p">(</span><span class="s">@"%@"</span><span class="p">,(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">CFBridgingRelease</span><span class="p">(</span><span class="n">CFRunLoopCopyCurrentMode</span><span class="p">(</span><span class="n">CFRunLoopGetCurrent</span><span class="p">())));</span>
<span class="p">}</span>
<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">touchesBegan</span><span class="o">:</span><span class="p">(</span><span class="n">NSSet</span><span class="o">&lt;</span><span class="n">UITouch</span> <span class="o">*&gt;</span> <span class="o">*</span><span class="p">)</span><span class="n">touches</span> <span class="n">withEvent</span><span class="o">:</span><span class="p">(</span><span class="n">UIEvent</span> <span class="o">*</span><span class="p">)</span><span class="n">event</span>
<span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"%@"</span><span class="p">,(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">CFBridgingRelease</span><span class="p">(</span><span class="n">CFRunLoopCopyCurrentMode</span><span class="p">(</span><span class="n">CFRunLoopGetCurrent</span><span class="p">())));</span>
    
<span class="p">}</span>
<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">touchesMoved</span><span class="o">:</span><span class="p">(</span><span class="n">NSSet</span><span class="o">&lt;</span><span class="n">UITouch</span> <span class="o">*&gt;</span> <span class="o">*</span><span class="p">)</span><span class="n">touches</span> <span class="n">withEvent</span><span class="o">:</span><span class="p">(</span><span class="n">UIEvent</span> <span class="o">*</span><span class="p">)</span><span class="n">event</span>
<span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"%@"</span><span class="p">,(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">CFBridgingRelease</span><span class="p">(</span><span class="n">CFRunLoopCopyCurrentMode</span><span class="p">(</span><span class="n">CFRunLoopGetCurrent</span><span class="p">())));</span>
<span class="p">}</span>
<span class="o">-</span> <span class="p">(</span><span class="n">IBAction</span><span class="p">)</span><span class="n">button</span><span class="o">:</span><span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="n">sender</span>
<span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"%@"</span><span class="p">,(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">CFBridgingRelease</span><span class="p">(</span><span class="n">CFRunLoopCopyCurrentMode</span><span class="p">(</span><span class="n">CFRunLoopGetCurrent</span><span class="p">())));</span>
<span class="p">}</span>
<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">doTimer1</span>
<span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"timer go"</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">@end</span>
</code></pre>
</div>
<p>当程序跑起来什么也不干就会每隔一秒，控制台输入一个timer go，但是如果我们不停的滑动scrollView，控制台就停止输出了。因为这个timer运行在NSDefaultRunLoopMode下，只有当RunLoop在这个mode下才会执行timer，当程序运行的时候，我们没做任何事，Runloop就处在这个mode下，等待用户的输入。但是当我们滑动scrollView时，RunLoop由NSDefaultRunLoopMode转到了UITrackingRunLoopMode下，就不会执行timer了。在点击按钮，滑动scrollView,点击屏幕和移动屏幕中可以看到mode的变化。</p>

<h2 id="总结">总结</h2>

<p>最后以一个RunLoop的应用场景结束本文。在有UITableView的控制器里，滑动UITableView加载图片时，主线程会把图片设置到cell上，如果这时你同时又滑动tableView，会因为主线程同时设置图片和滑动而造成到卡顿的现象。知道了RunLoop后，在滑动的时候，让子线程去处理网络请求，当停止滑动的时候，这时RunLoop进入到了NSDefaultRunLoopMode下，这时让主线程去设置图片。这样实现的话，代码只有一句：</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="n">UIImage</span> <span class="o">*</span><span class="n">downloadImage</span> <span class="o">=</span> <span class="p">.....</span>
<span class="p">[</span><span class="n">self</span> <span class="nf">performSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nf">setImage</span><span class="p">:)</span> <span class="n">withObject</span><span class="o">:</span><span class="n">downloadImage</span> <span class="n">afterDelay</span><span class="o">:</span><span class="mi">0</span> <span class="n">inModes</span><span class="o">:</span><span class="n">NSDefaultRunLoopMode</span><span class="p">];</span>
</code></pre>
</div>

<p>–EOF–
<!-- 下次研究CFRunLoop中的CFRunLoopTimer和CFRunLoopSource --></p>

<h2 id="参考">参考</h2>
<ul>
  <li><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1">Threading Programming Guide – iOS Developer Library</a></li>
  <li><a href="http://v.youku.com/v_show/id_XODgxODkzODI0.html">视频: iOS线下分享《RunLoop》by 孙源@sunnyxx</a></li>
  <li><a href="http://blog.ibireme.com/2015/05/18/runloop/">深入理解RunLoop</a></li>
  <li><a href="http://blog.handy.wang/blog/2014/05/26/runloopxue-xi-bi-ji-1/">RunLoop学习笔记</a></li>
</ul>

                    ]]>
                </content:encoded>
                <guid isPermaLink="false">/objective-c/runloop/2017/05/09/RunLoop%E5%B0%8F%E8%AE%B0/</guid>
                <description>
                    
                    RunLoop实际上是一个消息循环，用于处理消息的，只不过它是一种带条件的循环。
                    
                </description>
                <pubDate>Tue, 09 May 2017 00:00:00 +0800</pubDate>
                <author>冬阳</author>
            </item>
        
    
        
            <item>
                <title>oc中的黑魔法attribute</title>
                <link>http://localhost:4000/objective-c/attribute/2017/05/06/oc%E4%B8%AD%E7%9A%84%E9%BB%91%E9%AD%94%E6%B3%95attribute/</link>
                <content:encoded>
                    <![CDATA[
                    <p>标签： objective-c attribute</p>

<hr />

<h2 id="前言">前言</h2>

<p>__attribute__其实是一个编译器指令，用于指定一些声明中特性包括函数声明和变量声明，这样一来可以编译器可以执行一些错误检查或是进行一些高级的优化。说的直白一点就是对声明加一点限制，拿函数而言，可以用__attribute__来限制形参不为空，这样一来，可以保证在编程的过程，函数调用形参一定是不为空的。这只是其中一个用法。这个指令对于编写框架以及更新框架用的多，在实际的编程中用的不多，下面列出的都是一些用法。</p>

<h2 id="正文">正文</h2>

<p>对这个指令还比较陌生的程序员，那么在编程时候，肯定遇到过这样的情况：当调用一人API时，编译器发出警告说这个API在某某版本中已经被废弃，现在用某某API代替。这其实就是__attribute__的一种用法。</p>

<h4 id="用法">用法</h4>

<p>__attribute__后面是由两组圆括号，括号内的属性由逗号分割，该指令放在函数，变量和类型声明之后。</p>

<p>1.<font color="#FF6100">__attribute__((cleanup(...)))</font>，用于修饰一个变量，在它的作用域结束时可以自动执行一个指定的方法，如：</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="c1">// 指定一个cleanup方法，注意入参是所修饰变量的地址，类型要一样
// 对于指向objc对象的指针(id *)，如果不强制声明__strong默认是__autoreleasing，造成类型不匹配
</span><span class="k">static</span> <span class="kt">void</span> <span class="n">stringCleanUp</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">__strong</span> <span class="o">*</span><span class="n">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"%@"</span><span class="p">,</span> <span class="o">*</span><span class="n">string</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// 在某个方法中：
</span><span class="p">{</span>
     <span class="n">NSString</span> <span class="o">*</span><span class="n">__strong</span> <span class="n">string</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">cleanup</span><span class="p">(</span><span class="n">stringCleanUp</span><span class="p">)))</span> <span class="o">=</span> <span class="s">@"hello"</span><span class="p">;</span>
<span class="p">}</span> <span class="c1">// 当运行到这个作用域结束时，自动调用stringCleanUp
</span></code></pre>
</div>
<p>所谓作用域结束，包括大括号结束、return、goto、break、exception等各种情况。
当然，可以修饰的变量不止NSString，自定义Class或基本类型都是可以的。</p>

<p>这个指令可以修饰变量，当然也就可以修饰block：</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="c1">// void(^block)(void)的指针是void(^*block)(void)
</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">blockCleanUp</span><span class="p">(</span><span class="n">__strong</span> <span class="kt">void</span><span class="p">(</span><span class="o">^*</span><span class="n">block</span><span class="p">)(</span><span class="kt">void</span><span class="p">))</span> <span class="p">{</span>
    <span class="p">(</span><span class="o">*</span><span class="n">block</span><span class="p">)();</span>
<span class="p">}</span>
</code></pre>
</div>
<p>然后我们在一个作用域里来定义一个block变量：</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="p">{</span>
   <span class="c1">// 加了个`unused`的attribute用来消除`unused variable`的warning
</span>    <span class="n">__strong</span> <span class="kt">void</span><span class="p">(</span><span class="o">^</span><span class="n">block</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">cleanup</span><span class="p">(</span><span class="n">blockCleanUp</span><span class="p">),</span> <span class="n">unused</span><span class="p">))</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@"I'm dying..."</span><span class="p">);</span>
    <span class="p">};</span>
<span class="p">}</span> <span class="c1">//执行完这一行后就会输出"I'm dying..."
</span></code></pre>
</div>

<p>2.<font color="#FF6100">__attribute__((noreturn))</font>，它用于指定函数是不允许有返回值的。</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">noReturn</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="n">noreturn</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"hello"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>
<p>这个笔者没用到过。</p>

<p>3.<font color="#FF6100">__attribute__((deprecated))</font>,这个可能是大家见的最多了，苹果也经常干这个事，每隔一两个版本可能就会有那么几个API被废弃，然后提示我们用哪个API代替，在编译的时候就会发出警告。</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">deprecatedMethodWithMessage</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="n">deprecated</span><span class="p">(</span><span class="s">"this method was deprecated in MyApp.app version 5.0.2, use newMethod instead"</span><span class="p">)))</span>
<span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"his method was deprecated in MyApp.app version 5.0.2, use newMethod instead"</span><span class="p">);</span>
<span class="p">}</span><span class="c1">//调用这个方法的时候会发出警告信息，deprecated后面的参数可要可不要。
</span></code></pre>
</div>

<p>4.<font color="#FF6100">__attribute__((warn_unused_result))</font></p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">printMsg</span><span class="p">:(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">str</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">warn_unused_result</span><span class="p">))</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">str</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//这样调用这个函数会报警告信息,提示用户返回值没有被使用，在一些返回值很重要的函数里，这个很有用
</span><span class="p">[</span><span class="n">self</span> <span class="nf">printMsg</span><span class="p">:</span><span class="s">@"msg"</span><span class="p">];</span>
</code></pre>
</div>

<p>5.<font color="#FF6100">__attribute__((unavailable))</font>，这个和deprecated有很大的不一样，如果对函数加上这个，那么这个函数是禁止使用的。</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="n">init</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">unavailable</span><span class="p">(</span><span class="s">"这个函数不能用！"</span><span class="p">)));</span>
</code></pre>
</div>
<p>如果强行使用这个函数，编译是通不过的。这一种做法可禁止使用默认的初始化方法生成类的实例对象，只能使用用户提供的初始化方法。</p>

<p>6.<font color="#FF6100">__attribute__((overloadable))</font>，这个可以用来实现函数的重载。这里先来说一下两个概念：重载和覆盖。</p>
<ol>
  <li>
    <p>重载：它作用域是在一个类里面，函数名相同，参数不同（参数类型不同，或者参数个数不同），virtual关键字可有可无。</p>
  </li>
  <li>
    <p>覆盖：作用域不同，一个是在基类中一个是在派生类中，参数相同（参数个数和类型均相同），基类函数必须有virtual关键字（派生类可有可无，因为基类函数被声明为虚函数，派生类同名函数一定也是虚函数）</p>
  </li>
</ol>

<p>知道这个两个概念的区别，那么来讲讲objective-c，在这门语言中，是没有重载这个机制的，但是可以覆盖。使用overloadable后可以实现重载，但是不能像c++那样重载实例方法，只能重载c/c++的函数：</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="c1">//调用以下函数时和c/c++调用的语法一样
</span><span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">)</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">overloadable</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"Add Int %i"</span><span class="p">,</span><span class="n">num</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span> <span class="n">num</span><span class="p">)</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">overloadable</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"Add NSString %@"</span><span class="p">,</span><span class="n">num</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="n">NSNumber</span> <span class="o">*</span> <span class="n">num</span><span class="p">)</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">overloadable</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"Add NSNumber %@"</span><span class="p">,</span><span class="n">num</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<p>7.<font color="#FF6100">__attribute__((objc_subclassing_restricted))</font>，在类的声明文件中加入这一行，表示这个类，不能被继承，就是java类中的final类。如果试图去继承这个类，编译会报错：</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="c1">//customClass.h
</span><span class="n">__attribute__</span><span class="p">((</span><span class="n">objc_subclassing_restricted</span><span class="p">))</span>
<span class="k">@interface</span> <span class="nc">customClass</span> <span class="p">:</span> <span class="nc">NSObject</span>
</code></pre>
</div>

<p>8.<font color="#FF6100">__attribute__((objc_designated_initializer))</font>,这个用于类的初始化方法。对于对象而言，在生成一个实例的时候，如果需要提供必要的信息来完成初始化，才能使该对象正确的完成后面的工作，这种初始化方法叫”全能初始化方法”(designated initializer)。如果创建一个类的方法有多种，相应的，这个类便会有多个初始化方法。如果这些初始化分别初始化类中不同的属性时，那么在实际使用的过程中，当一使用同一个对象，做同一件事的时候，创建对象使用的是不同的初始化方法，那么问题会视后面具体的事出现不同的问题，有些可能不会造成很大的影响，有些可能会造成重大灾难。在《Effectvie objective-c 2.0》，条款16当中有详细的说明。具体的做法是指定一个全能初始化方法，让其他初始化方法去调用这个全能初始化方法。使用objc_designated_initializer还要注意，当存在继承的时候，子类在初始化时要调用父类的全能初始化方法，完成初始化，否则编译器会给出警告信息。</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="c1">//Rectangle.h
</span><span class="k">@interface</span> <span class="nc">Rectangle</span> <span class="p">:</span> <span class="nc">NSObject</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">assign</span><span class="p">,</span> <span class="n">readonly</span><span class="p">)</span> <span class="kt">float</span> <span class="n">width</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">assign</span><span class="p">,</span> <span class="n">readonly</span><span class="p">)</span> <span class="kt">float</span> <span class="n">heigth</span><span class="p">;</span>
<span class="k">-</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="nf">initWithWidth</span><span class="p">:(</span><span class="kt">float</span><span class="p">)</span> <span class="n">width</span> <span class="n">heigth</span><span class="o">:</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span> <span class="n">heigth</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">objc_designated_initializer</span><span class="p">));</span>
<span class="k">-</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="n">init</span> <span class="p">;</span>
<span class="k">@end</span>
<span class="c1">//Rectangle.m
</span><span class="k">@implementation</span> <span class="nc">Rectangle</span>
<span class="k">-</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="nf">initWithWidth</span><span class="p">:(</span><span class="kt">float</span><span class="p">)</span> <span class="n">width</span> <span class="n">heigth</span><span class="o">:</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span> <span class="n">heigth</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">self</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="nf">init</span><span class="p">])</span> <span class="p">{</span>
        <span class="n">_width</span> <span class="o">=</span> <span class="n">width</span><span class="p">;</span>
        <span class="n">_heigth</span> <span class="o">=</span> <span class="n">heigth</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
<span class="p">}</span>
<span class="o">-</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="n">init</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">self</span> <span class="nf">initWithWidth</span><span class="p">:</span><span class="mi">5</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span> <span class="nf">heigth</span><span class="p">:</span><span class="mi">5</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">];</span>
<span class="p">}</span>
<span class="k">@end</span>
</code></pre>
</div>

<p>9.<font color="#FF6100">__attribute__((objc_requires_super))</font>，这个指令表示在子类重写方法时，必须在调用父类中的方法，不然后会给出警告。</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="c1">//Base.h
</span><span class="k">@interface</span> <span class="nc">Base</span> <span class="p">:</span> <span class="nc">NSObject</span>
<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">method1</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">objc_requires_super</span><span class="p">));</span>
<span class="k">@end</span>
<span class="c1">//Base.m
</span><span class="k">@implementation</span> <span class="nc">Base</span>
<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">method1</span>
<span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"Base"</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">@end</span>
<span class="c1">//Derived.h
</span><span class="k">@interface</span> <span class="nc">Derived</span> <span class="p">:</span> <span class="nc">NSObject</span>

<span class="k">@end</span>
<span class="c1">//Derived.m
</span><span class="k">@implementation</span> <span class="nc">Derived</span>
<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">method1</span>
<span class="p">{</span>
    <span class="p">[</span><span class="n">super</span> <span class="nf">method1</span><span class="p">];</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"Derived"</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">@end</span>
</code></pre>
</div>

<p>10.<font color="#FF6100">__attribute__((nonnull))</font>，这个表示函数参数不为空，由编译器检查。</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">testNonnull</span><span class="p">:(</span><span class="n">id</span><span class="p">)</span><span class="nv">avg1</span> <span class="nf">avg2</span><span class="p">:(</span><span class="n">id</span><span class="p">)</span><span class="nv">avg2</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">nonnull</span><span class="p">))</span>
<span class="p">{</span>
    <span class="c1">//do something
</span><span class="p">}</span>
<span class="c1">//某个作用域内
</span><span class="p">{</span>
    <span class="p">[</span><span class="n">self</span> <span class="nf">testNonnull</span><span class="p">:</span><span class="nb">nil</span> <span class="nf">avg2</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span><span class="c1">//这样使用时编译器会给出警告
</span><span class="p">}</span>
</code></pre>
</div>

<p><a href="http://www.jianshu.com/p/29eb7b5c8b2d"><strong>attribute</strong> 总结</a></p>

<p><a href="http://blog.sunnyxx.com/2016/05/14/clang-attributes/">Clang Attributes 黑魔法小记</a></p>

<p><a href="http://nshipster.com/__attribute__/"><strong>attribute</strong></a></p>

<p><a href="http://www.aopod.com/2016/08/03/attribute-directives/">__attribute__指令</a></p>

<p><a href="http://www.jianshu.com/p/0237c34158f0">Clang 3.8 documentation</a></p>

<p>–EOF–</p>


                    ]]>
                </content:encoded>
                <guid isPermaLink="false">/objective-c/attribute/2017/05/06/oc%E4%B8%AD%E7%9A%84%E9%BB%91%E9%AD%94%E6%B3%95attribute/</guid>
                <description>
                    
                    attribute是编译器为我们提供的一个指令，在编程过程中善用它能为我们带来意想不到的好处。
                    
                </description>
                <pubDate>Sat, 06 May 2017 00:00:00 +0800</pubDate>
                <author>冬阳</author>
            </item>
        
    
        
            <item>
                <title>AFNetworking3.0源码解读之下载请求</title>
                <link>http://localhost:4000/objective-c/afnetworking/2017/05/05/AFNetworking3.0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%95%B0%E6%8D%AE%E4%B8%8B%E8%BD%BD/</link>
                <content:encoded>
                    <![CDATA[
                    <p>标签： objective-c AFNetworking download</p>

<hr />

<h3 id="前言">前言</h3>

<p>上一篇简单介绍了一下AFURLSessionManager类的结构以及发起一个网络请求的函数调用过程。AFURLSessionManager类中有很多属性，还定义了很多的局部全局变量，在数据请求那大部分用不上。比如，AFURLSessionManager类定义了很多的block:</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">AFURLSessionDidBecomeInvalidBlock</span><span class="p">)(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">);</span>
<span class="k">typedef</span> <span class="n">NSURLSessionAuthChallengeDisposition</span> <span class="p">(</span><span class="o">^</span><span class="n">AFURLSessionDidReceiveAuthenticationChallengeBlock</span><span class="p">)(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="n">NSURLAuthenticationChallenge</span> <span class="o">*</span><span class="n">challenge</span><span class="p">,</span> <span class="n">NSURLCredential</span> <span class="o">*</span> <span class="n">__autoreleasing</span> <span class="o">*</span><span class="n">credential</span><span class="p">);</span>

<span class="k">typedef</span> <span class="n">NSURLRequest</span> <span class="o">*</span> <span class="p">(</span><span class="o">^</span><span class="n">AFURLSessionTaskWillPerformHTTPRedirectionBlock</span><span class="p">)(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="n">NSURLSessionTask</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="n">NSURLResponse</span> <span class="o">*</span><span class="n">response</span><span class="p">,</span> <span class="n">NSURLRequest</span> <span class="o">*</span><span class="n">request</span><span class="p">);</span>
<span class="k">typedef</span> <span class="n">NSURLSessionAuthChallengeDisposition</span> <span class="p">(</span><span class="o">^</span><span class="n">AFURLSessionTaskDidReceiveAuthenticationChallengeBlock</span><span class="p">)(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="n">NSURLSessionTask</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="n">NSURLAuthenticationChallenge</span> <span class="o">*</span><span class="n">challenge</span><span class="p">,</span> <span class="n">NSURLCredential</span> <span class="o">*</span> <span class="n">__autoreleasing</span> <span class="o">*</span><span class="n">credential</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">AFURLSessionDidFinishEventsForBackgroundURLSessionBlock</span><span class="p">)(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="n">session</span><span class="p">);</span>

<span class="k">typedef</span> <span class="n">NSInputStream</span> <span class="o">*</span> <span class="p">(</span><span class="o">^</span><span class="n">AFURLSessionTaskNeedNewBodyStreamBlock</span><span class="p">)(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="n">NSURLSessionTask</span> <span class="o">*</span><span class="n">task</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">AFURLSessionTaskDidSendBodyDataBlock</span><span class="p">)(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="n">NSURLSessionTask</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">bytesSent</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">totalBytesSent</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">totalBytesExpectedToSend</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">AFURLSessionTaskDidCompleteBlock</span><span class="p">)(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="n">NSURLSessionTask</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">);</span>

<span class="k">typedef</span> <span class="n">NSURLSessionResponseDisposition</span> <span class="p">(</span><span class="o">^</span><span class="n">AFURLSessionDataTaskDidReceiveResponseBlock</span><span class="p">)(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="n">NSURLSessionDataTask</span> <span class="o">*</span><span class="n">dataTask</span><span class="p">,</span> <span class="n">NSURLResponse</span> <span class="o">*</span><span class="n">response</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">AFURLSessionDataTaskDidBecomeDownloadTaskBlock</span><span class="p">)(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="n">NSURLSessionDataTask</span> <span class="o">*</span><span class="n">dataTask</span><span class="p">,</span> <span class="n">NSURLSessionDownloadTask</span> <span class="o">*</span><span class="n">downloadTask</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">AFURLSessionDataTaskDidReceiveDataBlock</span><span class="p">)(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="n">NSURLSessionDataTask</span> <span class="o">*</span><span class="n">dataTask</span><span class="p">,</span> <span class="n">NSData</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">typedef</span> <span class="n">NSCachedURLResponse</span> <span class="o">*</span> <span class="p">(</span><span class="o">^</span><span class="n">AFURLSessionDataTaskWillCacheResponseBlock</span><span class="p">)(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="n">NSURLSessionDataTask</span> <span class="o">*</span><span class="n">dataTask</span><span class="p">,</span> <span class="n">NSCachedURLResponse</span> <span class="o">*</span><span class="n">proposedResponse</span><span class="p">);</span>

<span class="k">typedef</span> <span class="n">NSURL</span> <span class="o">*</span> <span class="p">(</span><span class="o">^</span><span class="n">AFURLSessionDownloadTaskDidFinishDownloadingBlock</span><span class="p">)(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="n">NSURLSessionDownloadTask</span> <span class="o">*</span><span class="n">downloadTask</span><span class="p">,</span> <span class="n">NSURL</span> <span class="o">*</span><span class="n">location</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">AFURLSessionDownloadTaskDidWriteDataBlock</span><span class="p">)(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="n">NSURLSessionDownloadTask</span> <span class="o">*</span><span class="n">downloadTask</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">bytesWritten</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">totalBytesWritten</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">totalBytesExpectedToWrite</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">AFURLSessionDownloadTaskDidResumeBlock</span><span class="p">)(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="n">NSURLSessionDownloadTask</span> <span class="o">*</span><span class="n">downloadTask</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">fileOffset</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">expectedTotalBytes</span><span class="p">);</span>

<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">AFURLSessionTaskCompletionHandler</span><span class="p">)(</span><span class="n">NSURLResponse</span> <span class="o">*</span><span class="n">response</span><span class="p">,</span> <span class="n">id</span> <span class="n">responseObject</span><span class="p">,</span> <span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">);</span>
</code></pre>
</div>
<p>这里列出了该类所有的block，有没有很吓人，刚开始看的时候，我也看的头疼，后来调试的时候发现在本文接下来要讲的内容中，只用到了两个分别是AFURLSessionTaskCompletionHandler和AFURLSessionDownloadTaskDidFinishDownloadingBlock，这两个block都是delegate在完成代理后调用的。说明AFURLSessionManager中的block属性打酱油了，那我就很好奇了，既然是打酱油的那还要它干吗？其实不是，我们先来仔细观察一下它们的名字——objective-c的命名都是见名知意的，这一点笔者感觉很不错——以本文的下载为例，AFURLSessionDownloadTaskDidFinishDownloadingBlock意：下载任务完成时的block。那我们怎么去使用这个呢？呆会就讲。</p>

<h2 id="正文">正文</h2>

<p>和上一篇一样还是以官方git上的例子看起，源码如下：</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="n">NSURLSessionConfiguration</span> <span class="o">*</span><span class="n">configuration</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSURLSessionConfiguration</span> <span class="nf">defaultSessionConfiguration</span><span class="p">];</span>
<span class="n">AFURLSessionManager</span> <span class="o">*</span><span class="n">manager</span> <span class="o">=</span> <span class="p">[[</span><span class="n">AFURLSessionManager</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">initWithSessionConfiguration</span><span class="p">:</span><span class="n">configuration</span><span class="p">];</span>

<span class="n">NSURL</span> <span class="o">*</span><span class="n">URL</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSURL</span> <span class="nf">URLWithString</span><span class="p">:</span><span class="s">@"http://img04.tooopen.com/images/20130701/tooopen_10055061.jpg"</span><span class="p">];</span>
<span class="n">NSURLRequest</span> <span class="o">*</span><span class="n">request</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSURLRequest</span> <span class="nf">requestWithURL</span><span class="p">:</span><span class="n">URL</span><span class="p">];</span>

<span class="n">NSURLSessionDownloadTask</span> <span class="o">*</span><span class="n">downloadTask</span> <span class="o">=</span> <span class="p">[</span><span class="n">manager</span> <span class="nf">downloadTaskWithRequest</span><span class="p">:</span><span class="n">request</span> <span class="nf">progress</span><span class="p">:</span><span class="nb">nil</span> <span class="n">destination</span><span class="o">:^</span><span class="n">NSURL</span> <span class="o">*</span><span class="p">(</span><span class="n">NSURL</span> <span class="o">*</span><span class="n">targetPath</span><span class="p">,</span> <span class="n">NSURLResponse</span> <span class="o">*</span><span class="n">response</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">NSURL</span> <span class="o">*</span><span class="n">documentsDirectoryURL</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSFileManager</span> <span class="nf">defaultManager</span><span class="p">]</span> <span class="nf">URLForDirectory</span><span class="p">:</span><span class="n">NSDocumentDirectory</span> <span class="nf">inDomain</span><span class="p">:</span><span class="n">NSUserDomainMask</span> <span class="n">appropriateForURL</span><span class="o">:</span><span class="nb">nil</span> <span class="n">create</span><span class="o">:</span><span class="nb">NO</span> <span class="n">error</span><span class="o">:</span><span class="nb">nil</span><span class="p">];</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">documentsDirectoryURL</span> <span class="nf">URLByAppendingPathComponent</span><span class="p">:[</span><span class="n">response</span> <span class="nf">suggestedFilename</span><span class="p">]];</span>
<span class="p">}</span> <span class="n">completionHandler</span><span class="o">:^</span><span class="p">(</span><span class="n">NSURLResponse</span> <span class="o">*</span><span class="n">response</span><span class="p">,</span> <span class="n">NSURL</span> <span class="o">*</span><span class="n">filePath</span><span class="p">,</span> <span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"File downloaded to: %@"</span><span class="p">,</span> <span class="n">filePath</span><span class="p">);</span>
    <span class="n">self</span><span class="p">.</span><span class="n">imgView</span><span class="p">.</span><span class="n">image</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIImage</span> <span class="nf">imageWithData</span><span class="p">:[</span><span class="n">NSData</span> <span class="nf">dataWithContentsOfURL</span><span class="p">:</span><span class="n">filePath</span><span class="p">]];</span>

<span class="p">}];</span>
<span class="c1">//以下三行是我添加的，下面三行设置了下载完成后的回调
</span><span class="k">typedef</span> <span class="n">NSURL</span> <span class="o">*</span> <span class="p">(</span><span class="o">^</span><span class="n">DownloadTaskDidFinishDownloadingBlock</span><span class="p">)(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="n">NSURLSessionDownloadTask</span> <span class="o">*</span><span class="n">downloadTask</span><span class="p">,</span> <span class="n">NSURL</span> <span class="o">*</span><span class="n">location</span><span class="p">);</span>

<span class="n">id</span> <span class="n">block</span> <span class="o">=</span> <span class="o">^</span><span class="p">(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="n">NSURLSessionDownloadTask</span> <span class="o">*</span><span class="n">downloadTask</span><span class="p">,</span> <span class="n">NSURL</span> <span class="o">*</span><span class="n">location</span><span class="p">){</span>
    <span class="c1">//doing something
</span>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"%@"</span><span class="p">,</span><span class="n">location</span><span class="p">);</span>
<span class="cm">/*
 * 将上面的打印语句注释掉，改成下面的，再运行一次看看会有什么结果？
    NSURL *documentsDirectoryURL = [[NSFileManager defaultManager] URLForDirectory:NSDocumentDirectory inDomain:NSUserDomainMask appropriateForURL:nil create:NO error:nil]; 
        
    return [documentsDirectoryURL URLByAppendingPathComponent:[downloadTask.response suggestedFilename]];
    */</span>
<span class="p">};</span>
<span class="p">[</span><span class="n">manager</span> <span class="nf">setDownloadTaskDidFinishDownloadingBlock</span><span class="p">:</span><span class="n">block</span><span class="p">];</span>


<span class="p">[</span><span class="n">downloadTask</span> <span class="nf">resume</span><span class="p">];</span>

</code></pre>
</div>
<p>这里我在网上随便找了一张图片，然后还设置了manager的一个AFURLSessionDownloadTaskDidFinishDownloadingBlock，就是刚才说那些打酱油中的block中的一个。笔者在这里只是简单的打印了一下location，并没有返回一个路径，注意哦，这个block要返回一个路径的哦，这个路径是用来存放我们下载的图片的。</p>

<p>这里通过manager实例方法来创建downloadTask:</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="n">NSURLSessionDownloadTask</span> <span class="o">*</span><span class="p">)</span><span class="nf">downloadTaskWithRequest</span><span class="p">:(</span><span class="n">NSURLRequest</span> <span class="o">*</span><span class="p">)</span><span class="nv">request</span>
                                             <span class="nf">progress</span><span class="p">:(</span><span class="n">NSProgress</span> <span class="o">*</span> <span class="n">__autoreleasing</span> <span class="o">*</span><span class="p">)</span><span class="nv">progress</span>
                                          <span class="nf">destination</span><span class="p">:(</span><span class="n">NSURL</span> <span class="o">*</span> <span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="n">NSURL</span> <span class="o">*</span><span class="n">targetPath</span><span class="p">,</span> <span class="n">NSURLResponse</span> <span class="o">*</span><span class="n">response</span><span class="p">))</span><span class="nv">destination</span>
                                    <span class="nf">completionHandler</span><span class="p">:(</span><span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="n">NSURLResponse</span> <span class="o">*</span><span class="n">response</span><span class="p">,</span> <span class="n">NSURL</span> <span class="o">*</span><span class="n">filePath</span><span class="p">,</span> <span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">))</span><span class="nv">completionHandler</span>
<span class="p">{</span>
    <span class="n">__block</span> <span class="n">NSURLSessionDownloadTask</span> <span class="o">*</span><span class="n">downloadTask</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
    <span class="n">dispatch_sync</span><span class="p">(</span><span class="n">url_session_manager_creation_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
        <span class="n">downloadTask</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">session</span> <span class="nf">downloadTaskWithRequest</span><span class="p">:</span><span class="n">request</span><span class="p">];</span>
    <span class="p">});</span>
    <span class="c1">//这个是用来设置下载代理的
</span>    <span class="p">[</span><span class="n">self</span> <span class="nf">addDelegateForDownloadTask</span><span class="p">:</span><span class="n">downloadTask</span> <span class="nf">progress</span><span class="p">:</span><span class="n">progress</span> <span class="n">destination</span><span class="o">:</span><span class="n">destination</span> <span class="n">completionHandler</span><span class="o">:</span><span class="n">completionHandler</span><span class="p">];</span>

    <span class="k">return</span> <span class="n">downloadTask</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>
<p>然后又进入到[NSURLSessionManager addDelegateForDownloadTask:progress:destination:completionHandler]这个函数设置了具体的代理对象，以及下载完成后设置了图片存储路径的block，上一篇的数据请求也会进行这一步，但下载比数据请求多了一些东西，让我们来看看多了什么：</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">addDelegateForDownloadTask</span><span class="p">:(</span><span class="n">NSURLSessionDownloadTask</span> <span class="o">*</span><span class="p">)</span><span class="nv">downloadTask</span>
                          <span class="nf">progress</span><span class="p">:(</span><span class="n">NSProgress</span> <span class="o">*</span> <span class="n">__autoreleasing</span> <span class="o">*</span><span class="p">)</span><span class="nv">progress</span>
                       <span class="nf">destination</span><span class="p">:(</span><span class="n">NSURL</span> <span class="o">*</span> <span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="n">NSURL</span> <span class="o">*</span><span class="n">targetPath</span><span class="p">,</span> <span class="n">NSURLResponse</span> <span class="o">*</span><span class="n">response</span><span class="p">))</span><span class="nv">destination</span>
                 <span class="nf">completionHandler</span><span class="p">:(</span><span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="n">NSURLResponse</span> <span class="o">*</span><span class="n">response</span><span class="p">,</span> <span class="n">NSURL</span> <span class="o">*</span><span class="n">filePath</span><span class="p">,</span> <span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">))</span><span class="nv">completionHandler</span>
<span class="p">{</span>
    <span class="n">AFURLSessionManagerTaskDelegate</span> <span class="o">*</span><span class="n">delegate</span> <span class="o">=</span> <span class="p">[[</span><span class="n">AFURLSessionManagerTaskDelegate</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">init</span><span class="p">];</span>
    <span class="n">delegate</span><span class="p">.</span><span class="n">manager</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>
    <span class="n">delegate</span><span class="p">.</span><span class="n">completionHandler</span> <span class="o">=</span> <span class="n">completionHandler</span><span class="p">;</span>
<span class="c1">//downloadTaskDidFinishDownloading -&gt; NSURL * (^AFURLSessionDownloadTaskDidFinishDownloadingBlock)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, NSURL *location);
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">destination</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">delegate</span><span class="p">.</span><span class="n">downloadTaskDidFinishDownloading</span> <span class="o">=</span> <span class="o">^</span><span class="n">NSURL</span> <span class="o">*</span> <span class="p">(</span><span class="n">NSURLSession</span> <span class="o">*</span> <span class="n">__unused</span> <span class="n">session</span><span class="p">,</span> <span class="n">NSURLSessionDownloadTask</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="n">NSURL</span> <span class="o">*</span><span class="n">location</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">destination</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">task</span><span class="p">.</span><span class="n">response</span><span class="p">);</span>
        <span class="p">};</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">progress</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">progress</span> <span class="o">=</span> <span class="n">delegate</span><span class="p">.</span><span class="n">progress</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">downloadTask</span><span class="p">.</span><span class="n">taskDescription</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">taskDescriptionForSessionTasks</span><span class="p">;</span>

    <span class="p">[</span><span class="n">self</span> <span class="nf">setDelegate</span><span class="p">:</span><span class="n">delegate</span> <span class="nf">forTask</span><span class="p">:</span><span class="n">downloadTask</span><span class="p">];</span>
<span class="p">}</span>
</code></pre>
</div>
<p>和数据请求相比，这里主要多了两个地方一个是设置了下载完成后的回调，一个是设置了下载的进度。这里设置的是delegate相应的回调。函数的最后一句就是保存delegate，这个和数据请求部分一样，不解释了。最后还会调用这个函数：</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setDownloadTaskDidFinishDownloadingBlock</span><span class="p">:(</span><span class="n">NSURL</span> <span class="o">*</span> <span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="n">NSURLSessionDownloadTask</span> <span class="o">*</span><span class="n">downloadTask</span><span class="p">,</span> <span class="n">NSURL</span> <span class="o">*</span><span class="n">location</span><span class="p">))</span><span class="nv">block</span> <span class="p">{</span>
    <span class="n">self</span><span class="p">.</span><span class="n">downloadTaskDidFinishDownloading</span> <span class="o">=</span> <span class="n">block</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>
<p>因为我们之前设置了manager下载完成后的回调就是这句：</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="n">manager</span> <span class="nf">setDownloadTaskDidFinishDownloadingBlock</span><span class="p">:</span><span class="n">block</span><span class="p">];</span>
</code></pre>
</div>

<p>现在可以启动downloadTask了。</p>

<p>网络正常的情况以及URL没错的情况下，收到下载的数据后就会调用manager实现的代理方法：</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="c1">//AFURLSessionManager-&gt;NSURLSessionDownloadDelegate-&gt;下载时调用，可能调用多次
</span><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">URLSession</span><span class="p">:(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="p">)</span><span class="nv">session</span>
      <span class="nf">downloadTask</span><span class="p">:(</span><span class="n">NSURLSessionDownloadTask</span> <span class="o">*</span><span class="p">)</span><span class="nv">downloadTask</span>
      <span class="nf">didWriteData</span><span class="p">:(</span><span class="kt">int64_t</span><span class="p">)</span><span class="nv">bytesWritten</span>
 <span class="nf">totalBytesWritten</span><span class="p">:(</span><span class="kt">int64_t</span><span class="p">)</span><span class="nv">totalBytesWritten</span>
<span class="nf">totalBytesExpectedToWrite</span><span class="p">:(</span><span class="kt">int64_t</span><span class="p">)</span><span class="nv">totalBytesExpectedToWrite</span>
<span class="p">{</span>
    <span class="n">AFURLSessionManagerTaskDelegate</span> <span class="o">*</span><span class="n">delegate</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nf">delegateForTask</span><span class="p">:</span><span class="n">downloadTask</span><span class="p">];</span>
    <span class="p">[</span><span class="n">delegate</span> <span class="nf">URLSession</span><span class="p">:</span><span class="n">session</span> <span class="nf">downloadTask</span><span class="p">:</span><span class="n">downloadTask</span> <span class="n">didWriteData</span><span class="o">:</span><span class="n">bytesWritten</span> <span class="n">totalBytesWritten</span><span class="o">:</span><span class="n">totalBytesWritten</span> <span class="n">totalBytesExpectedToWrite</span><span class="o">:</span><span class="n">totalBytesExpectedToWrite</span><span class="p">];</span>
<span class="c1">//downloadTaskDidWriteData - &gt; void (^AFURLSessionDownloadTaskDidWriteDataBlock)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, int64_t bytesWritten, int64_t totalBytesWritten, int64_t totalBytesExpectedToWrite);
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">downloadTaskDidWriteData</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">self</span><span class="p">.</span><span class="n">downloadTaskDidWriteData</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">downloadTask</span><span class="p">,</span> <span class="n">bytesWritten</span><span class="p">,</span> <span class="n">totalBytesWritten</span><span class="p">,</span> <span class="n">totalBytesExpectedToWrite</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>
<p>这个函数没什么可以讲主要就是用来计算下载的进度。当下载完成的时候就会进入到这个代理方法中：</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="c1">//AFURLSessionManager-&gt;NSURLSessionDownloadDelegate-&gt;下载完成是调用
</span><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">URLSession</span><span class="p">:(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="p">)</span><span class="nv">session</span>
      <span class="nf">downloadTask</span><span class="p">:(</span><span class="n">NSURLSessionDownloadTask</span> <span class="o">*</span><span class="p">)</span><span class="nv">downloadTask</span>
<span class="nf">didFinishDownloadingToURL</span><span class="p">:(</span><span class="n">NSURL</span> <span class="o">*</span><span class="p">)</span><span class="nv">location</span>
<span class="p">{</span>
    <span class="n">AFURLSessionManagerTaskDelegate</span> <span class="o">*</span><span class="n">delegate</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nf">delegateForTask</span><span class="p">:</span><span class="n">downloadTask</span><span class="p">];</span>
<span class="c1">//downloadTaskDidFinishDownloading -&gt; NSURL * (^AFURLSessionDownloadTaskDidFinishDownloadingBlock)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, NSURL *location);
</span>    <span class="c1">//下载的时候这个block没有用
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">downloadTaskDidFinishDownloading</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">NSURL</span> <span class="o">*</span><span class="n">fileURL</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">downloadTaskDidFinishDownloading</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">downloadTask</span><span class="p">,</span> <span class="n">location</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fileURL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">delegate</span><span class="p">.</span><span class="n">downloadFileURL</span> <span class="o">=</span> <span class="n">fileURL</span><span class="p">;</span>
            <span class="n">NSError</span> <span class="o">*</span><span class="n">error</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
            <span class="p">[[</span><span class="n">NSFileManager</span> <span class="nf">defaultManager</span><span class="p">]</span> <span class="nf">moveItemAtURL</span><span class="p">:</span><span class="n">location</span> <span class="nf">toURL</span><span class="p">:</span><span class="n">fileURL</span> <span class="n">error</span><span class="o">:&amp;</span><span class="n">error</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
                <span class="p">[[</span><span class="n">NSNotificationCenter</span> <span class="nf">defaultCenter</span><span class="p">]</span> <span class="nf">postNotificationName</span><span class="p">:</span><span class="n">AFURLSessionDownloadTaskDidFailToMoveFileNotification</span> <span class="nf">object</span><span class="p">:</span><span class="n">downloadTask</span> <span class="n">userInfo</span><span class="o">:</span><span class="n">error</span><span class="p">.</span><span class="n">userInfo</span><span class="p">];</span>
            <span class="p">}</span>

            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">delegate</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">[</span><span class="n">delegate</span> <span class="nf">URLSession</span><span class="p">:</span><span class="n">session</span> <span class="nf">downloadTask</span><span class="p">:</span><span class="n">downloadTask</span> <span class="n">didFinishDownloadingToURL</span><span class="o">:</span><span class="n">location</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>
<p>这里有一个重点，单步执行的时候会发现，程序会进入到第一个if里面。还记得在开头的例子中我加了三行代码：</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="k">typedef</span> <span class="n">NSURL</span> <span class="o">*</span> <span class="p">(</span><span class="o">^</span><span class="n">DownloadTaskDidFinishDownloadingBlock</span><span class="p">)(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="n">NSURLSessionDownloadTask</span> <span class="o">*</span><span class="n">downloadTask</span><span class="p">,</span> <span class="n">NSURL</span> <span class="o">*</span><span class="n">location</span><span class="p">);</span>

<span class="n">id</span> <span class="n">block</span> <span class="o">=</span> <span class="o">^</span><span class="p">(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="n">NSURLSessionDownloadTask</span> <span class="o">*</span><span class="n">downloadTask</span><span class="p">,</span> <span class="n">NSURL</span> <span class="o">*</span><span class="n">location</span><span class="p">){</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"%@"</span><span class="p">,</span><span class="n">location</span><span class="p">);</span>
<span class="p">};</span>
<span class="p">[</span><span class="n">manager</span> <span class="nf">setDownloadTaskDidFinishDownloadingBlock</span><span class="p">:</span><span class="n">block</span><span class="p">];</span>
</code></pre>
</div>
<p>这三行设置了manager的downloadTaskDidFinishDownloading属性，它是下载完成后的一个回调，它要求返回一个URL用来存放下载的图片，如果在这个block里返回了一个URL那么它会进入到第一个if里去，并且执行完就返回了。图片也就保存到了返回的这个URL了，后面的代码就不会执行了，如果没有返回一个URL的话，程序就是把下载的图片保存到这里：</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="c1">//这是例子开头我们设置的用来保存图片的URL,如果我们设置了managerr的downloadTaskDidFinishDownloading属性并且同时在这个block里返回了一个URL那么下面这两行代码就不会执行了，因为已经有保存图片的URL了。只有block里没有返回URL下面的代码才会执行
</span><span class="n">NSURL</span> <span class="o">*</span><span class="n">documentsDirectoryURL</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSFileManager</span> <span class="nf">defaultManager</span><span class="p">]</span> <span class="nf">URLForDirectory</span><span class="p">:</span><span class="n">NSDocumentDirectory</span> <span class="nf">inDomain</span><span class="p">:</span><span class="n">NSUserDomainMask</span> <span class="n">appropriateForURL</span><span class="o">:</span><span class="nb">nil</span> <span class="n">create</span><span class="o">:</span><span class="nb">NO</span> <span class="n">error</span><span class="o">:</span><span class="nb">nil</span><span class="p">];</span>

<span class="k">return</span> <span class="p">[</span><span class="n">documentsDirectoryURL</span> <span class="nf">URLByAppendingPathComponent</span><span class="p">:[</span><span class="n">response</span> <span class="nf">suggestedFilename</span><span class="p">]];</span>
</code></pre>
</div>
<p>上面的这两行代码是在这个代理方法里调用的：</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="c1">//AFURLSessionManagerTaskDelegate-&gt;NSURLSessionTaskDelegate-&gt;下载完成时调用
</span><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">URLSession</span><span class="p">:(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="p">)</span><span class="nv">session</span>
      <span class="nf">downloadTask</span><span class="p">:(</span><span class="n">NSURLSessionDownloadTask</span> <span class="o">*</span><span class="p">)</span><span class="nv">downloadTask</span>
<span class="nf">didFinishDownloadingToURL</span><span class="p">:(</span><span class="n">NSURL</span> <span class="o">*</span><span class="p">)</span><span class="nv">location</span>
<span class="p">{</span>
    <span class="n">NSError</span> <span class="o">*</span><span class="n">fileManagerError</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
    <span class="n">self</span><span class="p">.</span><span class="n">downloadFileURL</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
<span class="c1">//downloadTaskDidFinishDownloading -&gt; NSURL * (^AFURLSessionDownloadTaskDidFinishDownloadingBlock)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, NSURL *location);
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">downloadTaskDidFinishDownloading</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">//下载完成时调用block
</span>        <span class="n">self</span><span class="p">.</span><span class="n">downloadFileURL</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">downloadTaskDidFinishDownloading</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">downloadTask</span><span class="p">,</span> <span class="n">location</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">downloadFileURL</span><span class="p">)</span> <span class="p">{</span>
            <span class="p">[[</span><span class="n">NSFileManager</span> <span class="nf">defaultManager</span><span class="p">]</span> <span class="nf">moveItemAtURL</span><span class="p">:</span><span class="n">location</span> <span class="nf">toURL</span><span class="p">:</span><span class="n">self</span><span class="p">.</span><span class="n">downloadFileURL</span> <span class="n">error</span><span class="o">:&amp;</span><span class="n">fileManagerError</span><span class="p">];</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">fileManagerError</span><span class="p">)</span> <span class="p">{</span>
                <span class="p">[[</span><span class="n">NSNotificationCenter</span> <span class="nf">defaultCenter</span><span class="p">]</span> <span class="nf">postNotificationName</span><span class="p">:</span><span class="n">AFURLSessionDownloadTaskDidFailToMoveFileNotification</span> <span class="nf">object</span><span class="p">:</span><span class="n">downloadTask</span> <span class="n">userInfo</span><span class="o">:</span><span class="n">fileManagerError</span><span class="p">.</span><span class="n">userInfo</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>
<p>这里需要注意的是这个downloadTaskDidFinishDownloading是delegate里的和manager里的不一样，不要被迷惑了。这个block返回URL，往下执行就是把图片保存在这个URL上了。这个block是不是不知道我们什么时候设置的了。写了这么我，我也差一点忘记了。它是在这个[AFURLSessionMananger addDelegateForDownloadTask:progress:destination:completionHandler:]函数里设置的，注意里面的这一行代码：</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">destination</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">delegate</span><span class="p">.</span><span class="n">downloadTaskDidFinishDownloading</span> <span class="o">=</span> <span class="o">^</span><span class="n">NSURL</span> <span class="o">*</span> <span class="p">(</span><span class="n">NSURLSession</span> <span class="o">*</span> <span class="n">__unused</span> <span class="n">session</span><span class="p">,</span> <span class="n">NSURLSessionDownloadTask</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="n">NSURL</span> <span class="o">*</span><span class="n">location</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">destination</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">task</span><span class="p">.</span><span class="n">response</span><span class="p">);</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre>
</div>
<p>block的用法有没有很神奇它竟然捕获从最外面传进来的destination，并且保存到现在，而且现在要执行它来返回图片要保存的URL。</p>

<p>到这里基本也就快结束了，执行完，就会进入这个[AFURLSessionManagerTaskDelegate URLSession:task:didCompleteWithError:]函数里了，这一步和数据请求没有什么区别。经过这么多调用，图片也就下载完了。前面笔者设置manager的downloadTaskDidFinishDownloading属性，这个笔者认为可以用来返回指定的URL，也可以用来做一些，下载完成后的后续处理工作。</p>

<p>—EOF—</p>


                    ]]>
                </content:encoded>
                <guid isPermaLink="false">/objective-c/afnetworking/2017/05/05/AFNetworking3.0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%95%B0%E6%8D%AE%E4%B8%8B%E8%BD%BD/</guid>
                <description>
                    
                    本文主要分析AFNetworking的下载请求部分。
                    
                </description>
                <pubDate>Fri, 05 May 2017 00:00:00 +0800</pubDate>
                <author>冬阳</author>
            </item>
        
    
        
            <item>
                <title>AFNetworking3.0源码解读之数据请求</title>
                <link>http://localhost:4000/objective-c/afnetworking/2017/05/03/AFNetworking3.0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82/</link>
                <content:encoded>
                    <![CDATA[
                    <p>标签： objective-c AFNetworking</p>

<hr />

<h3 id="前言">前言</h3>

<p>无论做什么开发，都避免不了和网络打交道。在iOS中，网络请求这一块，大家肯定用过AFNetworking库。那么它到底是怎么实现的呢？本文主要讲它的数据请求部分，在以后博客中，会慢慢讲解其他部分。网上其实已经有很多相关的博客了，有些写的更好，写这篇博客的原因也是为了方便记下自己在看一些开源库的代码时学习到的编程技法、编程思想和问题的解决方案。</p>

<h3 id="正文">正文</h3>
<p>先从AFURLSessionManager开始，可以说它是整个库的核心，后面的AFHTTPSessionManager是就继承自AFURLSessionManager类。AFURLSessionManager类主要是对NSURLSession还有相关代理协议的封装。这个类对用户暴露的接口很少，在实现文件里定义了大量的私有方法，此外还对AFURLSessionManager进行了扩展。进行入AFURLSessionManager.m文件内看可以看到这样的结构：
<img src="/images/AFURLSessionManager类的结构图.png" alt="AFURLSessionManager类结构图" /></p>

<p>在实现文件里，AFURLSessionManager.m里定义了两个类，一个类是AFURLSessionManagerTaskDelegate，还有一个就是_AFURLSessionTaskSwizzling。</p>

<p>AFURLSessionManagerTaskDelegate这个类从名字上看就知道，它是用来实现代理的，所有的网络请求回调都是经过它。呆会通过一个实际的例子来的说明。</p>

<p>那么_AFURLSessionTaskSwizzling类是用来干吗的呢？在写这篇博客的时候，笔者还没有能过例子实际的使用过，不过它的源码很少，通过看原码和注释大概知道，它是用来进行方法调配，使用了系统的运行期系统来交换两个方法的实现。注释中提到NSURLSessionTask的实现是通过class cluster来实现的，也就是说我们创建的一个NSURLSessionTask对象，并不是真正的创建这个对象而是创建了一个名字叫__NSCFLocalDataTask。这个类只干了一件了，那就是对任务的<code class="highlighter-rouge">resume</code>和<code class="highlighter-rouge">suspend</code>进行了交换，目的可能就是要实现任务的暂停和恢复的功能。对这个类先说这么点点个人理解吧。</p>

<p>接下来，笔者就以官方给出的例子跟踪一下，它的调用过程以下是源码：</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="n">NSURLSessionConfiguration</span> <span class="o">*</span><span class="n">configuration</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSURLSessionConfiguration</span> <span class="nf">defaultSessionConfiguration</span><span class="p">];</span>
<span class="n">AFURLSessionManager</span> <span class="o">*</span><span class="n">manager</span> <span class="o">=</span> <span class="p">[[</span><span class="n">AFURLSessionManager</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">initWithSessionConfiguration</span><span class="p">:</span><span class="n">configuration</span><span class="p">];</span>

<span class="n">manager</span><span class="p">.</span><span class="n">responseSerializer</span> <span class="o">=</span> <span class="p">[</span><span class="n">AFHTTPResponseSerializer</span> <span class="nf">serializer</span><span class="p">];</span>
<span class="n">NSURL</span> <span class="o">*</span><span class="n">URL</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSURL</span> <span class="nf">URLWithString</span><span class="p">:</span><span class="s">@"http://www.baidu.com"</span><span class="p">];</span>
<span class="n">NSURLRequest</span> <span class="o">*</span><span class="n">request</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSURLRequest</span> <span class="nf">requestWithURL</span><span class="p">:</span><span class="n">URL</span><span class="p">];</span>

<span class="n">NSURLSessionDataTask</span> <span class="o">*</span><span class="n">dataTask</span> <span class="o">=</span> <span class="p">[</span><span class="n">manager</span> <span class="nf">dataTaskWithRequest</span><span class="p">:</span><span class="n">request</span> <span class="nf">completionHandler</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">NSURLResponse</span> <span class="o">*</span><span class="n">response</span><span class="p">,</span> <span class="n">id</span> <span class="n">responseObject</span><span class="p">,</span> <span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@"Error: %@"</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        
        <span class="n">NSString</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSString</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">initWithData</span><span class="p">:</span><span class="n">responseObject</span>  <span class="nf">encoding</span><span class="p">:</span><span class="n">NSUTF8StringEncoding</span><span class="p">];</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@"%@"</span><span class="p">,[</span><span class="n">responseObject</span> <span class="nf">class</span><span class="p">]);</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@"%@"</span><span class="p">,</span><span class="n">result</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}];</span>
<span class="p">[</span><span class="n">dataTask</span> <span class="nf">resume</span><span class="p">];</span>
</code></pre>
</div>
<p>该代码核心只有两句一个是manager的初始化还有一个就是dataTask的创建。先来看看初始化：</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="nf">initWithSessionConfiguration</span><span class="p">:(</span><span class="n">NSURLSessionConfiguration</span> <span class="o">*</span><span class="p">)</span><span class="nv">configuration</span> <span class="p">{</span>
    <span class="n">self</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="nf">init</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">nil</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">configuration</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">configuration</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSURLSessionConfiguration</span> <span class="nf">defaultSessionConfiguration</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="n">self</span><span class="p">.</span><span class="n">sessionConfiguration</span> <span class="o">=</span> <span class="n">configuration</span><span class="p">;</span><span class="c1">//默认配置
</span>
    <span class="n">self</span><span class="p">.</span><span class="n">operationQueue</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSOperationQueue</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">init</span><span class="p">];</span>
    <span class="n">self</span><span class="p">.</span><span class="n">operationQueue</span><span class="p">.</span><span class="n">maxConcurrentOperationCount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="c1">//最大并发数，此处应该当成串行队列来用了
</span>
    <span class="n">self</span><span class="p">.</span><span class="n">session</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSURLSession</span> <span class="nf">sessionWithConfiguration</span><span class="p">:</span><span class="n">self</span><span class="p">.</span><span class="n">sessionConfiguration</span> <span class="nf">delegate</span><span class="p">:</span><span class="n">self</span> <span class="n">delegateQueue</span><span class="o">:</span><span class="n">self</span><span class="p">.</span><span class="n">operationQueue</span><span class="p">];</span><span class="c1">//创建session，设置代理对象
</span>
    <span class="n">self</span><span class="p">.</span><span class="n">responseSerializer</span> <span class="o">=</span> <span class="p">[</span><span class="n">AFJSONResponseSerializer</span> <span class="nf">serializer</span><span class="p">];</span><span class="c1">//默认的解析器
</span>
    <span class="n">self</span><span class="p">.</span><span class="n">securityPolicy</span> <span class="o">=</span> <span class="p">[</span><span class="n">AFSecurityPolicy</span> <span class="nf">defaultPolicy</span><span class="p">];</span>

<span class="cp">#if !TARGET_OS_WATCH
</span>    <span class="n">self</span><span class="p">.</span><span class="n">reachabilityManager</span> <span class="o">=</span> <span class="p">[</span><span class="n">AFNetworkReachabilityManager</span> <span class="nf">sharedManager</span><span class="p">];</span>
<span class="cp">#endif
</span>
    <span class="n">self</span><span class="p">.</span><span class="n">mutableTaskDelegatesKeyedByTaskIdentifier</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSMutableDictionary</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">init</span><span class="p">];</span>

    <span class="n">self</span><span class="p">.</span><span class="n">lock</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSLock</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">init</span><span class="p">];</span>
    <span class="n">self</span><span class="p">.</span><span class="n">lock</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">AFURLSessionManagerLockName</span><span class="p">;</span>

    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">session</span> <span class="nf">getTasksWithCompletionHandler</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">NSArray</span> <span class="o">*</span><span class="n">dataTasks</span><span class="p">,</span> <span class="n">NSArray</span> <span class="o">*</span><span class="n">uploadTasks</span><span class="p">,</span> <span class="n">NSArray</span> <span class="o">*</span><span class="n">downloadTasks</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">NSURLSessionDataTask</span> <span class="o">*</span><span class="n">task</span> <span class="k">in</span> <span class="n">dataTasks</span><span class="p">)</span> <span class="p">{</span>
            <span class="p">[</span><span class="n">self</span> <span class="nf">addDelegateForDataTask</span><span class="p">:</span><span class="n">task</span> <span class="nf">completionHandler</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">NSURLSessionUploadTask</span> <span class="o">*</span><span class="n">uploadTask</span> <span class="k">in</span> <span class="n">uploadTasks</span><span class="p">)</span> <span class="p">{</span>
            <span class="p">[</span><span class="n">self</span> <span class="nf">addDelegateForUploadTask</span><span class="p">:</span><span class="n">uploadTask</span> <span class="nf">progress</span><span class="p">:</span><span class="nb">nil</span> <span class="n">completionHandler</span><span class="o">:</span><span class="nb">nil</span><span class="p">];</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">NSURLSessionDownloadTask</span> <span class="o">*</span><span class="n">downloadTask</span> <span class="k">in</span> <span class="n">downloadTasks</span><span class="p">)</span> <span class="p">{</span>
            <span class="p">[</span><span class="n">self</span> <span class="nf">addDelegateForDownloadTask</span><span class="p">:</span><span class="n">downloadTask</span> <span class="nf">progress</span><span class="p">:</span><span class="nb">nil</span> <span class="n">destination</span><span class="o">:</span><span class="nb">nil</span> <span class="n">completionHandler</span><span class="o">:</span><span class="nb">nil</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}];</span>

    <span class="p">[[</span><span class="n">NSNotificationCenter</span> <span class="nf">defaultCenter</span><span class="p">]</span> <span class="nf">addObserver</span><span class="p">:</span><span class="n">self</span> <span class="nf">selector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">taskDidResume</span><span class="o">:</span><span class="p">)</span> <span class="n">name</span><span class="o">:</span><span class="n">AFNSURLSessionTaskDidResumeNotification</span> <span class="n">object</span><span class="o">:</span><span class="nb">nil</span><span class="p">];</span>
    <span class="p">[[</span><span class="n">NSNotificationCenter</span> <span class="nf">defaultCenter</span><span class="p">]</span> <span class="nf">addObserver</span><span class="p">:</span><span class="n">self</span> <span class="nf">selector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">taskDidSuspend</span><span class="o">:</span><span class="p">)</span> <span class="n">name</span><span class="o">:</span><span class="n">AFNSURLSessionTaskDidSuspendNotification</span> <span class="n">object</span><span class="o">:</span><span class="nb">nil</span><span class="p">];</span>

    <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>
<p>看起来好多，对我们本次的目的其实需要关心的东西很少，我都给出来了注释。</p>

<p>第二处是dataTask的创建，为了说明，先把程序跑起来看看函数的调用栈。任务一启动，首先进入到了[AFURLSessionManager dataTaskWithRequest:completionHandler:]函数中：</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="n">NSURLSessionDataTask</span> <span class="o">*</span><span class="p">)</span><span class="nf">dataTaskWithRequest</span><span class="p">:(</span><span class="n">NSURLRequest</span> <span class="o">*</span><span class="p">)</span><span class="nv">request</span>
                            <span class="nf">completionHandler</span><span class="p">:(</span><span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="n">NSURLResponse</span> <span class="o">*</span><span class="n">response</span><span class="p">,</span> <span class="n">id</span> <span class="n">responseObject</span><span class="p">,</span> <span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">))</span><span class="nv">completionHandler</span>
<span class="p">{</span>
    <span class="n">__block</span> <span class="n">NSURLSessionDataTask</span> <span class="o">*</span><span class="n">dataTask</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
    <span class="n">dispatch_sync</span><span class="p">(</span><span class="n">url_session_manager_creation_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
        <span class="n">dataTask</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">session</span> <span class="nf">dataTaskWithRequest</span><span class="p">:</span><span class="n">request</span><span class="p">];</span>
    <span class="p">});</span>

    <span class="p">[</span><span class="n">self</span> <span class="nf">addDelegateForDataTask</span><span class="p">:</span><span class="n">dataTask</span> <span class="nf">completionHandler</span><span class="p">:</span><span class="n">completionHandler</span><span class="p">];</span>

    <span class="k">return</span> <span class="n">dataTask</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>
<p>函数体内主要是在一个GCD队列里创建dataTask，此处用到的是GCD同步API。然后调用了第一个私有方法[AFURLSessionManager addDelegateForDataTask:completionHandler:]来设置dataTask的代理和回调的block:</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">addDelegateForDataTask</span><span class="p">:(</span><span class="n">NSURLSessionDataTask</span> <span class="o">*</span><span class="p">)</span><span class="nv">dataTask</span>
             <span class="nf">completionHandler</span><span class="p">:(</span><span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="n">NSURLResponse</span> <span class="o">*</span><span class="n">response</span><span class="p">,</span> <span class="n">id</span> <span class="n">responseObject</span><span class="p">,</span> <span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">))</span><span class="nv">completionHandler</span>
<span class="p">{</span>
    <span class="n">AFURLSessionManagerTaskDelegate</span> <span class="o">*</span><span class="n">delegate</span> <span class="o">=</span> <span class="p">[[</span><span class="n">AFURLSessionManagerTaskDelegate</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">init</span><span class="p">];</span>
    <span class="n">delegate</span><span class="p">.</span><span class="n">manager</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>
    <span class="n">delegate</span><span class="p">.</span><span class="n">completionHandler</span> <span class="o">=</span> <span class="n">completionHandler</span><span class="p">;</span>

    <span class="n">dataTask</span><span class="p">.</span><span class="n">taskDescription</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">taskDescriptionForSessionTasks</span><span class="p">;</span>
    
    <span class="p">[</span><span class="n">self</span> <span class="nf">setDelegate</span><span class="p">:</span><span class="n">delegate</span> <span class="nf">forTask</span><span class="p">:</span><span class="n">dataTask</span><span class="p">];</span>
<span class="p">}</span>
</code></pre>
</div>
<p>在这个函数内真正的设置了网络的代理，就是刚才提到的AFURLSessionManagerTaskDelegate类，这里有一个小细节需要注意一下，就是这一行<code class="highlighter-rouge">delegate.manager = self</code>，在该函数内定义了一个delegate并且持有了manager,而在AFURLSessionManagerTaskDelegate定义中声明了一个AFURLSessionManager对象manager。这就是说delegate持有了manager，manager持有了delegate，循环引用的问题就出来了，这里的解决方法是通过将AFURLSessionManagerTaskDelegate中的manager属性的内存管理语义声明为weak。我们看一下，该类的声明就知道了。</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="k">@interface</span> <span class="nc">AFURLSessionManagerTaskDelegate</span> <span class="p">:</span> <span class="nc">NSObject</span> <span class="o">&lt;</span><span class="n">NSURLSessionTaskDelegate</span><span class="p">,</span> <span class="n">NSURLSessionDataDelegate</span><span class="p">,</span> <span class="n">NSURLSessionDownloadDelegate</span><span class="o">&gt;</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">weak</span><span class="p">)</span> <span class="n">AFURLSessionManager</span> <span class="o">*</span><span class="n">manager</span><span class="p">;</span><span class="c1">//内存管理语义为weak
</span><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">strong</span><span class="p">)</span> <span class="n">NSMutableData</span> <span class="o">*</span><span class="n">mutableData</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">strong</span><span class="p">)</span> <span class="n">NSProgress</span> <span class="o">*</span><span class="n">progress</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">copy</span><span class="p">)</span> <span class="n">NSURL</span> <span class="o">*</span><span class="n">downloadFileURL</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">copy</span><span class="p">)</span> <span class="n">AFURLSessionDownloadTaskDidFinishDownloadingBlock</span> <span class="n">downloadTaskDidFinishDownloading</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">copy</span><span class="p">)</span> <span class="n">AFURLSessionTaskCompletionHandler</span> <span class="n">completionHandler</span><span class="p">;</span>
<span class="k">@end</span>
</code></pre>
</div>

<p>接着上面的说，接下来函数的调用栈就进入了[AFURLSessionManager setDelegate:dataTask:]。</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setDelegate</span><span class="p">:(</span><span class="n">AFURLSessionManagerTaskDelegate</span> <span class="o">*</span><span class="p">)</span><span class="nv">delegate</span>
            <span class="nf">forTask</span><span class="p">:(</span><span class="n">NSURLSessionTask</span> <span class="o">*</span><span class="p">)</span><span class="nv">task</span>
<span class="p">{</span>
    <span class="n">NSParameterAssert</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
    <span class="n">NSParameterAssert</span><span class="p">(</span><span class="n">delegate</span><span class="p">);</span>

    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">lock</span> <span class="nf">lock</span><span class="p">];</span>
    <span class="n">self</span><span class="p">.</span><span class="n">mutableTaskDelegatesKeyedByTaskIdentifier</span><span class="p">[</span><span class="err">@</span><span class="p">(</span><span class="n">task</span><span class="p">.</span><span class="n">taskIdentifier</span><span class="p">)]</span> <span class="o">=</span> <span class="n">delegate</span><span class="p">;</span>
    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">lock</span> <span class="nf">unlock</span><span class="p">];</span>
<span class="p">}</span>
</code></pre>
</div>
<p>这个函数是用来干吗的呢？还加了锁。从代码上看，就是保存task的代理。</p>

<p>至此，所有的准备工作都做完了只等我们去启动这个任务了。没错，就是通过这一句<code class="highlighter-rouge">[dataTask resume]</code>。写到这，先来总结一下，这些准备工作的函数调用过程，直接甩图了：
<img src="/images/调用过程.png" alt="调用过程" /></p>

<p>接下来就是代理了，代理的过程是这样的，AFURLSessionManager自己实现了代理协议，但是在代理协议方法中，根据dataTask的taskIdentifier找到相应的delegate对象，把具体代理该做的事，交给这个delegate。任务启动后第一个调用的是AFURLSessionManager这个函数：</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="c1">//这是AFURLSessionManager类的方法
</span><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">URLSession</span><span class="p">:(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="p">)</span><span class="nv">session</span>
          <span class="nf">dataTask</span><span class="p">:(</span><span class="n">NSURLSessionDataTask</span> <span class="o">*</span><span class="p">)</span><span class="nv">dataTask</span>
    <span class="nf">didReceiveData</span><span class="p">:(</span><span class="n">NSData</span> <span class="o">*</span><span class="p">)</span><span class="nv">data</span>
<span class="p">{</span>
    <span class="n">AFURLSessionManagerTaskDelegate</span> <span class="o">*</span><span class="n">delegate</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nf">delegateForTask</span><span class="p">:</span><span class="n">dataTask</span><span class="p">];</span>
    <span class="p">[</span><span class="n">delegate</span> <span class="nf">URLSession</span><span class="p">:</span><span class="n">session</span> <span class="nf">dataTask</span><span class="p">:</span><span class="n">dataTask</span> <span class="n">didReceiveData</span><span class="o">:</span><span class="n">data</span><span class="p">];</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">dataTaskDidReceiveData</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">self</span><span class="p">.</span><span class="n">dataTaskDidReceiveData</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">dataTask</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>
<p>可以看出它把delegate取出来之后就转到AFURLSessionManagerTaskDelegate类中去了，调用了AFURLSessionManagerTaskDelegate同名方法。</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="c1">//这是AFURLSessionManagerTaskDelegate类的方法
</span><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">URLSession</span><span class="p">:(</span><span class="n">__unused</span> <span class="n">NSURLSession</span> <span class="o">*</span><span class="p">)</span><span class="nv">session</span>
          <span class="nf">dataTask</span><span class="p">:(</span><span class="n">__unused</span> <span class="n">NSURLSessionDataTask</span> <span class="o">*</span><span class="p">)</span><span class="nv">dataTask</span>
    <span class="nf">didReceiveData</span><span class="p">:(</span><span class="n">NSData</span> <span class="o">*</span><span class="p">)</span><span class="nv">data</span>
<span class="p">{</span>
    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">mutableData</span> <span class="nf">appendData</span><span class="p">:</span><span class="n">data</span><span class="p">];</span>
<span class="p">}</span>
</code></pre>
</div>
<p>上面的这个函数才是真正干事的，AFURLSessionManager类中的同名方法只是打了一个酱油。当请求结束的时候，同样首先会调用AFURLSessionManager中的方法：</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="c1">//这是AFURLSessionManager类的方法
</span><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">URLSession</span><span class="p">:(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="p">)</span><span class="nv">session</span>
              <span class="nf">task</span><span class="p">:(</span><span class="n">NSURLSessionTask</span> <span class="o">*</span><span class="p">)</span><span class="nv">task</span>
<span class="nf">didCompleteWithError</span><span class="p">:(</span><span class="n">NSError</span> <span class="o">*</span><span class="p">)</span><span class="nv">error</span>
<span class="p">{</span>
    <span class="n">AFURLSessionManagerTaskDelegate</span> <span class="o">*</span><span class="n">delegate</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nf">delegateForTask</span><span class="p">:</span><span class="n">task</span><span class="p">];</span>

    <span class="c1">// delegate may be nil when completing a task in the background
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">delegate</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">[</span><span class="n">delegate</span> <span class="nf">URLSession</span><span class="p">:</span><span class="n">session</span> <span class="nf">task</span><span class="p">:</span><span class="n">task</span> <span class="n">didCompleteWithError</span><span class="o">:</span><span class="n">error</span><span class="p">];</span>

        <span class="p">[</span><span class="n">self</span> <span class="nf">removeDelegateForTask</span><span class="p">:</span><span class="n">task</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">taskDidComplete</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">self</span><span class="p">.</span><span class="n">taskDidComplete</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
    <span class="p">}</span>

<span class="p">}</span>
</code></pre>
</div>
<p>真正干事的还是AFURLSessionManagerTaskDelegate类中的同名方法。这里给出这个方法的部分代码：</p>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="c1">//在没有错误的时候就执行这一段代码
</span><span class="n">dispatch_async</span><span class="p">(</span><span class="n">url_session_manager_processing_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
    <span class="n">NSError</span> <span class="o">*</span><span class="n">serializationError</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
    <span class="n">responseObject</span> <span class="o">=</span> <span class="p">[</span><span class="n">manager</span><span class="p">.</span><span class="n">responseSerializer</span> <span class="nf">responseObjectForResponse</span><span class="p">:</span><span class="n">task</span><span class="p">.</span><span class="n">response</span> <span class="nf">data</span><span class="p">:</span><span class="n">data</span> <span class="n">error</span><span class="o">:&amp;</span><span class="n">serializationError</span><span class="p">];</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">downloadFileURL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">responseObject</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">downloadFileURL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">responseObject</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">userInfo</span><span class="p">[</span><span class="nf">AFNetworkingTaskDidCompleteSerializedResponseKey</span><span class="p">]</span> <span class="o">=</span> <span class="n">responseObject</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">serializationError</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">userInfo</span><span class="p">[</span><span class="nf">AFNetworkingTaskDidCompleteErrorKey</span><span class="p">]</span> <span class="o">=</span> <span class="n">serializationError</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//这是真正干事的
</span>    <span class="n">dispatch_group_async</span><span class="p">(</span><span class="n">manager</span><span class="p">.</span><span class="n">completionGroup</span> <span class="p">?:</span> <span class="n">url_session_manager_completion_group</span><span class="p">(),</span> <span class="n">manager</span><span class="p">.</span><span class="n">completionQueue</span> <span class="p">?:</span> <span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
    	<span class="c1">//执行completionHandler，把取到的数据传到外面去，这里的responseObject就是我们请求到的数据
</span>        <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">completionHandler</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">self</span><span class="p">.</span><span class="n">completionHandler</span><span class="p">(</span><span class="n">task</span><span class="p">.</span><span class="n">response</span><span class="p">,</span> <span class="n">responseObject</span><span class="p">,</span> <span class="n">serializationError</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
            <span class="p">[[</span><span class="n">NSNotificationCenter</span> <span class="nf">defaultCenter</span><span class="p">]</span> <span class="nf">postNotificationName</span><span class="p">:</span><span class="n">AFNetworkingTaskDidCompleteNotification</span> <span class="nf">object</span><span class="p">:</span><span class="n">task</span> <span class="n">userInfo</span><span class="o">:</span><span class="n">userInfo</span><span class="p">];</span>
        <span class="p">});</span>
    <span class="p">});</span>
<span class="p">});</span>

</code></pre>
</div>
<p>至此整个代理过程就结束了。其中有一个地方值得注意一下，那就是每用manager创建一个task时，manager都会以task的taskIdentifier属性为key，以delegate为value存入字典中。这样的做的目的应该是一个manager可以管理多个task。</p>

<p>—EOF—</p>


                    ]]>
                </content:encoded>
                <guid isPermaLink="false">/objective-c/afnetworking/2017/05/03/AFNetworking3.0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82/</guid>
                <description>
                    
                    本文主要分析AFNetworking的数据请求部分。
                    
                </description>
                <pubDate>Wed, 03 May 2017 00:00:00 +0800</pubDate>
                <author>冬阳</author>
            </item>
        
    
        
            <item>
                <title>github-pages-搭建成功</title>
                <link>http://localhost:4000/overview/2017/04/27/github-pages-%E6%90%AD%E5%BB%BA%E6%88%90%E5%8A%9F/</link>
                <content:encoded>
                    <![CDATA[
                    <p>早就有想把平时遇到的问题，还有把自己的知识积累做个总结，但是一直懒于动手，结果是，一些知识时间一长，如果用的不是很频繁的话就比较容易忘记，到写这篇博客的时候好像就有一些知识点就忘记了。前一段时间知道了github pages后就，就在网上找了个模板，修修改改，搞了一两天，笔都对前端不太了解，平时做的都是iOS，看来得找个时间看看前端了。好吧，今天就写这么点了，本来还想写写怎么建立自己的博客，不过网上已有很多相关的博客，这里我发一两篇我参考的吧。</p>

<p><a href="https://github.com/uolcano/blog/issues/11">利用GitHub Pages建立项目或个人网站</a></p>

<p><a href="http://www.zhanxin.info/jekyll/2013-08-07-jekyll-doc-installation.html">Jekyll教程</a></p>

<p>–EOF–</p>

                    ]]>
                </content:encoded>
                <guid isPermaLink="false">/overview/2017/04/27/github-pages-%E6%90%AD%E5%BB%BA%E6%88%90%E5%8A%9F/</guid>
                <description>
                    
                    折腾了一两天，终于把博客搭的差不多了。
                    
                </description>
                <pubDate>Thu, 27 Apr 2017 00:00:00 +0800</pubDate>
                <author>冬阳</author>
            </item>
        
    
  </channel>
</rss>
