<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title></title>
    <link>http://localhost:4000</link>
    <description>
      A simple, beautiful theme for Jekyll that emphasizes content rather than aesthetic fluff.
    </description>
    
        
            <item>
                <title>UIView中的frame与bounds的关系</title>
                <link>http://localhost:4000/objectvie-c/uiview/2018/06/06/UIView%E4%B8%AD%E7%9A%84frame%E4%B8%8Ebounds%E7%9A%84%E5%85%B3%E7%B3%BB/</link>
                <content:encoded>
                    <![CDATA[
                    <p>标签： objectvie-c UIView</p>

<h1 id="概念">概念</h1>

<p>在UIView中，frame和bounds属性都是CGRect类型，两者非常相似，在平时的开发中，如果使用AutoLayout进行布局那么frame基本上用不上，而bounds使用的场景也不多，但是在用到的时候，经常想不明白，不明所以，这次要彻底搞懂。</p>

<p>frame是相对于父视图的坐标的，frame中的x和y，代表视图在父视图的起始坐标；frame中的size，代表视图在父视图中的大小。bounds是相对于视图本身而言，bounds的x和y定义了视图左上角的点，当有子视图的时候，子视图以父视图的左上角为原点(0,0)来决定自身在父视图的位置。所以父视图的bounds影响的是其子视图在父视图上的位置，视图的bounds属性的x和y默认为0，即以视图的左上角的点为坐标原点，大小为视图的大小。</p>

<ul>
  <li>frame：描述当前视图在其父视图中的位置和大小。</li>
  <li>bounds：描述当前视图在其自身坐标系统中的位置和大小。</li>
  <li>center：描述当前视图的中心点在其父视图中的位置。</li>
</ul>

<p>想要确定视图在父视图上的大小和位置，可以通过：</p>

<ol>
  <li>
    <p>设置frame。</p>
  </li>
  <li>
    <p>设置bounds和center，bounds可以确定视图大小，center可以确定视图位置。</p>
  </li>
</ol>

<p>frame、bounds、center的关系：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>center.x = frame.origin.x + frame.size.width / 2
center.y = frame.origin.y + frame.size.heigth / 2
</code></pre></div></div>

<p>当设置bounds不设置frame时：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>frame.origin.x = -bounds.size.width / 2
frame.origin.y = -bounds.size.heigth / 2

frame.size.width = bounds.size.width
frame.size.width = bounds.size.width
</code></pre></div></div>

<p>因此，当设置bounds不设置frame时，其center始终为0。</p>

<h1 id="demo">Demo</h1>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>UIView *view1 = [[UIView alloc] initWithFrame:CGRectMake(20, 20, 280, 250)];  
[view1 setBounds:CGRectMake(-20, -20, 280, 250)];  
view1.backgroundColor = [UIColor redColor];  
[self.view addSubview:view1];//添加到self.view  
NSLog(@"view1 frame:%@========view1 bounds:%@",NSStringFromCGRect(view1.frame),NSStringFromCGRect(view1.bounds));  
  
UIView *view2 = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 100, 100)];  
view2.backgroundColor = [UIColor yellowColor];  
[view1 addSubview:view2];//添加到view1上,[此时view1坐标系左上角起点为(-20,-20)]  
NSLog(@"view2 frame:%@========view2 bounds:%@",NSStringFromCGRect(view2.frame),NSStringFromCGRect(view2.bounds));  
</code></pre></div></div>

<p>运行结果：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2018-06-06 16:44:08.794861+0800 LearnCALayer[47486:28184109] view1 frame:\{\{20, 20\}, {280, 250}}========view1 bounds:\{\{-20, -20\}, {280, 250}}
2018-06-06 16:44:08.795074+0800 LearnCALayer[47486:28184109] view2 frame:\{\{0, 0\}, {100, 100}}========view2 bounds:\{\{0, 0\}, {100, 100}}
</code></pre></div></div>

<p><img src="/images/frame_eg.jpg" alt="frame_eg" /></p>

                    ]]>
                </content:encoded>
                <guid isPermaLink="false">/objectvie-c/uiview/2018/06/06/UIView%E4%B8%AD%E7%9A%84frame%E4%B8%8Ebounds%E7%9A%84%E5%85%B3%E7%B3%BB/</guid>
                <description>
                    
                    frame与bounds之间的关系，以及使用bounds与center的效果等同于frame
                    
                </description>
                <pubDate>Wed, 06 Jun 2018 00:00:00 +0800</pubDate>
                <author>冬阳</author>
            </item>
        
    
        
            <item>
                <title>NSFastEnumeration协议快速枚举</title>
                <link>http://localhost:4000/objectvie-c/nsfastenumeration/2018/06/01/NSFastEnumeration-%E5%8D%8F%E8%AE%AE%E5%BF%AB%E9%80%9F%E6%9E%9A%E4%B8%BE/</link>
                <content:encoded>
                    <![CDATA[
                    <p>标签： objectvie-c NSFastEnumeration</p>

<h1 id="问题起源">问题起源</h1>

<p>平时写代码的时候，当遍历一个数组的时候免不了要使用for语句，其中for-in语句经常被使用到，<strong>其具有高效、语法简洁、遍历的时候不能修改元素的值的特点</strong>，而并没有去关心它与for语句的区别，更没关心它是如何实现的，一直以来，都认为只有在系统提供的集合类型中才能使用for-in语句。直到今天，在学习ReactiveCocoa源码的时候，在RACSequence类中发现了，一段代码，让我思考良久，确切的说是RACSequence的子类RACArraySequence。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- (id)foldLeftWithStart:(id)start reduce:(id (^)(id, id))reduce {
	NSCParameterAssert(reduce != NULL);
	if (self.head == nil) return start;
	for (id value in self) {
        NSLog(@"for-in stemtent: %@",value);
		start = reduce(start, value);
	}
	return start;
}
</code></pre></div></div>
<p>我一开始只是试一试RACSequenece的用法，如：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NSArray *array = @[@12,@34,@12,@13,@14,@15,@16,@17,@18,@19,@20,@21,@22,@23,@24,
                       @17,@18,@19,@20,@21,@22,@23];
BOOL result = [array.rac_sequence all:^BOOL(id value) {
    return [value integerValue] &lt; 24;
}];
</code></pre></div></div>

<p>然后就是顺着调用顺序看源码发现了在<code class="highlighter-rouge">foldLeftWithStart: reduce:</code>中有一个for-in语句，而且遍历的对象竟然是自己<strong>RACArraySequence</strong>。这个类的继承关系为：</p>

<p><strong>RACArraySequence-&gt;RACSequence-&gt;RACStream-&gt;NSObject</strong>
其本质是一个NSObject的子类。多方打探后，发现<code class="highlighter-rouge">RACArraySequence</code>实现了<code class="highlighter-rouge">NSFastEnumeration</code>协议，让其具备了for-in的功能。好了，问题发现了，下面开始正文。</p>

<h1 id="nsfastenumeration">NSFastEnumeration</h1>

<p>这个协议很简单，可能是我见过系统框架里最简单的协议了吧。里面只有一个结构体，和一个方法。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef struct {
    unsigned long state;
    id __unsafe_unretained _Nullable * _Nullable itemsPtr;
    unsigned long * _Nullable mutationsPtr;
    unsigned long extra[5];
} NSFastEnumerationState;

- (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState *)state objects:(id __unsafe_unretained _Nullable [_Nonnull])buffer count:(NSUInteger)len;
</code></pre></div></div>
<p>只要实现这个协议，任何类都具备使用for-in能力。网上有一很多资料解释这个结构和这个方法的作用，有一些不是很准确。对这个方法最重要的是<strong>它会调用n次，n=array.length / 16。准确来说，这个方法会分段生成数组，这个数组就是参数buffer。</strong></p>

<ol>
  <li>NSFastEnumerationState只用到了两个字段：itemPtr和mutationPtr。前者指向buffer的首地址，后者用于检测在遍历的过程中是否修改元素，是则抛出异常。</li>
  <li>参数buffer为系统提供的缓冲数组，参数len为缓冲数组的最大长度。</li>
</ol>

<p>对<code class="highlighter-rouge">foldLeftWithStart: reduce:</code>方法断点调试会发现，<code class="highlighter-rouge">countByEnumeratingWithState: objects: count:</code>方法会调用三次。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState *)state objects:(__unsafe_unretained id[])stackbuf count:(NSUInteger)len {
	NSCParameterAssert(len &gt; 0);
	//上一次生成的数组时state-&gt;state保存的index等于源数组的长度时，表示数组生成完毕，返回0
	if (state-&gt;state &gt;= self.backingArray.count) {
		// Enumeration has completed.
		return 0;
	}
	//方法第一次调用时state-&gt;state是为0的，对state结构体进行初始化设置
	if (state-&gt;state == 0) {
		state-&gt;state = self.offset;
		// 因为遍历期间不能修改元素的值，所以mutationsPtr要设置为非空
		state-&gt;mutationsPtr = state-&gt;extra;
	}

	state-&gt;itemsPtr = stackbuf;

	NSUInteger startIndex = state-&gt;state;
	NSUInteger index = 0;

	for (id value in self.backingArray) {
		// Constructing an index set for -enumerateObjectsAtIndexes: can actually be
		// slower than just skipping the items we don't care about.
		if (index &lt; startIndex) {
			++index;
			continue;
		}

		stackbuf[index - startIndex] = value;

		++index;
		if (index - startIndex &gt;= len) break;
	}

	NSCAssert(index &gt; startIndex, @"Final index (%lu) should be greater than start index (%lu)", (unsigned long)index, (unsigned long)startIndex);
	//记录本次生成的数组的长度，以后每一次生成数组时，其下标为相对上一次生成的数组的长度
	//比如：源数组长度为22，则第一次生成的数组stackbuf长度为16，stage-&gt;state= 16，下次生成的数组为长度则为6，index则在16的基础上偏移
	state-&gt;state = index;
	//返回本次生成的stackbuf数组的实际长度
	return index - startIndex;
}
</code></pre></div></div>
<p>反编译以下例子：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int main() {
    NSArray *arr = @[@12,@13,@14,@15,@16];
    for (id value in arr) {
        printf("%ld\n",[value integerValue]);
    }
    return 0;
}
</code></pre></div></div>

<p>汇编结果：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>memset(var_108, 0x0, 0x40);
rax = [var_C0 retain];
var_160 = rax;
rax = [rax countByEnumeratingWithState:var_108 objects:var_B0 count:0x10];
var_168 = rax;
if (rax != 0x0) {
        var_170 = *var_F8;
        var_178 = var_108 + 0x10;
        var_180 = 0x0;
        var_188 = var_168;
        do {
                do {
                        var_190 = var_188;
                        var_198 = var_180;
                        if (**var_178 != var_170) {
                                objc_enumerationMutation(var_160);
                        }
                        printf("%ld\n", [*(var_100 + var_198 * 0x8) integerValue]);
                        var_188 = var_190;
                        var_180 = var_198 + 0x1;
                } while (var_198 + 0x1 &lt; var_190);
                rax = [var_160 countByEnumeratingWithState:var_108 objects:var_B0 count:0x10];
                var_180 = 0x0;
                var_188 = rax;
        } while (rax != 0x0);
}

</code></pre></div></div>


                    ]]>
                </content:encoded>
                <guid isPermaLink="false">/objectvie-c/nsfastenumeration/2018/06/01/NSFastEnumeration-%E5%8D%8F%E8%AE%AE%E5%BF%AB%E9%80%9F%E6%9E%9A%E4%B8%BE/</guid>
                <description>
                    
                    代码中经常能见到的for-in语句，背后的实现细节。
                    
                </description>
                <pubDate>Fri, 01 Jun 2018 00:00:00 +0800</pubDate>
                <author>冬阳</author>
            </item>
        
    
        
            <item>
                <title>关于AutoLayout的一些总结</title>
                <link>http://localhost:4000/objectvie-c/auotlayout/2018/05/31/%E5%85%B3%E4%BA%8EAutoLayout%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/</link>
                <content:encoded>
                    <![CDATA[
                    <p>标签： objectvie-c AuotLayout</p>

<h1 id="布局方式">布局方式</h1>
<h2 id="autolayout">AutoLayout</h2>

<p>Masonry使用AutoLayout布局方式，使用一组约束，构成一个一次方程来计算出视图的x，y，width，heigth。确定视图的约束属性有：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NSLayoutAttributeLeft（视图左边）
NSLayoutAttributeRight（视图右边）
NSLayoutAttributeTop（视图上边）
NSLayoutAttributeBottom（视图底边）
NSLayoutAttributeLeading（视图前边，与左边含义一样）
NSLayoutAttributeTrailing（视图后边，与右边含义一样）
NSLayoutAttributeWidth（视图宽度）
NSLayoutAttributeHeight（视图高度）
NSLayoutAttributeCenterX（视图水平居中）
NSLayoutAttributeCenterY（视图垂直居中）

以下使用默认值与View有关

NSLayoutAttributeRightMargin
NSLayoutAttributeTopMargin
NSLayoutAttributeBottomMargin
NSLayoutAttributeLeadingMargin
NSLayoutAttributeTrailingMargin
NSLayoutAttributeCenterXWithinMargins
NSLayoutAttributeCenterYWithinMargins

NSLayoutRelationLessThanOrEqual(小于等于) NSLayoutRelationEqual（等于） NSLayoutRelationGreaterThanOrEqual（大于等于）
</code></pre></div></div>

<p><img src="/images/AutoLayout.png" alt="AutoLayout" /></p>

<p>图中设置RedView的leading约束，公式为：RedView的左边与BlueView的右边的距离为8，这样就确定了RedView的左边位置也就确定了RedView的x坐标位置。使用AutoLayout布局视图时，所设置的约束必须能够让布局引擎计算出视图的x，y坐标与width和height，才能正确的显示视图。对于UIButton、UILabel、UIImageView来说，这些固件有intrinsic content size，只要设置了内容，那么其大小就固定了，所以使用AutoLayout布局时，只需要约束其左边与右边。intrinsic content size可以重写get方法，返回自定义的大小。UIView有一个layoutMargins属性，用于指定视图和它的子视图之间的边距。默认是{8,8,8,8}，但是如果是viewController的root view则top和bottom的margins为0，左右margins可能是16或者20，这取决于当前的view尺寸，并且不能修改。</p>

<p>每一条约束都有优先级， 用于存在多套约束的情况下，解决约束冲突问题，优先级范围为1-1000，数值越大，优先级越高，高优先级的约束会覆盖低优先级的约束。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[subView mas_makeConstraints:^(MASConstraintMaker *make) {
    make.top.equalTo(superView).offset(10);
    make.left.equalTo(superView).offset(8).priorityMedium();
    make.right.equalTo(superView).offset(-8).priorityMedium();
    make.height.mas_equalTo(100);
    make.width.mas_equalTo(50).priorityHigh();
}];
</code></pre></div></div>

<p>上例中，设置了左右约束，就能确定视图的宽度，如果设置优先级，在布局时就会产生冲突，AutoLayout不知道怎么布局视图的宽度。设置宽度的优先级之后，布局时则会优先满足视图的宽度约束。在AutoLayout中，有：Content Compression Resistance和Content Hugging，分别为抗压缩与抗拉伸，其优先级从1-1000，默认为750。分为水平和垂直两个方面，抗压缩的值越高，视图越不容易被压缩，值越低视图越容易受到压缩；抗拉伸类似。</p>

<p>抗拉伸测试：为了测试内容吸附优先级我们在页面上添加两个View，分别是topView和bottomView，设置他们都水平居中，然后分别和页面的顶部和底部对齐：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>UIView *topView = [UIView new];
topView.backgroundColor = [UIColor colorWithRed:.2 green:.4 blue:.6 alpha:1];
[self.view addSubview:topView];
[topView mas_makeConstraints:^(MASConstraintMaker *make) {
    make.centerX.mas_equalTo(self.view);
    make.top.mas_equalTo(self.mas_topLayoutGuideBottom);//和导航栏底部对齐
    make.width.height.mas_equalTo(50);
}];
 
UIView *bottomView = [UIView new];
bottomView.backgroundColor = [UIColor colorWithRed:.2 green:.4 blue:.6 alpha:1];
[self.view addSubview:bottomView];
[bottomView mas_makeConstraints:^(MASConstraintMaker *make) {
    make.centerX.mas_equalTo(self.view);
    make.bottom.mas_equalTo(self.mas_bottomLayoutGuideBottom);//和页面底部对齐
    make.width.height.mas_equalTo(50);
}];
</code></pre></div></div>

<p>运行结果：</p>

<p><img src="/images/AutoLayout_result1.jpg" alt="AutoLayout_result1" /></p>

<p>下面设置topView.bottom + 40 = bottomView.top，这样在运行的时候其实是会有冲突的，height约束与top约束冲突了。</p>

<p>设置后结果:</p>

<p><img src="/images/AutoLayout_result2.jpg" alt="AutoLayout_result2" /></p>

<p>从运行结果来看，topView显示被拉伸了，如果想要topView正常显示不被拉伸：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[topView setContentHuggingPriority:UILayoutPriorityRequired forAxis:UILayoutConstraintAxisVertical];
</code></pre></div></div>
<p>除了这种方法，还可以使用优先级，来解决冲突，设置bottomView的width和height的优先级最高，设置topView的width和height优先级比bottomView低即可，这样AutoLayout会优先满足bottmView的高度与宽度大小。</p>

<h2 id="uilayoutguide">UILayoutGuide</h2>
<p>iOS9之后出来的，其直接依赖NSLayoutAnchor实现，属性有:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">NSLayoutAnchor</span><span class="err">属性</span>
<span class="cm">/* Constraint creation conveniences. See NSLayoutAnchor.h for details.
 */</span>
<span class="k">@property</span><span class="p">(</span><span class="n">readonly</span><span class="p">,</span> <span class="n">strong</span><span class="p">)</span> <span class="n">NSLayoutXAxisAnchor</span> <span class="o">*</span><span class="n">leadingAnchor</span><span class="p">;</span>    <span class="c1">//x坐标
</span><span class="k">@property</span><span class="p">(</span><span class="n">readonly</span><span class="p">,</span> <span class="n">strong</span><span class="p">)</span> <span class="n">NSLayoutXAxisAnchor</span> <span class="o">*</span><span class="n">trailingAnchor</span><span class="p">;</span>
<span class="k">@property</span><span class="p">(</span><span class="n">readonly</span><span class="p">,</span> <span class="n">strong</span><span class="p">)</span> <span class="n">NSLayoutXAxisAnchor</span> <span class="o">*</span><span class="n">leftAnchor</span><span class="p">;</span>
<span class="k">@property</span><span class="p">(</span><span class="n">readonly</span><span class="p">,</span> <span class="n">strong</span><span class="p">)</span> <span class="n">NSLayoutXAxisAnchor</span> <span class="o">*</span><span class="n">rightAnchor</span><span class="p">;</span>
<span class="k">@property</span><span class="p">(</span><span class="n">readonly</span><span class="p">,</span> <span class="n">strong</span><span class="p">)</span> <span class="n">NSLayoutYAxisAnchor</span> <span class="o">*</span><span class="n">topAnchor</span><span class="p">;</span>    <span class="c1">//y坐标
</span><span class="k">@property</span><span class="p">(</span><span class="n">readonly</span><span class="p">,</span> <span class="n">strong</span><span class="p">)</span> <span class="n">NSLayoutYAxisAnchor</span> <span class="o">*</span><span class="n">bottomAnchor</span><span class="p">;</span>
<span class="k">@property</span><span class="p">(</span><span class="n">readonly</span><span class="p">,</span> <span class="n">strong</span><span class="p">)</span> <span class="n">NSLayoutDimension</span> <span class="o">*</span><span class="n">widthAnchor</span><span class="p">;</span>    <span class="c1">//宽
</span><span class="k">@property</span><span class="p">(</span><span class="n">readonly</span><span class="p">,</span> <span class="n">strong</span><span class="p">)</span> <span class="n">NSLayoutDimension</span> <span class="o">*</span><span class="n">heightAnchor</span><span class="p">;</span>    <span class="c1">//高
</span><span class="k">@property</span><span class="p">(</span><span class="n">readonly</span><span class="p">,</span> <span class="n">strong</span><span class="p">)</span> <span class="n">NSLayoutXAxisAnchor</span> <span class="o">*</span><span class="n">centerXAnchor</span><span class="p">;</span>
<span class="k">@property</span><span class="p">(</span><span class="n">readonly</span><span class="p">,</span> <span class="n">strong</span><span class="p">)</span> <span class="n">NSLayoutYAxisAnchor</span> <span class="o">*</span><span class="n">centerYAnchor</span><span class="p">;</span>
<span class="k">@property</span><span class="p">(</span><span class="n">readonly</span><span class="p">,</span> <span class="n">strong</span><span class="p">)</span> <span class="n">NSLayoutYAxisAnchor</span> <span class="o">*</span><span class="n">firstBaselineAnchor</span><span class="p">;</span>
<span class="k">@property</span><span class="p">(</span><span class="n">readonly</span><span class="p">,</span> <span class="n">strong</span><span class="p">)</span> <span class="n">NSLayoutYAxisAnchor</span> <span class="o">*</span><span class="n">lastBaselineAnchor</span><span class="p">;</span>
</code></pre></div></div>

<p>这种布局方式相对AutoLayout来说，非常简洁。官方例子：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Creating constraints using NSLayoutConstraint
[NSLayoutConstraint
 constraintWithItem:subview
 attribute:NSLayoutAttributeLeading
 relatedBy:NSLayoutRelationEqual
 toItem:self.view
 attribute:NSLayoutAttributeLeadingMargin
 multiplier:1.0
 constant:0.0].active = YES;
  
[NSLayoutConstraint
 constraintWithItem:subview
 attribute:NSLayoutAttributeTrailing
 relatedBy:NSLayoutRelationEqual
 toItem:self.view
 attribute:NSLayoutAttributeTrailingMargin
 multiplier:1.0
 constant:0.0].active = YES;
  
// Creating the same constraints using Layout Anchors
UILayoutGuide *margin = self.view.layoutMarginsGuide;
[subview.leadingAnchor constraintEqualToAnchor:margin.leadingAnchor].active = YES;
[subview.trailingAnchor constraintEqualToAnchor:margin.trailingAnchor].active = YES;
</code></pre></div></div>
<h1 id="应用">应用</h1>

<p>（1）在superView上纵向放置两个subView，使得两个子视图与父视图间的垂直间距和子视图之间的垂直间距始终相等，无论两个子视图的大小如何变化，图黑线长度。</p>

<p><img src="/images/AutoLayout_eg1.png" alt="AutoLayout_eg1" /></p>

<ul>
  <li>使用UILayoutGuide</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>subView1.translatesAutoresizingMaskIntoConstraints = NO;
subView2.translatesAutoresizingMaskIntoConstraints = NO;
     
UILayoutGuide *space1 = [[UILayoutGuide alloc] init];
UILayoutGuide *space2 = [[UILayoutGuide alloc] init];
UILayoutGuide *space3 = [[UILayoutGuide alloc] init];
 
[self.superView addLayoutGuide:space1];
[self.superView addLayoutGuide:space2];
[self.superView addLayoutGuide:space3];
 
[space1.topAnchor constraintEqualToAnchor:self.superView.topAnchor].active = YES;
[space1.bottomAnchor constraintEqualToAnchor:subView1.topAnchor].active = YES;
 
[space2.topAnchor constraintEqualToAnchor:subView1.bottomAnchor].active = YES;
[space2.bottomAnchor constraintEqualToAnchor:subView2.topAnchor].active = YES;
 
[space3.topAnchor constraintEqualToAnchor:subView2.bottomAnchor].active = YES;
[space3.bottomAnchor constraintEqualToAnchor:self.superView.bottomAnchor].active = YES;
 
[space1.heightAnchor constraintEqualToAnchor:space2.heightAnchor].active = YES;
[space2.heightAnchor constraintEqualToAnchor:space3.heightAnchor].active = YES;
</code></pre></div></div>
<ul>
  <li>使用AutoLayout</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>UIView *spaceView1 = UIView.new;
UIView *spaceView2 = UIView.new;
UIView *spaceView3 = UIView.new;
[self.superView addSubview:spaceView1];
[self.superView addSubview:spaceView2];
[self.superView addSubview:spaceView3];
 
[spaceView1 mas_makeConstraints:^(MASConstraintMaker *make) {
    make.top.equalTo(self.superView.mas_top);
    make.centerX.equalTo(self.superView);
    make.bottom.equalTo(subView1.mas_top);
    make.width.mas_equalTo(10);
    make.height.mas_equalTo(@[spaceView2, spaceView3]);
}];
[subView1 mas_makeConstraints:^(MASConstraintMaker *make) {
    make.top.equalTo(spaceView1.mas_bottom);
    make.centerX.equalTo(self.superView);
    make.height.equalTo(@100);
    make.width.equalTo(@100);
    make.bottom.equalTo(spaceView2.mas_top);
}];
[spaceView2 mas_makeConstraints:^(MASConstraintMaker *make) {
    make.top.equalTo(subView1.mas_bottom);
    make.centerX.equalTo(self.superView);
    make.bottom.equalTo(subView2.mas_top);
    make.width.mas_equalTo(@10);
    make.height.mas_equalTo(@[spaceView1, spaceView3]);
}];
[subView2 mas_makeConstraints:^(MASConstraintMaker *make) {
    make.top.equalTo(spaceView2.mas_bottom);
    make.centerX.equalTo(self.superView);
    make.bottom.equalTo(spaceView3.mas_top);
    make.height.equalTo(@50);
    make.width.equalTo(@50);
}];
[spaceView3 mas_makeConstraints:^(MASConstraintMaker *make) {
    make.top.equalTo(subView2.mas_bottom);
    make.centerX.equalTo(self.superView);
    make.bottom.equalTo(self.superView.mas_bottom);
    make.width.mas_equalTo(10);
    make.height.mas_equalTo(@[spaceView1, spaceView2]);
}];
</code></pre></div></div>

<p>比较：使用AutoLayout想保它们之间的距离始终相等，需要使用三个占位视图，并且隐藏，这样视图层级里多出三个占位视图，如果有消息产生，占位视图也会收到。使用UILayoutGuide则不需要占位视图避免了占位视图的缺点，且它不会出现在视图层级中，代码简洁易懂，但是只能运行在iOS 9以上。</p>

<p>（2） 使用Masonry自动撑起scrollView的高度</p>

<p>使用自动布局自动撑起视图的高度时，子视图不直接添加到scrollView上，而是添加到一个contentView，由它撑起scorllView的高度，原来scrollView的子视图变为contentView的子视图。对scrollView使用自动布局时牢记两点：</p>

<ol>
  <li>UIScrollView自身的约束按照正常的视图添加。</li>
  <li>内部子控件的约束不能按照UIScrollView来设置，同时必须完整，否则撑不起contentSize。</li>
</ol>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>UIView* contentView = UIView.new;
[self.scrollView addSubview:contentView];
[contentView makeConstraints:^(MASConstraintMaker *make) {
    make.edges.equalTo(self.scrollView);
    make.width.equalTo(self.scrollView);
}];
UIView *lastView;
CGFloat height = 25;
 
for (int i = 0; i &lt; 10; i++) {
    UIView *view = UIView.new;
    view.backgroundColor = [self randomColor];
    [contentView addSubview:view];
    [view mas_makeConstraints:^(MASConstraintMaker *make) {
        make.top.equalTo(lastView ? lastView.bottom : @0);
        make.left.equalTo(@0);
        make.width.equalTo(contentView.width);
        make.height.equalTo(@(height));
    }];
    height += 25;
    lastView = view;
}
[contentView makeConstraints:^(MASConstraintMaker *make) {
    make.bottom.equalTo(lastView.bottom);
}];
</code></pre></div></div>

<p>（3）在自动计算UITableViewCell高度中的使用</p>

<p>假定我们有如下需求：</p>

<p><img src="/images/AutoLayout_eg3.jpg" alt="AutoLayout_eg3" /></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//图片距左边距离为10，上下居中
[_cellImageView mas_makeConstraints:^(MASConstraintMaker *make) {
    make.left.mas_equalTo(self.contentView).offset(10);
    make.centerY.mas_equalTo(self.contentView);
    make.top.mas_greaterThanOrEqualTo(self.contentView).offset(10);
    make.bottom.mas_lessThanOrEqualTo(self.contentView).offset(-10);
}];
//标题Label,一行显示
[_nameLabel mas_makeConstraints:^(MASConstraintMaker *make) {
    make.left.mas_equalTo(self.cellImageView.mas_right).offset(6);
    make.right.mas_lessThanOrEqualTo(self.contentView).offset(-10);
    make.top.mas_equalTo(self.contentView).offset(10);
}];
//内容label,多行显示
_contentLabel.numberOfLines = 0;
[self.contentView addSubview:_contentLabel];
[_contentLabel mas_makeConstraints:^(MASConstraintMaker *make) {
    make.left.mas_equalTo(self.nameLabel);
    make.top.mas_equalTo(self.nameLabel.mas_bottom).offset(6);
}];
//标题Label,一行显示
[_companyLabel mas_makeConstraints:^(MASConstraintMaker *make) {
    make.left.mas_equalTo(self.contentLabel);
    make.right.mas_lessThanOrEqualTo(self.contentView).offset(-10);
    make.top.mas_equalTo(self.contentLabel.mas_bottom).offset(6);
    make.bottom.mas_equalTo(self.contentView).offset(-10);//设定了这个自动计算cell高度时才知道具体cell的高度
}];
 
[_nameLabel setContentHuggingPriority:UILayoutPriorityRequired forAxis:UILayoutConstraintAxisVertical];
[_companyLabel setContentHuggingPriority:UILayoutPriorityRequired forAxis:UILayoutConstraintAxisVertical];
[_contentLabel setContentHuggingPriority:UILayoutPriorityRequired forAxis:UILayoutConstraintAxisVertical];
</code></pre></div></div>

<p>（4）优先级应用</p>

<p>在页面垂直排列三个视图，彼此之间相距一定距离，中间的视图可有可无，当中间视图存在的时候，三个视图正常排列；当中间视图消失时，底部视图上移至中间视图位置，或者距顶部视图一定距离。</p>

<p>初始位置：</p>

<p><img src="/images/AutoLayout_eg4-1.png" alt="AutoLayout_eg4-1" /></p>

<p>新位置：</p>

<p><img src="/images/AutoLayout_eg4-2.png" alt="AutoLayout_eg4-2" /></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[self.topView mas_makeConstraints:^(MASConstraintMaker *make) {
    make.top.equalTo(self.view.mas_top).offset(100);
    make.centerX.equalTo(self.view);
    make.width.height.equalTo(@50);
}];
[self.midView mas_makeConstraints:^(MASConstraintMaker *make) {
    make.top.equalTo(self.topView.mas_bottom).offset(50);
    make.centerX.equalTo(self.view);
    make.size.equalTo(self.topView);
}];
[self.bottomView mas_makeConstraints:^(MASConstraintMaker *make) {
    make.size.equalTo(self.topView);
    make.centerX.equalTo(self.view);
    make.top.equalTo(self.midView.mas_bottom).offset(50);
    make.top.equalTo(self.topView.mas_bottom).offset(50).priorityHigh();
}];
</code></pre></div></div>

<p>（5）对某个视图，不在同的条件下，会有不同的约束。</p>

<p>在ViewController中添加一个blueView，水平居中，初始状态为距ViewController的顶部一定距离，点击右上角按钮后，blueView移至相距ViewController底部一定距离处。</p>

<p>第一种情况：</p>

<p><img src="/images/AutoLayout_eg5-1.png" alt="AutoLayout_eg5—1" /></p>

<p>第二种情况：</p>

<p><img src="/images/AutoLayout_eg5-2.png" alt="AutoLayout_eg5—2" /></p>

<ol>
  <li>设置两套约束，代价较大。因为视图的水平位置不变，大小不变，变的只是Y方向的约束。使用两套约束的问题在于：对这些不变的约束先remove约束再add约束。</li>
  <li>设置一套约束，持有Y方向上的两种益约束（需要设置两个约束的优先级），任何时刻，只有一个约束生效，避免了第一种方案的缺点。</li>
</ol>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>UIView *subView = UIView.new;
subView.backgroundColor = [UIColor blueColor];
[self.view addSubview:subView];
 
[subView mas_makeConstraints:^(MASConstraintMaker *make) {
    self.topConstraint = make.top.equalTo(self.view).offset(100);
    make.width.height.mas_equalTo(50);
    make.centerX.equalTo(self.view);
    self.bottmConstraint = make.bottom.equalTo(self.view).offset(-50).;
}];
[self.bottmConstraint deactivate];
- (void)click
{
    self.isClick = !self.isClick;
    if (self.isClick) {
        [self.bottmConstraint activate];
        [self.topConstraint deactivate];
    } else {
        [self.bottmConstraint deactivate];
        [self.topConstraint activate];
    }
}
</code></pre></div></div>
<p>（6）topLayoutGuide、bottomLayoutGuide使用</p>

<p>iOS 7以后ViewController增加了这两个属性，tooLayoutGuide代表ViewController最顶部，除了状态栏和导航栏（如果有）；bottomLayoutGuide代表ViewController最底部，除了tabbar（如果有）。</p>

<p><img src="/images/AutoLayout_eg6.png" alt="AuotLayout_eg6" /></p>

<p>如果某个视图设置了topLayoutGudie对齐，那么在有导航栏的情况下视图的顶部总是紧跟在导航栏的底部，在没有导航栏的情况下视图的顶部紧跟在状态栏的底部，bottomLayoutGuide类似。设置这两个约束可以在布局视图的时候避开导航栏、状态栏和tabbar。这两个ViewController的属性，实质为两个虚拟的占位View。如：在ViewController上添加一个View宽和高均为50，水平居中，紧贴状态栏或者导航栏之下。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>UIView *view1 = UIView.new;
view1.backgroundColor = [UIColor blueColor];
[self.view addSubview:view1];
 
[view1 mas_makeConstraints:^(MASConstraintMaker *make) {
    make.top.equalTo(self.mas_topLayoutGuide);
    make.centerX.equalTo(self.view);
    make.width.height.equalTo(@50);
}];
</code></pre></div></div>
<p>iOS 11又引入了一个Safe Area（安全区域）的概念，苹果建议在这个安全区域内放置UI控件。这个安全区域的范围其实就是整个屏幕隔离出状态栏，导航栏，tabar，以及iPhone X顶部刘海，底部虚拟home手势区域的范围。在iOS 11以后想要达到上述效果使用下面的代码：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[view mas_makeConstraints:^(MASConstraintMaker *make) {
   make.top.equalTo(self.view.mas_safeAreaLayoutGuideTop);
   make.centerX.equalTo(self.view);
   make.width.height.mas_equalTo(50);
}];
</code></pre></div></div>

                    ]]>
                </content:encoded>
                <guid isPermaLink="false">/objectvie-c/auotlayout/2018/05/31/%E5%85%B3%E4%BA%8EAutoLayout%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/</guid>
                <description>
                    
                    AutoLayout常用的概念和一些经典的使用场景。
                    
                </description>
                <pubDate>Thu, 31 May 2018 00:00:00 +0800</pubDate>
                <author>冬阳</author>
            </item>
        
    
        
            <item>
                <title>ReactiveCocoa</title>
                <link>http://localhost:4000/objectvie-c/reactivecocoa/2018/05/25/ReactiveCocoa%E5%B8%B8%E7%94%A8%E7%B1%BB/</link>
                <content:encoded>
                    <![CDATA[
                    <p>标签： objectvie-c ReactiveCocoa</p>

<h1 id="reactivecocoa常用类">ReactiveCocoa常用类</h1>
<hr />

<ul>
  <li>RACSingnal</li>
  <li>RACSubject</li>
  <li>RACCommand</li>
  <li>RACMulticastConnection</li>
  <li>RACChannelTerminal</li>
</ul>

<h2 id="racsingal相关的类">RACSingal相关的类</h2>

<!-- ReactiveCocoa里信号都是泛型的，如UITextField的信号是NSString类型的信号，UISlider的信号是NSNumber信号，在涉及到信号的绑定时，不同类型的信号需要map一下。之前我将UITextField信号绑定在UISlider上，想在UITextField上输入数字的时候UISlider的value值跟着变，虽然可以用RACChannelTerminal来实现，但我就是想用RAC宏来绑定信号。刚开始是这样的： -->
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RACEmptySignal ：空信号，用来实现 RACSignal 的 +empty 方法；
RACReturnSignal ：一元信号，用来实现 RACSignal 的 +return:方法；
RACDynamicSignal ：动态信号，使用一个 block - 来实现订阅行为，我们在使用 RACSignal 的 +createSignal: 方法时创建的就是该类的实例；
RACErrorSignal ：错误信号，用来实现 RACSignal 的 +error: 方法；
RACChannelTerminal ：通道终端，代表 RACChannel 的一个终端，用来实现双向绑定。
</code></pre></div></div>
<p>RACSignal代表冷信号，与订阅者是一对一的关系，当有不同的订阅者时，消息都会完整的重发。热号信不管有没有订阅者，都会发送消息。</p>

<p>冷信号：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
    [subscriber sendNext:@1];
    [subscriber sendNext:@2];
    [subscriber sendNext:@3];
    [subscriber sendCompleted];
    return nil;
}];
NSLog(@"Signal was created.");
[[RACScheduler mainThreadScheduler] afterDelay:0.1 schedule:^{
    [signal subscribeNext:^(id x) {
        NSLog(@"Subscriber 1 recveive: %@", x);
    }];
}];

[[RACScheduler mainThreadScheduler] afterDelay:1 schedule:^{
    [signal subscribeNext:^(id x) {
        NSLog(@"Subscriber 2 recveive: %@", x);
    }];
}];
</code></pre></div></div>
<p>两个订阅者都会收到1，2，3，但两个订阅者收到的不是同一个消息，而是两次不同的消息。</p>

<p>热信号：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RACMulticastConnection *connection = [[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
    [[RACScheduler mainThreadScheduler] afterDelay:1 schedule:^{
        [subscriber sendNext:@1];
    }];
    
    [[RACScheduler mainThreadScheduler] afterDelay:2 schedule:^{
        [subscriber sendNext:@2];
    }];
    
    [[RACScheduler mainThreadScheduler] afterDelay:3 schedule:^{
        [subscriber sendNext:@3];
    }];
    
    [[RACScheduler mainThreadScheduler] afterDelay:4 schedule:^{
        [subscriber sendCompleted];
    }];
    return nil;
}] publish];
[connection connect];
RACSignal *signal = connection.signal;
    
NSLog(@"Signal was created.");
[[RACScheduler mainThreadScheduler] afterDelay:1.1 schedule:^{
    [signal subscribeNext:^(id x) {
        NSLog(@"Subscriber 1 recveive: %@", x);
    }];
}];
    
[[RACScheduler mainThreadScheduler] afterDelay:2.1 schedule:^{
    [signal subscribeNext:^(id x) {
        NSLog(@"Subscriber 2 recveive: %@", x);
    }];
}];
</code></pre></div></div>
<p>这次，这两个订阅者收到的都是都一组消息，两都共享信号发出的消息，因此结果与第一个不同。热信号signal主动发送消息，分别在第一秒，第二秒和第三秒，发送了三个消息。订阅者一，在1.1秒后订阅消息，因此只能收到消息2和消息3，错过了1秒钟之前发送的消息；订阅者二，在2.1秒后开始订阅消息，因此只能收到消息3，错过了信号在2秒钟之前发送的消息。冷信号转换成热信号通过<code class="highlighter-rouge">RACMulticastConnection</code>，它内部使用RACSubject订阅RACSignal，前者可以表示热信号。</p>

<h2 id="racsubject相关的类">RACSubject相关的类</h2>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RACGroupedSignal ：分组信号，用来实现 RACSignal 的分组功能；

RACBehaviorSubject ：重演最后值的信号，当被订阅时，会向订阅者发送它最后接收到的值；

RACReplaySubject ：重演信号，保存发送过的值，当被订阅时，会向订阅者重新发送这些值。
</code></pre></div></div>

<p>RACSubject是RACSignal的子类，既能发送信号，又能订阅信号，本身及其子类都是热信号。<strong>使用RACSubject创建的信号，必需要先订阅再发送，订阅者才能收到消息。</strong>RACSubject可以替换代理，代理对象订阅信号，委托对象发送信号。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 1.创建信号
RACSubject *subject = [RACSubject subject];
// 2.订阅信号
[subject subscribeNext:^(id x) {
    NSLog(@"第一个订阅者%@", x);
}];
[subject subscribeNext:^(id x) {
    NSLog(@"第二个订阅者%@", x);
}];
// 3.发送信号
[subject sendNext:@"1"];
</code></pre></div></div>
<p><strong>子类RACBehaviorSubject和RACReplaySubject都可以先发送信号，再订阅信号</strong></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 1.创建信号
RACReplaySubject *replaySubject = [RACReplaySubject subject];
// 2.发送信号
[replaySubject sendNext:@1];
[replaySubject sendNext:@2];
// 3.订阅信号
[replaySubject subscribeNext:^(id x) {
    NSLog(@"第一个订阅者接收到的数据%@",x);
}];
// 订阅信号
[replaySubject subscribeNext:^(id x) {
    NSLog(@"第一个订阅者接收到的数据%@",x);
}];
</code></pre></div></div>
<p>RACReplaySubject会把之前的值都重复的再发一次，使用场景：</p>

<ul>
  <li>如果一个信号每被订阅一次，就需要把之前的值重复发送一遍，使用重复提供信号类。</li>
  <li>用于缓存最新的capacity数量的值</li>
</ul>

<p>RACBehviorSubject只会向订阅者发送最新的消息。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RACBehaviorSubject *subject = [RACBehaviorSubject subject];
[subject subscribeNext:^(id  _Nullable x) {
    NSLog(@"1st subject: %@",x);
}];  
[subject sendNext:@"1"];   
[subject subscribeNext:^(id  _Nullable x) {
    NSLog(@"2st subject: %@",x);
}]; 
[subject sendNext:@"2"];
[subject subscribeNext:^(id  _Nullable x) {
    NSLog(@"3st subject: %@",x);
}]; 
[subject sendNext:@"3"]; 
[subject sendCompleted];
</code></pre></div></div>
<p>最开始有一个订阅者1，它立刻收到最新消息，这时没有最新消息发出，默认为nil，RACBehviorSubject有一个用于创建包含默认值的类方法<code class="highlighter-rouge">behaviorSubjectWithDefaultValue:</code>。然后发送1，马上又有订阅者2，这时最新的消息为1，订阅者2此时只会收到1，订阅者1也会收到最新消息，接着发送2，此时的最新消息为2，订阅者1与订阅者2都会收到消息2。最后创建订阅者3的时候，会收到最新消息2，然后发送3的时候，订阅者1，2，3收到最新消息3。</p>

<h2 id="raccommand">RACCommand</h2>

<p>在ReactiveCocoa中RACCommand的解释为用于处理某些事件的类，比如UI相关的。因此可以将其与UIButton的点击事件进行绑定，还可以对<code class="highlighter-rouge">UIButton</code>的<code class="highlighter-rouge">rac_signalForControlEvents</code>信号的订阅进行处理。RACCommand可以对事件的处理进行包装，并将处理结果发送出来。</p>

<p>运用场景：点击按钮，执行一个网络请求或上传数据或下载图片等，期间只有当command执行完成，按钮才可用。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RACCommand *command = [[RACCommand alloc] initWithEnabled:nil signalBlock:^RACSignal * _Nonnull(id  _Nullable input) {
    return [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {
        //模拟网络处理...
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
			//将结果发送出去
            [subscriber sendNext:@"data"];
            [subscriber sendCompleted];
        });
        return nil;
    }];
}];
//与UIButton绑定
self.button.rac_command = command;
//订阅信号，获取结果
[[command.executionSignals switchToLatest] subscribeNext:^(id  _Nullable x) {
    NSLog(@"%@", x);
}];
</code></pre></div></div>
<p>不与UIButton绑定，手动执行的时候使用<code class="highlighter-rouge">-execute:</code>，可以将网络请求的参数传进去。<code class="highlighter-rouge">RACCommand</code>有一个<code class="highlighter-rouge">executing</code>属性用于监听当前的command是否执行完毕，默认会发送一次，可跳过。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[command execute:nil];
[[command.executionSignals switchToLatest] subscribeNext:^(id  _Nullable x) {
    NSLog(@"%@", x);
}];
//以上等价于
[[command execute:nil] subscribeNext:^(id  _Nullable x) {
    NSLog(@"%@",x);
}];
[[command.executing skip:1] subscribeNext:^(NSNumber * _Nullable x) {
    if ([x boolValue]) {
        NSLog(@"command is executing");
    } else {
        NSLog(@"command executed");
    }
}];
</code></pre></div></div>
<h2 id="racchannelterminal">RACChannelTerminal</h2>

<p>RACChannelTerminal是RACSignal的子类，可以实现数据流的双向绑定，如model与视图之间的绑定，某一方发生变化，另一方也跟着变。UIKit中支持RACChannelTerminal的类有：</p>

<ul>
  <li>UIDatePicker</li>
  <li>UIStepper</li>
  <li>UISegmentedControl</li>
  <li>UITextField</li>
  <li>UISwitch</li>
  <li>UISlider</li>
</ul>

<p><strong>注意：</strong>获取一个RACChannelTerminal可通过<code class="highlighter-rouge">RACChannelTo</code>宏，也可以通过框架提供的相应属性。<code class="highlighter-rouge">self.valueTextField.rac_newTextChannel</code> 这个只有在输入框输入的时候才会发出新的值，如果用代码设置的text属性，则不会。使用<code class="highlighter-rouge">RACChannelTo</code>宏，只有在使用代码设置text属性时才会发出新的值，当在输入框输入时，则不会。其他控件类似。<strong><em>对于控件不要使用<code class="highlighter-rouge">RACChannelTo</code>宏。</em></strong></p>

<p>绑定view与model：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RACChannelTerminal *text = self.nameText.rac_newTextChannel;
RACChannelTerminal *string = RACChannelTo(self.model, text);
[text subscribe:string];
[string subscribe:text];
</code></pre></div></div>
<h1 id="reactivecocoa常用宏">ReactiveCocoa常用宏</h1>
<hr />

<p><code class="highlighter-rouge">RAC</code>宏总是与一个signal绑定，当signal发每产生一个value时，都是自动执行：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[TARGET setValue: value ?: NIL_VALUE forKeyPath:KEYPATH];
</code></pre></div></div>
<p>更新<code class="highlighter-rouge">RAC</code>宏绑定的，TARGET的属性。
<code class="highlighter-rouge">RACObserve</code>宏，用于观察TARGET的KEYPATH属性，相当于一个KVO，产生一signal，默认会发送一次信号，常与<code class="highlighter-rouge">RAC</code>宏一起使用。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//model改变时，设置label的text属性
RAC(self.outputLabel, text) = RACObserve(self.model, name); 
</code></pre></div></div>

<h1 id="reactivecocoa常用操作方法">ReactiveCocoa常用操作方法</h1>
<hr />

<h2 id="then">then</h2>
<p>用于连接两个信号，当第一个信号完成，才会连接then返回的信号。</p>

<p><strong>注意: 使用then之前的信号的值会被忽略。</strong></p>

<p>底层实现：</p>

<ol>
  <li>先过滤掉之前的信号发出的值。</li>
  <li>使用concat连接then返回的信号</li>
</ol>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
    //发送请求
    NSLog(@"发送上部分的请求");
    //发送信号
    [subscriber sendNext:@"上部分数据"];
    //发送完毕
    //加上后就可以上部分发送完毕后发送下半部分信号
    [subscriber sendCompleted];
    return nil;
    
}];

RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
    //发送请求
    NSLog(@"发送下部分的请求");
    //发送信号
    [subscriber sendNext:@"下部分数据"];
    return nil;
    
}];
    
//thenSignal组合信号
//then:会忽略掉第一个信号的所有值
RACSignal *thenSignal = [signalA then:^RACSignal *{
    //返回的信号就是需要组合的信号
    return signalB;
}];

[thenSignal subscribeNext:^(id x) {
    NSLog(@"%@", x);
}];
</code></pre></div></div>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2018-05-24 19:27:48.573128+0800 ReactiveCocoa[93483:16178302] 发送上部分的请求
2018-05-24 19:27:48.573343+0800 ReactiveCocoa[93483:16178302] 发送下部分的请求
2018-05-24 19:27:48.573457+0800 ReactiveCocoa[93483:16178302] 下部分数据
</code></pre></div></div>

<h2 id="concat">concat</h2>
<p>concat底层实现:
<strong>注意：第一个信号必须调用<code class="highlighter-rouge">sendCompleted:</code></strong></p>

<ol>
  <li>当拼接信号被订阅，就会调用拼接信号的didSubscribe</li>
  <li>didSubscribe中会先订阅第一个源信号（signalA）</li>
  <li>会执行第一个源信号（signalA）的didSubscribe</li>
  <li>第一个源信号（signalA）didSubscribe中发送值，就会调用第一个源信号（signalA）订阅者的nextBlock,通过拼接信号的订阅者把值发送出来.</li>
  <li>第一个源信号（signalA）didSubscribe中发送完成，就会调用第一个源信号（signalA）订阅者的completedBlock,订阅第二个源信号（signalB）这时候才激活（signalB）。</li>
  <li>订阅第二个源信号（signalB）,执行第二个源信号（signalB）的didSubscribe</li>
  <li>第二个源信号（signalA）didSubscribe中发送值,就会通过拼接信号的订阅者把值发送出来.</li>
</ol>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
    //发送请求
    NSLog(@"发送上部分的请求");
    //发送信号
    [subscriber sendNext:@"上部分数据"];
    //发送完毕
    //加上后就可以上部分发送完毕后发送下半部分信号
    [subscriber sendCompleted];
    return nil;
}];
RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
    //发送请求
    NSLog(@"发送下部分的请求");
    //发送信号
    [subscriber sendNext:@"下部分数据"];
    return nil;
}];
//创建组合信号
//concat:按顺序去连接(组合)
//注意:第一个信号必须调用sendCompleted
RACSignal *concat = [signalA concat:signalB];
//订阅组合信号
[concat subscribeNext:^(id x) {
    //既能拿到A信号的值,又能拿到B信号的值
    NSLog(@"x: %@", x);
}];
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2018-05-24 19:30:48.735101+0800 ReactiveCocoa[93570:16181347] 发送上部分的请求
2018-05-24 19:30:48.735292+0800 ReactiveCocoa[93570:16181347] x: 上部分数据
2018-05-24 19:30:48.735426+0800 ReactiveCocoa[93570:16181347] 发送下部分的请求
2018-05-24 19:30:48.735531+0800 ReactiveCocoa[93570:16181347] x: 下部分数据
</code></pre></div></div>

<h2 id="zipwith">zipWith</h2>

<p>把两个信号压缩成一个信号，只有当两个信号同时发出信号内容时，并且把两个信号的内容合并成一个元组，才会触发压缩流的next事件
底层实现:</p>

<ol>
  <li>定义压缩信号，内部就会自动订阅signalA，signalB</li>
  <li>每当signalA或者signalB发出信号，就会判断signalA，signalB有没有发出个信号，有就会把最近发出的信号都包装成元组发出。元组中数据的顺序与发送顺序无关，跟组合顺序有关</li>
</ol>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//创建信号A
RACSubject *signalA = [RACSubject subject];
//创建信号B
RACSubject *signalB = [RACSubject subject];
//压缩成一个信号
//当一个界面多个请求时,要等所有的请求都完成才能更新UI
//打印顺序跟组合顺序有关,跟发送顺序无关
RACSignal *zipSignal = [signalB zipWith:signalA];
[zipSignal subscribeNext:^(id x) {
    NSLog(@"%@", x);
}];
[signalA sendNext:@"HMJ"];
[signalB sendNext:@"GQ"];
</code></pre></div></div>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2018-05-24 19:35:41.495498+0800 ReactiveCocoa[93673:16185744] &lt;RACTwoTuple: 0x604000019b50&gt; (
    GQ,
    HMJ
)
</code></pre></div></div>
<h2 id="combinelatestwith">combineLatestWith</h2>

<p>将多个信号合并起来，并且拿到各个信号的最新的值,必须每个合并的signal至少都有过一次sendNext，才会触发合并的信号。
底层实现：</p>

<ol>
  <li>当组合信号被订阅，内部会自动订阅signalA，signalB,必须两个信号都发出内容，才会被触发。</li>
  <li>并且把两个信号组合成元组发出。</li>
</ol>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
    [subscriber sendNext:@"A"];//一次sendNext
    [subscriber sendCompleted];
    return nil;
}];
RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
    [subscriber sendNext:@"B"];//一次sendNext
    [subscriber sendCompleted];
    return nil;
}];
RACSignal *combineSignal = [signalA combineLatestWith:signalB];
[combineSignal subscribeNext:^(id x) {
    NSLog(@"%@", x);
}];
</code></pre></div></div>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2018-05-24 19:37:48.897069+0800 ReactiveCocoa[93734:16187988] &lt;RACTwoTuple: 0x60800000d540&gt; (
    A,
    B
)
</code></pre></div></div>
<h2 id="combinelatesreduce">combineLates:reduce</h2>

<p>组合多个信号，并聚合，返回聚合后的值</p>

<p>登录界面：当用户名与密码都输入时，登录按钮才可点击。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RACSignal *combineSignal = [RACSignal combineLatest:@[self.nameText.rac_textSignal, self.passwdText.rac_textSignal] reduce:^id(NSString *account, NSString *pwd){
    //block:只要源信号发送内容就会调用,组合成新的一个值
    //聚合的值就是组合信号的内容
    return @(account.length &amp;&amp; pwd.length);
}];
//订阅信号
//    [combineSignal subscribeNext:^(id x) {
//        self.loginBtn.enabled = [x boolValue];
//
//    }];
//等同于
RAC(self.loginBtn, enabled) = combineSignal;
</code></pre></div></div>

<h2 id="merge">merge</h2>

<p>将多个信号合并成一个信号，任何一个信号有新值时都会调用，在textField中输入或者滑动slider订阅者都会收到消息。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RACChannelTerminal *t = [self.slider rac_newValueChannelWithNilValue:nil];
RACSignal *tt = [self.textField rac_textSignal];
RACSignal *ttt = [t merge:tt];
[ttt subscribeNext:^(id  _Nullable x) {
    NSLog(@"%@",x);
}];
</code></pre></div></div>

<h2 id="filter">filter</h2>
<p>filter方法用于过滤信号，当满足条件时才会发送消息</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//只有当text.length&gt;3的时候才会订阅改消息
[[textField.rac_textSignal filter:^BOOL(NSString * text) {
   
    return text.length&gt;3;
    
}] subscribeNext:^(id x) {
   
    NSLog(@"%@",x);
    
}];
</code></pre></div></div>
<h2 id="take">take</h2>
<p>take:当有多个消息发送的时候，只取前面的几条</p>

<p>takeLast:当有多个消息发送的时候，只取最后面的几条。<strong>订阅者必须完成调用，即调用<code class="highlighter-rouge">sendCompleted</code>，才能总共有多少个信号。</strong></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//在textField里输入时，只会取前面的5条消息
[[[self.textField rac_textSignal] take:5]subscribeNext:^(NSString * _Nullable x) {
    NSLog(@"X:%@",x);
}];
</code></pre></div></div>
<h2 id="map">map</h2>

<p>map方法返回映射后的新值</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//输出字符的个数
[[textField.rac_textSignal map:^id(NSString * value) {
    return @(value.length);
}] subscribeNext:^(NSNumber * x) {
    NSLog(@"%@",x);
}];
</code></pre></div></div>

<h2 id="distinctuntilchanged">distinctUntilChanged</h2>

<p>当上一次的值和当前的值有明显的变化就会发出信号，否则会被忽略掉。</p>

<h2 id="ignore">ignore</h2>

<p>忽略某些字符</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//忽略输入框后的空字符
[[self.textField.rac_textSignal ignore:@""] subscribeNext:^(NSString * _Nullable x) {
    NSLog(@"X:%@",x);
}];
</code></pre></div></div>

<h2 id="interval">interval</h2>

<p>每间隔一段时间发送一次信号。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//计时
RAC(lab,text) = [[RACSignal interval:1 onScheduler:[RACScheduler mainThreadScheduler]] map:^id(NSData * value) {
        return value.description;
    }];
</code></pre></div></div>

<h2 id="time">time</h2>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//设置超时时间为2秒,当超过2秒还没有发送消息的时候,就不会发送了
RACSignal *signal = [[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
        [[RACScheduler mainThreadScheduler] afterDelay:3 schedule:^{
            [subscriber sendNext:@"Ricky"];
            [subscriber sendCompleted];
        }];
        return nil;
    }] timeout:2 onScheduler:[RACScheduler mainThreadScheduler]];
    [signal subscribeNext:^(id x) {
    
        NSLog(@"%@",x);
    }];
</code></pre></div></div>


                    ]]>
                </content:encoded>
                <guid isPermaLink="false">/objectvie-c/reactivecocoa/2018/05/25/ReactiveCocoa%E5%B8%B8%E7%94%A8%E7%B1%BB/</guid>
                <description>
                    
                    一些常用类、方法和注意事项。
                    
                </description>
                <pubDate>Fri, 25 May 2018 00:00:00 +0800</pubDate>
                <author>冬阳</author>
            </item>
        
    
        
            <item>
                <title>NSTimer会保留目标对象</title>
                <link>http://localhost:4000/objectvie-c/nstimer/2017/05/22/NSTimer%E4%BC%9A%E4%BF%9D%E7%95%99%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1/</link>
                <content:encoded>
                    <![CDATA[
                    <p>标签： objectvie-c 计时器</p>

<h2 id="前言">前言</h2>

<p>在编写业务逻辑的时候，用到NSTimer的地方很多。比如，定期的更新窗口。对于它开发者文档中有如下描述：</p>
<blockquote>
  <p>You use the NSTimer class to create timer objects or, more simply, timers. A timer waits until a certain time interval has elapsed and then fires, sending a specified message to a target object. For example, you could create an NSTimer object that sends a message to a window, telling it to update itself after a certain time interval.</p>
</blockquote>

<p>这是官方对NSTimer的介绍，就是用来在一个指定的时间间隔内，发送个一消息给一个指定的对象做指定你想要做的事。提到它就顺带提一下CFRunLoopTimerRef，这两个其实是一个东西，只不过是不同框架里的。前者是属于Foundation里的，属于ARC的管理范围，后者是属于Core Foundation里的，基于C语言实现的一个框架，不属于ARC的管理范围。但是这两个框架里的很多东西是是等价的，只是名字不同而已。</p>

<div><font color="#FF6100">PS：在ARC下编程，Cocoa框架下的类都在ARC的管理范围之下包括以NS开头的类。Cocoa是最重要的两个框架为：Foundation和UIKit。使用其他框架的时候要小心了，对象的内存管理需要我们自己来哦！这其中就包括Core Foundation。</font></div>

<blockquote>
  <p>Timers work in conjunction with run loops.Note in particular that run loops maintain strong references to their timers, so you don’t have to maintain your own strong reference to a timer after you have added it to a run loop.A timer is not a real-time mechanism;it fires only when one of the run loop modes to which the timer has been added is running and able to check if the timer’s firing time has passed.</p>
</blockquote>

<p>上面是节选的一段，个人认为比较重要的。主要是说NSTimer是和RunLoop一起工作的，而且RunLoop会对加入其中的NSTimer保持一个强引用。对NSTimer来说，一旦添加进RunLoop中，我们就不需要在外部去维护一个NSTimer的强引用。NSTimer的时间间隔也不是实时，可能比实际的时候多一点，也可能少一点，而且它只在指定的mode中运行。关于RunLoop，<a href="https://zdyoung.github.io/objective-c/runloop/2017/05/09/RunLoop%E5%B0%8F%E8%AE%B0/">这是</a>之前写的。</p>

<h2 id="正文">正文</h2>

<p>以前用计时器的时候，只顾着用了，也没想太多，在后来的学习当中，发现计时器也会持有目标对象从而产生保留环，而且对重复执行的计时器，这种后果不仅是漏了内存还可能有更加严重。以下面的代码为例：</p>
<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//Customer.h
</span><span class="cp">#import &lt;Foundation/Foundation.h&gt;
</span>
<span class="k">@interface</span> <span class="nc">Customer</span> <span class="p">:</span> <span class="nc">NSObject</span>
<span class="k">@property</span><span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">strong</span><span class="p">)</span> <span class="n">NSTimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">;</span>
<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">start</span><span class="p">;</span>
<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">stop</span><span class="p">;</span>
<span class="k">@end</span>

<span class="c1">//Customer.m
</span><span class="cp">#import "MyTimer.h"
</span><span class="k">@implementation</span> <span class="nc">MyTimer</span>
<span class="k">-</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="n">init</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">super</span> <span class="nf">init</span><span class="p">];</span>
<span class="p">}</span>
<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">stop</span>
<span class="p">{</span>
    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">timer</span> <span class="nf">invalidate</span><span class="p">];</span>
    <span class="n">self</span><span class="p">.</span><span class="n">timer</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
<span class="p">}</span>
<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">start</span>
<span class="p">{</span>
    <span class="n">__weak</span> <span class="n">MyTimer</span> <span class="o">*</span><span class="n">timer</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>
    <span class="n">self</span><span class="p">.</span><span class="n">timer</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSTimer</span> <span class="nf">scheduledTimerWithTimeInterval</span><span class="p">:</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span> <span class="nf">target</span><span class="p">:</span><span class="n">self</span> <span class="n">selector</span><span class="o">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">dosomething</span><span class="p">)</span> <span class="n">userInfo</span><span class="o">:</span><span class="nb">nil</span> <span class="n">repeats</span><span class="o">:</span><span class="nb">YES</span><span class="p">];</span>
<span class="p">}</span>
<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">dosomething</span>
<span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"dosomething"</span><span class="p">);</span>
<span class="p">}</span>
<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">dealloc</span>
<span class="p">{</span>
    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">timer</span> <span class="nf">invalidate</span><span class="p">];</span>
<span class="p">}</span>
<span class="k">@end</span>

<span class="c1">//某个作用域
</span><span class="p">{</span>
    <span class="n">Customer</span> <span class="o">*</span><span class="n">cus</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Customer</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">init</span><span class="p">];</span>
    <span class="p">[</span><span class="n">cus</span> <span class="nf">start</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<p>如果一切正常情况，当出了作用域之后cus，cus便会被释放，计时器也会失效。但是因为计时器持有了self，而计时器作为属性又被self持有了，这样就出现了保留环，所以就算出了作用域cus其实也没有被释放即dealloc方法没有执行，计时器也没有失效，依然做着事，这样很可能会出现严重后果，这取决于所做的事。这里除非手动调用stop方法使计时器失效。那有没有更好的办法呢？答案是肯定的，那就是通过块来解决。可以为NSTimer增加一个分类：</p>
<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//NSTimer+blockSupport.h
</span><span class="cp">#import &lt;Foundation/Foundation.h&gt;
</span>
<span class="k">@interface</span> <span class="nc">NSTimer</span> <span class="p">(</span><span class="nl">blockSupport</span><span class="p">)</span>
<span class="k">+</span> <span class="p">(</span><span class="n">NSTimer</span><span class="o">*</span><span class="p">)</span><span class="nf">block_scheduledTimerWithTimerInterval</span><span class="p">:(</span><span class="n">NSTimeInterval</span><span class="p">)</span><span class="nv">interval</span>
                                           <span class="nf">block</span><span class="p">:(</span><span class="kt">void</span><span class="p">(</span><span class="o">^</span><span class="p">)())</span><span class="nv">block</span>
                                         <span class="nf">repeats</span><span class="p">:(</span><span class="n">BOOL</span><span class="p">)</span><span class="nv">repeats</span><span class="p">;</span>

<span class="k">@end</span>

<span class="c1">//NSTimer+blockSupport.m
</span><span class="cp">#import "NSTimer+blockSupport.h"
</span>
<span class="k">@implementation</span> <span class="nc">NSTimer</span> <span class="p">(</span><span class="nl">blockSupport</span><span class="p">)</span>
<span class="k">+</span> <span class="p">(</span><span class="n">NSTimer</span> <span class="o">*</span><span class="p">)</span><span class="nf">block_scheduledTimerWithTimerInterval</span><span class="p">:(</span><span class="n">NSTimeInterval</span><span class="p">)</span><span class="nv">interval</span>
                                             <span class="nf">block</span><span class="p">:(</span><span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="p">)())</span><span class="nv">block</span>
                                           <span class="nf">repeats</span><span class="p">:(</span><span class="n">BOOL</span><span class="p">)</span><span class="nv">repeats</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">self</span> <span class="nf">scheduledTimerWithTimeInterval</span><span class="p">:</span><span class="n">interval</span> <span class="nf">target</span><span class="p">:</span><span class="n">self</span> <span class="n">selector</span><span class="o">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">blockInvoke</span><span class="o">:</span><span class="p">)</span> <span class="n">userInfo</span><span class="o">:</span><span class="p">[</span><span class="n">block</span> <span class="nf">copy</span><span class="p">]</span> <span class="n">repeats</span><span class="o">:</span><span class="n">repeats</span><span class="p">];</span>
<span class="p">}</span>
<span class="k">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">blockInvoke</span><span class="p">:(</span><span class="n">NSTimer</span> <span class="o">*</span><span class="p">)</span><span class="nv">timer</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">block</span><span class="p">)()</span> <span class="o">=</span> <span class="n">timer</span><span class="p">.</span><span class="n">userInfo</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">block</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">block</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">@end</span>
</code></pre></div></div>
<p>通过上面这个类方法创建的计时器，利用了userInfo参数将计时器要执行的任务封装成了块，该参数可以存放一个不透明值即万能值，只要计时器有效，该参数就会一直被保留。仅依靠这个分类还不行，还要对start方法修改如下：</p>
<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">start</span>
<span class="p">{</span>
    <span class="n">__weak</span> <span class="n">MyTimer</span> <span class="o">*</span><span class="n">timer</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>
    <span class="n">self</span><span class="p">.</span><span class="n">timer</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSTimer</span> <span class="nf">block_scheduledTimerWithTimerInterval</span><span class="p">:</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span> <span class="nf">block</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
        <span class="p">[</span><span class="n">timer</span> <span class="nf">dosomething</span><span class="p">];</span>
    <span class="p">}</span> <span class="n">repeats</span><span class="o">:</span><span class="nb">YES</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>
<p>这样把计时器所做的事封装进了block，只要目标对象存在计时器就一直有效，而计时器捕获的只是self的一个弱引用，不会造成保留环。一旦目标对象被释放了，计时器立刻失效。以上内容参考了《Effectvie Objective-c》</p>

<p>–EOF–</p>


                    ]]>
                </content:encoded>
                <guid isPermaLink="false">/objectvie-c/nstimer/2017/05/22/NSTimer%E4%BC%9A%E4%BF%9D%E7%95%99%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1/</guid>
                <description>
                    
                    在开发的过程当中，有很多地方会用到NSTimer。在创建一个NSTimer的时候会要求用户指定一个target，指定完之后这个timer是会保留这个target，千万要注意，不然后果很严重。
                    
                </description>
                <pubDate>Mon, 22 May 2017 00:00:00 +0800</pubDate>
                <author>冬阳</author>
            </item>
        
    
        
            <item>
                <title>AFNetworking3.0之HTTP请求</title>
                <link>http://localhost:4000/objective-c/http/2017/05/19/AFNetworking3.0%E4%B9%8BHTTP%E8%AF%B7%E6%B1%82/</link>
                <content:encoded>
                    <![CDATA[
                    <p>标签： objective-c HTTP</p>

<h2 id="前言">前言</h2>

<p>前面写过了AFNetworking的数据请求和下载的部分，也对AFNetworking有了一个基本的了解，这部分讲一下它是如何实现HTTP请求的，同时也剖析一下AFNetworking整个类的构成。</p>

<h2 id="正文">正文</h2>

<p>AFNetworking3.0的代码比起以前的版本，精简了很多，可读性也大大的提高了。在这版本中，它的实现是对苹果给出的两套有关于网络请求的API及其代理的封装分别为:NSURLSession和NSURLConnection。其中NSURLSession是在iOS 7 或 Mac OS X 10.9以后才出现的API旨在用来替代NSURLConnection。为了兼容以前的代码，库里面还是把NSURLConnection加进来了。之前写关于AFNetworking的博客都是基于NSURLSession实现的，本文不打算讲AFNetworking基于NSURLConnection实现的部分，必竟现在都不太用了。</p>

<p>提到HTTP，就叉开一下，复习一下关于HTTP请求的东西。</p>

<h3 id="http请求">HTTP请求</h3>
<p>当浏览器向Web服务器发出请求时，它向服务器传递了一个数据块，也就是请求信息，它由3个部分组成：</p>
<ol>
  <li>请求方法URI协议/版本</li>
  <li>请求头(Request Header)</li>
  <li>请求正文</li>
</ol>

<p>请求格式：<br />
&lt;request-line&gt;<br />
&lt;headers&gt;<br />
&lt;blank line&gt;<br />
[&lt;request-body&gt;]</p>

<p>一个典型的例子：</p>

<p>GET / HTTP/1.1<br />
Host: youku.com<br />
Upgrade-Insecure-Requests: 1<br />
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36<br />
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,<em>/</em>;q=0.8<br />
Accept-Encoding: gzip, deflate, sdch<br />
Accept-Language: zh-CN,zh;q=0.8,en;q=0.6<br /></p>

<p>这是刚刚抓的请求包头。
第一行GET / HTTP/1.1分别为请求方法，URL（这里是根路径），协议版本1.1。从第二行开始都是请求头，请求头包含许多有关的客户端环境和请求正文的有用信息。例如，请求头可以声明浏览器所用的语言，请求正文的长度等。最后是是请求正文，这里没有。请求头和请求正文之间是一个空行，这个行非常重要，它表示请求头已经结束，接下来的是请求正文。请求正文中可以包含客户提交的查询字符。</p>

<p>HTTP请求方法用的最多的为GET方法与POST方法。</p>
<ol>
  <li>
    <div><font color="#FF6100">GET方法</font>：默认的HTTP请求方法，我们日常用GET方法来提交表单数据，然而用GET方法提交的表单数据只经过了简单的编码，同时它将作为URL的一部分向Web服务器发送，因此，如果使用GET方法来提交表单数据就存在着安全隐患上。例如Http://127.0.0.1/login.jsp?Name=zhangshi&amp;Age=30&amp;Submit=%cc%E+%BD%BB从上面的URL请求中，很容易就可以辩认出表单提交的内容。（？之后的内容）另外由于GET方法提交的数据是作为URL请求的一部分所以提交的数据量不能太大。</div>
  </li>
  <li>
    <div><font color="#FF6100">POST方法</font>：POST方法是GET方法的一个替代方法，它主要是向Web服务器提交表单数据，尤其是大批量的数据。POST方法克服了GET方法的一些缺点。通过POST方法提交表单数据时，数据不是作为URL请求的一部分而是作为标准数据传送给Web服务器，这就克服了GET方法中的信息无法保密和数据量太小的缺点。因此，出于安全的考虑以及对用户隐私的尊重，通常表单提交时采用POST方法。</div>
  </li>
</ol>

<p>HTTP响应也由三个部分组成，分别是：</p>
<ol>
  <li>状态行</li>
  <li>消息报头</li>
  <li>响应正文。</li>
</ol>

<p>响应格式：<br />
＜status-line＞<br />
＜headers＞<br />
＜blank line＞<br />
[＜response-body＞]</p>

<p>一个典型的例子：<br />
HTTP/1.1 200 OK<br />
Date: Thu, 18 May 2017 12:38:15 GMT<br />
Content-Type: text/html; charset=utf-8<br />
Content-Encoding: gzip<br /></p>

<p>第二行为协议状态版本代码描述，这里应答码为200，接下来都是响应头。<br />
HTTP应答码也称为状态码，它反映了Web服务器处理HTTP请求状态。HTTP应答码由3位数字构成，其中首位数字定义了应答码的类型：</p>
<ol>
  <li>
    <div><font color="#FF6100">1XX－信息类（Information）</font>：表示收到Web浏览器请求，正在进一步的处理中。</div>
  </li>
  <li>
    <div><font color="#FF6100">2XX－成功类（Successful）</font>:表示用户请求被正确接收，理解和处理例如：200 OK。</div>
  </li>
  <li>
    <div><font color="#FF6100">3XX-重定向类（Redirection）</font>:表示请求没有成功，客户必须采取进一步的动作。</div>
  </li>
  <li>
    <div><font color="#FF6100">4XX-客户端错误（Client Error）</font>:表示客户端提交的请求有错误。例如：404 NOTFound，意味着请求中所引用的文档不存在。</div>
  </li>
  <li>
    <div><font color="#FF6100">5XX-服务器错误（Server Error）</font>:表示服务器不能完成对请求的处理：如 500。</div>
  </li>
</ol>

<p>好了，现在叉回来。前面讲过AFURLSessionManager是整个库的核心，因为在HTTP这一部分，都是在这个类的基础上实现的。通过源码也可以看到AFURLSessionManager这个类有1000多行代码而接下来要讲的AFHTTPSessionManager类，只有300行多一点，而且AFHTTPSessionManager是继承自AFURLSessionManager的，因此HTTP请求部分的绝大多数工作都交给了AFHTTPSessionManager的父类那部分。来看看整个库的类的构成：<img src="/images/AFNetworking结构图.png" alt="AFNetworking结构图" /></p>

<p>简单介绍一下这张图上的每个类吧，其实
有些类的功能，我也没用过，不过往后可以试试：</p>
<ul>
  <li>
    <div><font color="#FF6100">AFURLSessionManager:</font>这个类前面讲过，它对NSURLSession及NSURLSessionTaskDelegate、NSURLSessionDataDelegate、NSURLSessionDownloadDelegate和NSURLSessionDelegate进行了封装，实现了诸如数据请求，下载和上传任务。</div>
  </li>
  <li>
    <div><font color="#FF6100">AFURLConnectionOperation:</font>它是NSOperation的子类，实现了NSURLConnection代理方法，这是iOS 6 或 Mac OS X 10.8以前用的API，现在基本不用了。</div>
  </li>
  <li>
    <div><font color="#FF6100">AFHTTPSessionManager:</font>这是基于NSURLSession实现的用于HTTP的GET、POST等类，也是本文主要讲的东西。</div>
  </li>
  <li>
    <div><font color="#FF6100">AFHTTPRequestOperation:</font>这是基于AFURLConnectionOperation子类，它和AFHTTPRequestOperationManager是一起配套使用的。这个类封装了可接受的状态码和可接受的内容类型。</div>
  </li>
  <li>
    <div><font color="#FF6100">AFHTTPRequestOperationManager:</font>这个是实现HTTP各个请求方法的和AFHTTPRequestOperation配套使用的。</div>
  </li>
  <li>
    <div><font color="#FF6100">AFURLRequestSerialization:</font>用来封装参数的，也可以用来设置请求头，请求的正文的格式等。比如，可以将请求的HTTP的body设置成JSON并在请求头部分将Content-Type字段的值设成application/json。</div>
  </li>
  <li>
    <div><font color="#FF6100">AFURLResponseSerialization:</font>根据服务器的响应细节来解析响应的数据，此外还可以对响应的数据进行验证。例如，如果期待得到的是JSON格式的数据，那么它会检查响应码是否是2xx开头的，同时还会检查响应头的Content-Type字段是否为application/json，从而将响应的数据正解的解析成对象。</div>
  </li>
  <li>
    <div><font color="#FF6100">AFNetworkReachabilityManager:</font>用来监控网络状态。</div>
  </li>
  <li>
    <div><font color="#FF6100">AFSecurityPolicy:</font>用来管控网络安全的。</div>
  </li>
</ul>

<p>抛开基于NSURLConnection那一部分，真正核心的就两个两类了AFHTTPSessionManager和AFURLSessionManager。</p>

<p>还是以官方给的例子讲吧，这里从网上找了一张图片，使用了GET方法，获取图片并且显示在一个UIImageView上：</p>
<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">AFHTTPSessionManager</span> <span class="o">*</span><span class="n">manager</span> <span class="o">=</span> <span class="p">[</span><span class="n">AFHTTPSessionManager</span> <span class="nf">manager</span><span class="p">];</span>

<span class="c1">//使用了默认的序列化器
</span><span class="n">manager</span><span class="p">.</span><span class="n">responseSerializer</span> <span class="o">=</span> <span class="p">[</span><span class="n">AFHTTPResponseSerializer</span> <span class="nf">serializer</span><span class="p">];</span>

<span class="c1">//发起一个GET请求还是巨方便的。
</span><span class="p">[</span><span class="n">manager</span> <span class="nf">GET</span><span class="p">:</span><span class="s">@"http://img04.tooopen.com/images/20130701/tooopen_10055061.jpg"</span>  <span class="nf">parameters</span><span class="p">:</span><span class="nb">nil</span> <span class="n">success</span><span class="o">:^</span><span class="p">(</span><span class="n">NSURLSessionDataTask</span> <span class="o">*</span> <span class="n">_Nonnull</span> <span class="n">task</span><span class="p">,</span> <span class="n">id</span>  <span class="n">_Nonnull</span> <span class="n">responseObject</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//这里知道得到的数据是一张图片，所以就直接这样生成图片了
</span>    <span class="n">self</span><span class="p">.</span><span class="n">imgView</span><span class="p">.</span><span class="n">image</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIImage</span> <span class="nf">imageWithData</span><span class="p">:</span><span class="n">responseObject</span><span class="p">];</span>
    
<span class="p">}</span> <span class="n">failure</span><span class="o">:^</span><span class="p">(</span><span class="n">NSURLSessionDataTask</span> <span class="o">*</span> <span class="n">_Nonnull</span> <span class="n">task</span><span class="p">,</span> <span class="n">NSError</span> <span class="o">*</span> <span class="n">_Nonnull</span> <span class="n">error</span><span class="p">)</span> <span class="p">{</span>
    
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"%@"</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
    
<span class="p">}];</span>
</code></pre></div></div>
<p>从[AFHTTPSessionManager GET:parameters:success:failure:]方法来一步一步看看，manager都干了什么。</p>
<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="n">NSURLSessionDataTask</span> <span class="o">*</span><span class="p">)</span><span class="nf">GET</span><span class="p">:(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">URLString</span>
                   <span class="nf">parameters</span><span class="p">:(</span><span class="n">id</span><span class="p">)</span><span class="nv">parameters</span>
                      <span class="nf">success</span><span class="p">:(</span><span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="n">NSURLSessionDataTask</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="n">id</span> <span class="n">responseObject</span><span class="p">))</span><span class="nv">success</span>
                      <span class="nf">failure</span><span class="p">:(</span><span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="n">NSURLSessionDataTask</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">))</span><span class="nv">failure</span>
<span class="p">{</span>
    <span class="n">NSURLSessionDataTask</span> <span class="o">*</span><span class="n">dataTask</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nf">dataTaskWithHTTPMethod</span><span class="p">:</span><span class="s">@"GET"</span> <span class="nf">URLString</span><span class="p">:</span><span class="n">URLString</span> <span class="n">parameters</span><span class="o">:</span><span class="n">parameters</span> <span class="n">success</span><span class="o">:</span><span class="n">success</span> <span class="n">failure</span><span class="o">:</span><span class="n">failure</span><span class="p">];</span>

    <span class="p">[</span><span class="n">dataTask</span> <span class="nf">resume</span><span class="p">];</span>

    <span class="k">return</span> <span class="n">dataTask</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>代码还是很少的，就是根据给定的URL地址调用本类的[AFHTTPSessionManager:dataTaskWithHTTPMethod:URLString:parameters:success:failure]方法生成一个dataTask然后启动它。这方法比较关键，一起来看看：</p>
<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="n">NSURLSessionDataTask</span> <span class="o">*</span><span class="p">)</span><span class="nf">dataTaskWithHTTPMethod</span><span class="p">:(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">method</span>
                                       <span class="nf">URLString</span><span class="p">:(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">URLString</span>
                                      <span class="nf">parameters</span><span class="p">:(</span><span class="n">id</span><span class="p">)</span><span class="nv">parameters</span>
                                         <span class="nf">success</span><span class="p">:(</span><span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="n">NSURLSessionDataTask</span> <span class="o">*</span><span class="p">,</span> <span class="n">id</span><span class="p">))</span><span class="nv">success</span>
                                         <span class="nf">failure</span><span class="p">:(</span><span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="n">NSURLSessionDataTask</span> <span class="o">*</span><span class="p">,</span> <span class="n">NSError</span> <span class="o">*</span><span class="p">))</span><span class="nv">failure</span>
<span class="p">{</span>
    <span class="n">NSError</span> <span class="o">*</span><span class="n">serializationError</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
    <span class="c1">//设置request，根据HTTP的请求方法添加参数
</span>    <span class="n">NSMutableURLRequest</span> <span class="o">*</span><span class="n">request</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">requestSerializer</span> <span class="nf">requestWithMethod</span><span class="p">:</span><span class="n">method</span> <span class="nf">URLString</span><span class="p">:[[</span><span class="n">NSURL</span> <span class="nf">URLWithString</span><span class="p">:</span><span class="n">URLString</span> <span class="nf">relativeToURL</span><span class="p">:</span><span class="n">self</span><span class="p">.</span><span class="nf">baseURL</span><span class="p">]</span> <span class="n">absoluteString</span><span class="p">]</span> <span class="n">parameters</span><span class="o">:</span><span class="n">parameters</span> <span class="n">error</span><span class="o">:&amp;</span><span class="n">serializationError</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">serializationError</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">failure</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">dispatch_async</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">completionQueue</span> <span class="p">?:</span> <span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
                <span class="n">failure</span><span class="p">(</span><span class="nb">nil</span><span class="p">,</span> <span class="n">serializationError</span><span class="p">);</span>
            <span class="p">});</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="nb">nil</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">__block</span> <span class="n">NSURLSessionDataTask</span> <span class="o">*</span><span class="n">dataTask</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
    <span class="c1">//这个方法调用的是父类的方法
</span>    <span class="n">dataTask</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nf">dataTaskWithRequest</span><span class="p">:</span><span class="n">request</span> <span class="nf">completionHandler</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">NSURLResponse</span> <span class="o">*</span> <span class="n">__unused</span> <span class="n">response</span><span class="p">,</span> <span class="n">id</span> <span class="n">responseObject</span><span class="p">,</span> <span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">failure</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">failure</span><span class="p">(</span><span class="n">dataTask</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">success</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">success</span><span class="p">(</span><span class="n">dataTask</span><span class="p">,</span> <span class="n">responseObject</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}];</span>

    <span class="k">return</span> <span class="n">dataTask</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>之所以说很关键，是因为它做了两次事，一是生成request，二是调用了父类的方法，用于设置代理，回调之类的，前面说过AFHTTPSessionManager继承自AFURLSessionManager的。这样AFHTTPSessionManager把剩下的部分全部分交给了AFURLSessionManager部分。对于AFURLSessionManager不熟悉的请出门左拐。库中的AFURLRequestSerialization和AFHTTPResponseSerializer也挺重要的，找个时间看看。到这里整个库也差不多看了一半多吧。写的这些都是根据官方给出的用法，去一点一点看探究它的实现。刚开始的时候，也想造个轮子，但是慢慢地发现造轮子考虑的东西太多，费时费力，而且又有写好开源的轮子，何不拿来用呢。世界这么大，得把时间用到别的地方去。用归用，但是也得看看源码，看看人家是怎么实现的，不是一个好的使用者，肯定不适合造轮子。</p>

<p>–EOF–</p>

                    ]]>
                </content:encoded>
                <guid isPermaLink="false">/objective-c/http/2017/05/19/AFNetworking3.0%E4%B9%8BHTTP%E8%AF%B7%E6%B1%82/</guid>
                <description>
                    
                    本文主要分析AFNetworking的HTTP请求部分。
                    
                </description>
                <pubDate>Fri, 19 May 2017 00:00:00 +0800</pubDate>
                <author>冬阳</author>
            </item>
        
    
        
            <item>
                <title>POSIX线程之条件变量</title>
                <link>http://localhost:4000/posix%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/2017/05/16/POSIX%E7%BA%BF%E7%A8%8B%E4%B9%8B%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/</link>
                <content:encoded>
                    <![CDATA[
                    <p>标签： POSIX多线程 条件变量</p>

<h2 id="前言">前言</h2>

<p>这两天看POSIX线程的时候，看到了一道题。问题大概这样的：启动三个线程，线程1打印A，线程2打印B，线程3打印C，三个线程打印的顺序要求为ABC，循环打印10次，也就是ABCABCABC….。这里的关键是要实现三个线程的协作，每次循环都要控制，只有线程1打印A，线程2再打印，然后再是线程3。这里涉及到了线程的同步问题，分别用到了互斥量和条件变量。</p>

<h2 id="正文">正文</h2>

<h3 id="线程同步">线程同步</h3>

<p>在多个控制线程共享内存的时候，需要确保每个线程看到的数据都是一致的。如果每个线程使用的变量，其他线程都不会修改，或者当变量是只读的时候，不会存在不一致的问题。但是当一个线程使用变量的时候，其他线程也可以读取或者修改的时候，就会出现数据不一致的问题。</p>

<!-- 存取时间是指启动一次存储器操作到完成该操作所需的时间。具体地说，读出时为取数时间，写入时为存数时间。取数时间就是指存储器从接受读命令到信息被读出并稳定在存储器数据寄存器中所需的时间；存数时间就是指存储器从接受写命令到把数据从存储器数据寄存器的输出端传送到存储单元所需的时间。 -->

<p>在变量修改时间多于一个存储器访问周期的处理器结构中，当存储器读与存储器写这两个周期交叉时，这种不一致就会出现。存储器访问周期是指连续启动两次独立的存储操作所需间隔的最小时间，存储器的两个基本的操作为读入和写出，指将数据在存储单元与存储寄存器（MDR）之间进行读和写。在读取变量的时候，只有要一个存储器周期，但是修改变量的时候需要两个存储器周期。以n++为例，这条语句并非原子操作，它可以分解为以下三个操作：</p>
<ol>
  <li>从内存单元读入寄存器</li>
  <li>在寄存器中对变量++</li>
  <li>将新的值写回内存单元</li>
</ol>

<div><font color="#FF6100">PS：原子操作是一旦开始就一直运行到结束，中间不会有任何的上下文切换，因此不需要同步。</font></div>

<p>如果两线程几乎在同一时间对同一个变量做增量操作而不进行同步的话，结果可能出现比原来增加了1也可能增加了2，具体要看第二个线程的开始操作获取的数值。</p>

<h3 id="互斥量">互斥量</h3>

<p>互斥量可以确保在同一时间内只有一个线程访问数据，本质上讲就是一把锁。对于使用了互斥量保护的数据而言，谁先得到这把锁谁就先访问到数据，并且把数据锁住不让其他线程访问，如果此时有其他线程想要访问数据会因没有得到锁而进行阻塞状态，在处理完数据之后，把锁解开，这时其他线程才可以访问。这时间其他线程看到锁解开了，就会由阻塞变为可运行状态。</p>

<p>这里由此也引出了，互斥量使用不当的情况下，容易产生死锁。例如，如果线程试图对同一个互斥量加锁两次，那么它自身就会陷入死锁状态。还有程序中使用一个以上的互斥量时，如果一个线程一直占有第一个互斥量，并且试图锁住第二个互斥量时处于阻塞状态，但此时有一个线程在拥有了第二个互斥量时也在试图锁住第一个互斥量时，会因为两个线程都在相互请求另一个线程拥有的资源而无法前进，于是就产生死锁。</p>

<h3 id="条件变量">条件变量</h3>

<p>条件变量是线程的另一种同步机制，与互斥一起使用时，允许线程以无竞争的等待方式等待特定的条件发生。它由互斥量保护，在线程改变条件之前必须首先锁住互斥量。</p>

<p>回到前面提到的问题。前面说了，解法用到了互斥量和条件变量，来看看怎么用的：</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include&lt;iostream&gt;
#include &lt;pthread.h&gt;
</span>
<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">flag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">pthread_cond_t</span> <span class="n">printReady</span> <span class="o">=</span> <span class="n">PTHREAD_COND_INITIALIZER</span><span class="p">;</span>
<span class="n">pthread_mutex_t</span> <span class="n">printLock</span> <span class="o">=</span> <span class="n">PTHREAD_MUTEX_INITIALIZER</span><span class="p">;</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">printA</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        
        <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">printLock</span><span class="p">);</span>
        
        <span class="k">while</span> <span class="p">(</span><span class="n">flag</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">printReady</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">printLock</span><span class="p">);</span>
            
        <span class="p">}</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">);</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
        <span class="n">pthread_cond_broadcast</span><span class="p">(</span><span class="o">&amp;</span><span class="n">printReady</span><span class="p">);</span>
        
        <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">printLock</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">printB</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>

        <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">printLock</span><span class="p">);</span>
        
        <span class="k">while</span> <span class="p">(</span><span class="n">flag</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">printReady</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">printLock</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">);</span>

        <span class="n">flag</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
        <span class="n">pthread_cond_broadcast</span><span class="p">(</span><span class="o">&amp;</span><span class="n">printReady</span><span class="p">);</span>
        
        <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">printLock</span><span class="p">);</span>
        
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">printC</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>

        <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">printLock</span><span class="p">);</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">flag</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">printReady</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">printLock</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">);</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="n">pthread_cond_broadcast</span><span class="p">(</span><span class="o">&amp;</span><span class="n">printReady</span><span class="p">);</span>
        
        <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">printLock</span><span class="p">);</span>
        
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mi">3</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>

    <span class="n">pthread_t</span> <span class="n">tid1</span><span class="p">,</span> <span class="n">tid2</span><span class="p">,</span> <span class="n">tid3</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">ret</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
    <span class="n">err</span> <span class="o">=</span> <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">printA</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="s">"A"</span><span class="p">);</span>

    <span class="n">err</span> <span class="o">=</span> <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid2</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">printB</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="s">"B"</span><span class="p">);</span>
    
    <span class="n">err</span> <span class="o">=</span> <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid3</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">printC</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="s">"C"</span><span class="p">);</span>
    
    
    <span class="n">err</span> <span class="o">=</span> <span class="n">pthread_join</span><span class="p">(</span><span class="n">tid1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ret</span><span class="p">);</span>
    <span class="n">err</span> <span class="o">=</span> <span class="n">pthread_join</span><span class="p">(</span><span class="n">tid2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ret</span><span class="p">);</span>
    <span class="n">err</span> <span class="o">=</span> <span class="n">pthread_join</span><span class="p">(</span><span class="n">tid3</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ret</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这里先来解释几个关于条件变量的函数：</p>
<ul>
  <li><code class="highlighter-rouge">pthread_cond_signal()</code>:发送一个信号给正在当前条件变量的线程队列中处于阻塞等待状态的线程，使其脱离阻塞状态，唤醒后继续执行。如果没有线程处在阻塞等待状态，pthread_cond_signal也会成功返回。一般只给一个阻塞状态的线程发信号。假如有多个线程正在阻塞等待当前条件变量，则根据各等待线程优先级的高低确定哪个线程接收到信号开始继续执行。如果各线程优先级相同，则根据等待时间的长短来确定哪个线程获得信号。但pthread_cond_signal在多处理器上可能同时唤醒多个线程，当只能让一个被唤醒的线程处理某个任务时，其它被唤醒的线程就需要继续wait。POSIX规范要求pthread_cond_signal至少唤醒一个pthread_cond_wait上的线程，有些实现为了简便，在单处理器上也会唤醒多个线程。</li>
  <li><code class="highlighter-rouge">pthread_cond_wait()</code>:等待条件变量的特殊条件发生；pthread_cond_wait() 必须与一个pthread_mutex配套使用。该函数调用实际上依次做了3件事：对当前pthread_mutex解锁、把当前线程挂起到当前条件变量的线程队列、被其它线程的信号唤醒后对当前pthread_mutex申请加锁。如果线程收到一个信号被唤醒，将被配套的互斥锁重新锁住，pthread_cond_wait() 函数将不返回直到线程获得配套的互斥锁。需要注意的是，一个条件变量不应该与多个互斥锁配套使用。</li>
  <li><code class="highlighter-rouge">pthread_cond_broadcast()</code>:某些应用，如线程池，pthread_cond_broadcast唤醒全部线程，但我们通常只需要一部分线程去做执行任务，所以其它的线程需要继续wait。</li>
</ul>

<p>在上面的代码中有一处比较重要，就是<code class="highlighter-rouge">pthread_cond_wait()</code>调用包裹在一个while循环里面，我刚开始的时候是用if来判断的。以printA为例，当flag不满足时，会释放互斥量进入阻塞状态并等待条件发生。其他线程修改了flag之后，随即调用<code class="highlighter-rouge">pthread_cond_broadcast()</code>唤醒其他正在等待条件变量的线程，这时其他两个线程都会从<code class="highlighter-rouge">pthread_cond_wait()</code>调用处返回。但满足flag条件的线程只有一个，这时while循环会再次判断flag条件，满足条件的线程会被唤醒，不满足的会继续阻塞。如果将while改为if，那么那个不满足flag条件的线程也会被唤醒。这里while循环实际上的作用就是只将满足条件的线程唤醒，不满足的继续等待。while还有一个另外一个作用，即线程可能不是由<code class="highlighter-rouge">pthread_cond_signal</code>和<code class="highlighter-rouge">pthread_cond_broadcast</code>唤醒，而是被中断唤醒。这种情况下，也需要重新对flag进行判断。</p>

<p>–EOF–</p>

<h2 id="参考">参考</h2>

<ul>
  <li><a href="http://blog.vladimirprus.com/2005/07/spurious-wakeups.html">Spurious wakeups</a></li>
</ul>

                    ]]>
                </content:encoded>
                <guid isPermaLink="false">/posix%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/2017/05/16/POSIX%E7%BA%BF%E7%A8%8B%E4%B9%8B%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/</guid>
                <description>
                    
                    条件变量是线程可用的另一种同步机制。条件变量给多个线程提供了一个会合的场所。
                    
                </description>
                <pubDate>Tue, 16 May 2017 00:00:00 +0800</pubDate>
                <author>冬阳</author>
            </item>
        
    
        
            <item>
                <title>RunLoop小记</title>
                <link>http://localhost:4000/objective-c/runloop/2017/05/09/RunLoop%E5%B0%8F%E8%AE%B0/</link>
                <content:encoded>
                    <![CDATA[
                    <p>标签： objective-c RunLoop</p>

<hr />

<h2 id="前言">前言</h2>

<p>本文主要从RunLoop是什么，如何使用RunLoop，它和线程之间的关系以及在编程中可能用到的地方来介绍RunLoop。现在CoreFoundation开源了，你可以在<a href="http://opensource.apple.com/tarballs/CF/">这里</a>下载源码。</p>

<h2 id="正文">正文</h2>

<p>RunLoop是什么？在windows下用MFC做过开发的人对于基于消息循环的事件处理机制应该不会陌生，RunLoop和其差不多。从名字上看，它是一个loop而且是一个带条件的，同时又是一个”死循环”，但是它又很特殊，在没有事干的时候，这个循环处于闲等待的状态。写一个死循环容易：</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="p">{</span>

<span class="p">}</span>
</code></pre></div></div>
<p>如果RunLoop是这样做的话，那么也就没什么值研究的了。所以说它是一种带条件的循环，那么又是什么条件呢？那就是消息或者事件，RunLoop是一个基于消息的循环。当没有消息的时候，它就会进入休眠，内核会将其挂起也就是：我睡觉了，没事别叫我。当有消息来的时候就加入到这个循环里时，内核就会将其唤醒，然后对消息进行处理，也就是：睡你XX，起来嗨。形象一点就是：</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">程序员</span> <span class="o">=</span> <span class="err">死了没</span><span class="p">();</span>
<span class="k">while</span><span class="p">(</span><span class="err">程序员</span><span class="p">)</span>
<span class="p">{</span>
    <span class="err">有事干了</span> <span class="o">=</span> <span class="err">我睡觉了没事别叫我</span><span class="p">();</span>
    <span class="k">if</span><span class="p">(</span><span class="err">该搬砖了</span><span class="p">){</span>
        <span class="err">搬砖</span><span class="p">();</span>
    <span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="err">该吃饭了</span><span class="p">){</span>
        <span class="err">吃饭</span><span class="p">();</span>
    <span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="err">该陪妹子了</span><span class="p">){</span>
        <span class="err">@</span><span class="n">throw</span><span class="p">(</span><span class="err">你没妹子</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>RunLoop是和线程配合使用的，一般来说一个线程执行用来执行一个任务，执行完之后就会退出。当我们启动应用程序的时候，默认启动了一个主线程，所有的UI界面都是运行在主线程里的。但是启动后应用程序并不会马上就退出，而是一直运行在那里，等待用户的输入。正常情况下，应该是启动完成后，就会退出。正是RunLoop，才使得应用程序一直运行着。线程刚创建的时候并没有RunLoop（主线程除外），如果不去主动获取。RunLoop的创建发生在第一次获取时，销毁发生在线程结束时。用户只能在一个线程内部获取其RunLoop（主线程除外）。</p>

<p>如何像主线程一样，让我们创建的线程成为常驻线程，当有任务的时候，就交线这个线程去执行。后面的例子中会提到。</p>

<h3 id="runloop工作">RunLoop工作</h3>

<p>先来看看，在我们启动一个应用程序的时候，观察一下主线程的RunLoop的状态。首先说一下，RunLoop的工作的mode：</p>
<ul>
  <li>
    <div><font color="#FF6100">NSDefaultRunLoopMode</font>：RunLoop的默认Mode，空闲状态，也就是什么也不干的时候。</div>
  </li>
  <li>
    <div><font color="#FF6100">UITrackingRunLoopMode</font>：有滑动等其它需要追踪的事件发生时，RunLoop处于此Mode，比如在滚动scrollView时。</div>
  </li>
  <li>
    <div><font color="#FF6100">NSInitializationRunLoopMode</font>：这是一个Private RunLoopMode，App启动时处于此Mode，启动完成进入App主界面后App处于NSDefaultRunLoopMode。</div>
  </li>
  <li>
    <div><font color="#FF6100">NSRunLoopCommonModes</font>：此Mode默认包含了NSDefaultRunLoopMode和UITrackingRunLoopMode。所以，当RunLoop运行在NSDefaultRunLoopMode或UITrackingRunLoopMode时，监听NSRunLoopCommonModes的Observer都会被回调。另外，还可以向NSRunLoopCommonModes里添加其它自定义的Mode。</div>
  </li>
</ul>

<p>每个mode下面又有timer，source和observer。timer是基于时间的触发器，我们在创建timer完的时候一定要把timer放进当前线程的RunLoop中，如果不是主线程还要将这个RunLoop启动，不然这个timer是不会触发的。source是事件产生的地方，系统提供了两个版本，也可以自定义source：</p>
<ul>
  <li>
    <div><font color="#FF6100">source0</font>：处理App内部事件(特指non-port-based事件，这里的事件是一个广义的事件，包括但不限于UI事件)，App负责管理自己的事件触发，如：UIEvent(Touch事件等，GS发起到RunLoop运行再到事件回调到UI)、CFSocketRef。</div>
  </li>
  <li>
    <div><font color="#FF6100">source1</font>：由RunLoop和内核管理，由Mach port驱动（特指port-based事件），如CFMachPort、CFMessagePort、NSSocketPort。特别要注意一下Mach port的概念，它是一个轻量级的进程间通讯的方式，可以理解为它是一个通讯通道，假如同时有几个进程都挂在这个通道上，那么其它进程向这个通道发送消息后，这些挂在这个通道上的进程都可以收到相应的消息。这个Port的概念非常重要，因为它是RunLoop休眠和被唤醒的关键，它是RunLoop与系统内核进行消息通讯的窗口。</div>
  </li>
</ul>

<p>observe是用来监听RunLoop的状态的，RunLoop有以下几种状态：</p>
<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Run Loop Observer Activities */</span>
<span class="k">typedef</span> <span class="nf">CF_OPTIONS</span><span class="p">(</span><span class="n">CFOptionFlags</span><span class="p">,</span> <span class="n">CFRunLoopActivity</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">kCFRunLoopEntry</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span> <span class="c1">//InputSource/Timer已经加入到RunLoop了
</span>    <span class="n">kCFRunLoopBeforeTimers</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span> <span class="c1">//Timer即将要被执行了
</span>    <span class="n">kCFRunLoopBeforeSources</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">),</span> <span class="c1">//InputSource即将要被执行了
</span>    <span class="n">kCFRunLoopBeforeWaiting</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">),</span> <span class="c1">//RunLoop即将休眠了
</span>    <span class="n">kCFRunLoopAfterWaiting</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">),</span> <span class="c1">//RunLoop即将被唤醒
</span>    <span class="n">kCFRunLoopExit</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">),</span> <span class="c1">//RunLoop停止运转了
</span>    <span class="n">kCFRunLoopAllActivities</span> <span class="o">=</span> <span class="mh">0x0FFFFFFFU</span>
<span class="p">}</span>
</code></pre></div></div>
<p>可以看到前四个描述了一个RunLoop的循环周期。</p>
<h3 id="runloop和nsautoreleasepool的关系">RunLoop和NSAutoreleasePool的关系</h3>

<p>这里得说一下NSAutoreleasePool，先来看看官方文档中怎么说的：</p>
<blockquote>
  <p>The Application Kit creates an autorelease pool on the main thread at the beginning of every cycle of the event loop, and drains it at the end, thereby releasing any autoreleased objects generated while processing an event. If you use the Application Kit, you therefore typically don’t have to create your own pools. If your application creates a lot of temporary autoreleased objects within the event loop, however, it may be beneficial to create “local” autorelease pools to help to minimize the peak memory footprint.</p>
</blockquote>

<p>意思是说，应用程序在主线程每个事件循环周期的开始中创建一个自动释放池，在这个循环周期结束的时候，把自动释放池排干，即把注册到自动释放池里的对象全部释放掉。之前一直不太明白，自动释放池是怎么释放对象的，现在可以来试验一下了：</p>
<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//ViewController.m
</span><span class="k">@interface</span> <span class="nc">ViewController</span> <span class="p">()</span>
<span class="c1">//注意label的内存管理语义，用weak也可以，不过weak在赋完值后，输出不了正确结果后面会解释
</span><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">assign</span><span class="p">)</span> <span class="n">UILabel</span> <span class="o">*</span><span class="n">label</span><span class="p">;</span>
<span class="k">@end</span>
<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">viewDidLoad</span>
<span class="p">{</span>
    <span class="p">[</span><span class="n">super</span> <span class="nf">viewDidLoad</span><span class="p">];</span>
    
    <span class="c1">//创建子线程执行任务
</span>    <span class="n">self</span><span class="p">.</span><span class="kr">thread</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSThread</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">initWithTarget</span><span class="p">:</span><span class="n">self</span> <span class="nf">selector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">run</span><span class="p">)</span> <span class="n">object</span><span class="o">:</span><span class="nb">nil</span><span class="p">];</span>
    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="kr">thread</span> <span class="nf">setName</span><span class="p">:</span><span class="s">@"com.thread"</span><span class="p">];</span>
    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="kr">thread</span> <span class="nf">start</span><span class="p">];</span>

<span class="p">}</span>
<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">addRunLoopObserver</span>
<span class="p">{</span>
    
    <span class="c1">//添加RunLoop监听,需要使用CFRunLoop，因为NSRunloop没有这个功能
</span>    
    <span class="c1">//1.获取runloop
</span>    <span class="n">CFRunLoopRef</span> <span class="n">runLoop</span> <span class="o">=</span> <span class="n">CFRunLoopGetCurrent</span><span class="p">();</span>
    
    <span class="c1">//2.1创建上下文
</span>    <span class="n">CFRunLoopObserverContext</span> <span class="n">context</span> <span class="o">=</span> <span class="p">{</span>
        
        <span class="mi">0</span><span class="p">,</span> <span class="c1">//这个context的版本
</span>        <span class="p">(</span><span class="n">__bridge</span> <span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">self</span><span class="p">),</span> <span class="c1">//传入的参数，这里我传入控制器
</span>        <span class="n">CFRetain</span><span class="p">,</span> <span class="c1">//告诉它retain是调用哪个函数
</span>        <span class="n">CFRelease</span><span class="p">,</span> <span class="c1">//告诉它release是调用哪个函数
</span>        <span class="nb">nil</span><span class="p">,</span>
    <span class="p">};</span>
    
    <span class="c1">//2.2创建runloop观察者
</span>
    <span class="n">CFRunLoopObserverRef</span> <span class="n">observer</span> <span class="o">=</span> <span class="n">CFRunLoopObserverCreate</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span>
                                                            <span class="n">kCFRunLoopBeforeWaiting</span><span class="p">,</span>
                                                            <span class="nb">YES</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                                                            <span class="n">callBack</span><span class="p">,</span>
                                                            <span class="o">&amp;</span><span class="n">context</span><span class="p">);</span>
    
    <span class="c1">//3.给runloop添加观察者
</span>    <span class="n">CFRunLoopAddObserver</span><span class="p">(</span><span class="n">runLoop</span><span class="p">,</span> <span class="n">observer</span><span class="p">,</span> <span class="n">kCFRunLoopCommonModes</span><span class="p">);</span>
    
<span class="p">}</span>
 <span class="kt">void</span> <span class="n">callBack</span><span class="p">(</span><span class="n">CFRunLoopObserverRef</span> <span class="n">observer</span><span class="p">,</span> <span class="n">CFRunLoopActivity</span> <span class="n">activity</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//1.拿到传过来的参数，再进行转换,因为这是C函数，不能直接调用self，所以在添加观察的时候把self传过来。
</span>    <span class="n">ViewController</span> <span class="o">*</span><span class="n">vc</span> <span class="o">=</span> <span class="p">(</span><span class="n">__bridge</span> <span class="n">ViewController</span> <span class="o">*</span><span class="p">)(</span><span class="n">info</span><span class="p">);</span>
    
    <span class="c1">//2.看看我们刚才设置的label，在这个循环同期内是否有值，可以看到是有值的。
</span>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"%@"</span><span class="p">,</span><span class="n">vc</span><span class="p">.</span><span class="n">label</span><span class="p">.</span><span class="n">text</span><span class="p">);</span>
<span class="p">}</span>
<span class="o">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">run</span>
<span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"跑起来"</span><span class="p">);</span>
    <span class="err">@autoreleasepool</span> <span class="p">{</span>
        <span class="c1">//这里生成的UILabel就注册到一个自动释放池里了，并且生成后并没有马上释放，也就是说self.label还是有值的哦，可以正常使用，但是编译器给出警告
</span>        <span class="n">self</span><span class="p">.</span><span class="n">label</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UILabel</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">init</span><span class="p">];</span>
        <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">label</span> <span class="nf">setText</span><span class="p">:</span><span class="s">@"这是一个标签"</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="n">NSRunLoop</span> <span class="o">*</span> <span class="n">rl</span> <span class="o">=</span>  <span class="p">[</span><span class="n">NSRunLoop</span> <span class="nf">currentRunLoop</span><span class="p">];</span>
    
    <span class="c1">//向线程添加一个port，这样可以维持线程，使其成为常驻线程
</span>    <span class="p">[</span><span class="n">rl</span> <span class="nf">addPort</span><span class="p">:[</span><span class="n">NSMachPort</span> <span class="nf">port</span><span class="p">]</span> <span class="nf">forMode</span><span class="p">:</span><span class="n">NSDefaultRunLoopMode</span><span class="p">];</span>

    <span class="c1">//添加RunLoopObserver
</span>    <span class="p">[</span><span class="n">self</span> <span class="nf">addRunLoopObserver</span><span class="p">];</span>

    <span class="c1">//启动runloop
</span>    <span class="p">[</span><span class="n">rl</span> <span class="nf">run</span><span class="p">];</span>
    
    <span class="c1">//如果线程成为了常驻线程，不会执行到这行代码
</span>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"end"</span><span class="p">);</span>
<span class="p">}</span>
<span class="o">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">touchesBegan</span><span class="o">:</span><span class="p">(</span><span class="n">NSSet</span><span class="o">&lt;</span><span class="n">UITouch</span> <span class="o">*&gt;</span> <span class="o">*</span><span class="p">)</span><span class="n">touches</span> <span class="n">withEvent</span><span class="o">:</span><span class="p">(</span><span class="n">UIEvent</span> <span class="o">*</span><span class="p">)</span><span class="n">event</span>
<span class="p">{</span>
    <span class="c1">// 让子线程再次执行任务
</span>    <span class="p">[</span><span class="n">self</span> <span class="nf">performSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">againRun</span><span class="p">)</span> <span class="nf">onThread</span><span class="p">:</span><span class="n">self</span><span class="p">.</span><span class="kr">thread</span> <span class="n">withObject</span><span class="o">:</span><span class="nb">nil</span> <span class="n">waitUntilDone</span><span class="o">:</span><span class="nb">NO</span><span class="p">];</span>
<span class="p">}</span>
<span class="o">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">againRun</span>
<span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"再次跑起来"</span><span class="p">);</span>
    <span class="c1">//下面这行是停止当前线程的RunLoop，这个方法是在我们创建的子线程中不是主线程，加上这一行，再跑一次看看会有什么结果
//    CFRunLoopStop(CFRunLoopGetCurrent());
</span><span class="p">}</span>
</code></pre></div></div>
<p>这把段代码跑一次，输出的结果为：</p>
<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">2017</span><span class="o">-</span><span class="mo">05</span><span class="o">-</span><span class="mi">09</span> <span class="mi">11</span><span class="o">:</span><span class="mi">37</span><span class="o">:</span><span class="mi">51</span><span class="p">.</span><span class="mi">134</span> <span class="n">copy</span><span class="p">[</span><span class="mi">92859</span><span class="o">:</span><span class="mi">12314616</span><span class="p">]</span> <span class="err">跑起来</span>
<span class="mi">2017</span><span class="o">-</span><span class="mo">05</span><span class="o">-</span><span class="mi">09</span> <span class="mi">11</span><span class="o">:</span><span class="mi">37</span><span class="o">:</span><span class="mi">51</span><span class="p">.</span><span class="mi">159</span> <span class="n">copy</span><span class="p">[</span><span class="mi">92859</span><span class="o">:</span><span class="mi">12314616</span><span class="p">]</span> <span class="err">这是一个标签</span>
</code></pre></div></div>
<p>当点击屏幕的时候，会在我们创建的线程内执行一次方法<code class="highlighter-rouge">againRun</code>，执行完后，RunLoop就进入了休眠，这时是第二个循环周期，label已经被释放了，所以程序就会因为访问已释放的内存而崩掉。还有一点label的内存管理语义这里设定的为assgin，设置weak的时候也可以但是输也不了正确的结果，通过断点调试的时候确实可以看到当label的内存管理语义为weak的时候，它是有值的，这条语句执行完后<code class="highlighter-rouge">self.label = [[UILabel alloc] init];</code>，label并没有马上释放掉，因为自动释放池延迟了它的释放，正常情况下，赋值完就会立该释放，但这里得不到正确的结果，猜想肯定编译器做了手脚。大家可以将label的内存管理语义改为weak，再跑一次看看。</p>

<h3 id="runloop对timer的影响">RunLoop对timer的影响</h3>

<p>先来看一个例子：</p>
<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//ViewController.m
</span><span class="cp">#import "ViewController.h"
</span>
<span class="k">@interface</span> <span class="nc">ViewController</span> <span class="p">()</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">weak</span><span class="p">,</span> <span class="n">nonatomic</span><span class="p">)</span> <span class="n">IBOutlet</span> <span class="n">UIScrollView</span> <span class="o">*</span><span class="n">scrollView</span><span class="p">;</span>

<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">ViewController</span>

<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">viewDidLoad</span> <span class="p">{</span>
    <span class="p">[</span><span class="n">super</span> <span class="nf">viewDidLoad</span><span class="p">];</span>
    <span class="c1">// Do any additional setup after loading the view, typically from a nib.
</span>    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">scrollView</span> <span class="nf">setContentSize</span><span class="p">:</span><span class="n">CGSizeMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)];</span>
    <span class="n">self</span><span class="p">.</span><span class="n">scrollView</span><span class="p">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>
    <span class="n">NSTimer</span> <span class="o">*</span><span class="n">timer1</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSTimer</span> <span class="nf">timerWithTimeInterval</span><span class="p">:</span><span class="mi">2</span> <span class="nf">target</span><span class="p">:</span><span class="n">self</span> <span class="n">selector</span><span class="o">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">doTimer1</span><span class="p">)</span> <span class="n">userInfo</span><span class="o">:</span><span class="nb">nil</span> <span class="n">repeats</span><span class="o">:</span><span class="nb">YES</span><span class="p">];</span>
    <span class="p">[[</span><span class="n">NSRunLoop</span> <span class="nf">currentRunLoop</span><span class="p">]</span> <span class="nf">addTimer</span><span class="p">:</span><span class="n">timer1</span> <span class="nf">forMode</span><span class="p">:</span><span class="n">NSDefaultRunLoopMode</span><span class="p">];</span>
<span class="p">}</span>
<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">scrollViewDidScroll</span><span class="o">:</span><span class="p">(</span><span class="n">UIScrollView</span> <span class="o">*</span><span class="p">)</span><span class="n">scrollView</span>
<span class="p">{</span>
     <span class="n">NSLog</span><span class="p">(</span><span class="s">@"%@"</span><span class="p">,(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">CFBridgingRelease</span><span class="p">(</span><span class="n">CFRunLoopCopyCurrentMode</span><span class="p">(</span><span class="n">CFRunLoopGetCurrent</span><span class="p">())));</span>
<span class="p">}</span>
<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">touchesBegan</span><span class="o">:</span><span class="p">(</span><span class="n">NSSet</span><span class="o">&lt;</span><span class="n">UITouch</span> <span class="o">*&gt;</span> <span class="o">*</span><span class="p">)</span><span class="n">touches</span> <span class="n">withEvent</span><span class="o">:</span><span class="p">(</span><span class="n">UIEvent</span> <span class="o">*</span><span class="p">)</span><span class="n">event</span>
<span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"%@"</span><span class="p">,(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">CFBridgingRelease</span><span class="p">(</span><span class="n">CFRunLoopCopyCurrentMode</span><span class="p">(</span><span class="n">CFRunLoopGetCurrent</span><span class="p">())));</span>
    
<span class="p">}</span>
<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">touchesMoved</span><span class="o">:</span><span class="p">(</span><span class="n">NSSet</span><span class="o">&lt;</span><span class="n">UITouch</span> <span class="o">*&gt;</span> <span class="o">*</span><span class="p">)</span><span class="n">touches</span> <span class="n">withEvent</span><span class="o">:</span><span class="p">(</span><span class="n">UIEvent</span> <span class="o">*</span><span class="p">)</span><span class="n">event</span>
<span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"%@"</span><span class="p">,(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">CFBridgingRelease</span><span class="p">(</span><span class="n">CFRunLoopCopyCurrentMode</span><span class="p">(</span><span class="n">CFRunLoopGetCurrent</span><span class="p">())));</span>
<span class="p">}</span>
<span class="o">-</span> <span class="p">(</span><span class="n">IBAction</span><span class="p">)</span><span class="n">button</span><span class="o">:</span><span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="n">sender</span>
<span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"%@"</span><span class="p">,(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">CFBridgingRelease</span><span class="p">(</span><span class="n">CFRunLoopCopyCurrentMode</span><span class="p">(</span><span class="n">CFRunLoopGetCurrent</span><span class="p">())));</span>
<span class="p">}</span>
<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">doTimer1</span>
<span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"timer go"</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">@end</span>
</code></pre></div></div>
<p>当程序跑起来什么也不干就会每隔一秒，控制台输入一个timer go，但是如果我们不停的滑动scrollView，控制台就停止输出了。因为这个timer运行在NSDefaultRunLoopMode下，只有当RunLoop在这个mode下才会执行timer，当程序运行的时候，我们没做任何事，Runloop就处在这个mode下，等待用户的输入。但是当我们滑动scrollView时，RunLoop由NSDefaultRunLoopMode转到了UITrackingRunLoopMode下，就不会执行timer了。在点击按钮，滑动scrollView,点击屏幕和移动屏幕中可以看到mode的变化。</p>

<h2 id="总结">总结</h2>

<p>最后以一个RunLoop的应用场景结束本文。在有UITableView的控制器里，滑动UITableView加载图片时，主线程会把图片设置到cell上，如果这时你同时又滑动tableView，会因为主线程同时设置图片和滑动而造成到卡顿的现象。知道了RunLoop后，在滑动的时候，让子线程去处理网络请求，当停止滑动的时候，这时RunLoop进入到了NSDefaultRunLoopMode下，这时让主线程去设置图片。这样实现的话，代码只有一句：</p>
<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">UIImage</span> <span class="o">*</span><span class="n">downloadImage</span> <span class="o">=</span> <span class="p">.....</span>
<span class="p">[</span><span class="n">self</span> <span class="nf">performSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nf">setImage</span><span class="p">:)</span> <span class="n">withObject</span><span class="o">:</span><span class="n">downloadImage</span> <span class="n">afterDelay</span><span class="o">:</span><span class="mi">0</span> <span class="n">inModes</span><span class="o">:</span><span class="n">NSDefaultRunLoopMode</span><span class="p">];</span>
</code></pre></div></div>

<p>–EOF–
<!-- 下次研究CFRunLoop中的CFRunLoopTimer和CFRunLoopSource --></p>

<h2 id="参考">参考</h2>
<ul>
  <li><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1">Threading Programming Guide – iOS Developer Library</a></li>
  <li><a href="http://v.youku.com/v_show/id_XODgxODkzODI0.html">视频: iOS线下分享《RunLoop》by 孙源@sunnyxx</a></li>
  <li><a href="http://blog.ibireme.com/2015/05/18/runloop/">深入理解RunLoop</a></li>
  <li><a href="http://blog.handy.wang/blog/2014/05/26/runloopxue-xi-bi-ji-1/">RunLoop学习笔记</a></li>
</ul>

                    ]]>
                </content:encoded>
                <guid isPermaLink="false">/objective-c/runloop/2017/05/09/RunLoop%E5%B0%8F%E8%AE%B0/</guid>
                <description>
                    
                    RunLoop实际上是一个消息循环，用于处理消息的，只不过它是一种带条件的循环。
                    
                </description>
                <pubDate>Tue, 09 May 2017 00:00:00 +0800</pubDate>
                <author>冬阳</author>
            </item>
        
    
        
            <item>
                <title>编译器指令attribute</title>
                <link>http://localhost:4000/objective-c/attribute/2017/05/06/%E7%BC%96%E8%AF%91%E5%99%A8%E6%8C%87%E4%BB%A4attribute/</link>
                <content:encoded>
                    <![CDATA[
                    <p>标签： objective-c attribute</p>

<hr />

<h2 id="前言">前言</h2>

<p>最近在看开源的框架的时候，经常能看到用__attribute__定义的各种宏。__attribute__是一个编译器指令，用于指定一些声明中特性包括函数声明和变量声明，这样一来可以编译器可以执行一些错误检查或是进行一些高级的优化。说的直白一点就是对声明加一点限制，拿函数而言，可以用__attribute__来限制形参不为空，这样一来，可以保证在编程的过程，函数调用形参一定是不为空的。这只是其中一个用法。这个指令对于编写框架以及更新框架用的多，在实际的编程中用的不多，下面列出的都是一些用法。</p>

<h2 id="正文">正文</h2>

<p>对这个指令还比较陌生的程序员，那么在编程时候，肯定遇到过这样的情况：当调用一人API时，编译器发出警告说这个API在某某版本中已经被废弃，现在用某某API代替。这其实就是__attribute__的一种用法。</p>

<h4 id="用法">用法</h4>

<p>__attribute__后面是由两组圆括号，括号内的属性由逗号分割，该指令放在函数，变量和类型声明之后。</p>

<p>1.<font color="#FF6100">__attribute__((cleanup(...)))</font>，用于修饰一个变量，在它的作用域结束时可以自动执行一个指定的方法，如：</p>
<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 指定一个cleanup方法，注意入参是所修饰变量的地址，类型要一样
// 对于指向objc对象的指针(id *)，如果不强制声明__strong默认是__autoreleasing，造成类型不匹配
</span><span class="k">static</span> <span class="kt">void</span> <span class="n">stringCleanUp</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">__strong</span> <span class="o">*</span><span class="n">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"%@"</span><span class="p">,</span> <span class="o">*</span><span class="n">string</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// 在某个方法中：
</span><span class="p">{</span>
     <span class="n">NSString</span> <span class="o">*</span><span class="n">__strong</span> <span class="n">string</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">cleanup</span><span class="p">(</span><span class="n">stringCleanUp</span><span class="p">)))</span> <span class="o">=</span> <span class="s">@"hello"</span><span class="p">;</span>
<span class="p">}</span> <span class="c1">// 当运行到这个作用域结束时，自动调用stringCleanUp
</span></code></pre></div></div>
<p>所谓作用域结束，包括大括号结束、return、goto、break、exception等各种情况。
当然，可以修饰的变量不止NSString，自定义Class或基本类型都是可以的。</p>

<p>这个指令可以修饰变量，当然也就可以修饰block：</p>
<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// void(^block)(void)的指针是void(^*block)(void)
</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">blockCleanUp</span><span class="p">(</span><span class="n">__strong</span> <span class="kt">void</span><span class="p">(</span><span class="o">^*</span><span class="n">block</span><span class="p">)(</span><span class="kt">void</span><span class="p">))</span> <span class="p">{</span>
    <span class="p">(</span><span class="o">*</span><span class="n">block</span><span class="p">)();</span>
<span class="p">}</span>
</code></pre></div></div>
<p>然后我们在一个作用域里来定义一个block变量：</p>
<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
   <span class="c1">// 加了个`unused`的attribute用来消除`unused variable`的warning
</span>    <span class="n">__strong</span> <span class="kt">void</span><span class="p">(</span><span class="o">^</span><span class="n">block</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">cleanup</span><span class="p">(</span><span class="n">blockCleanUp</span><span class="p">),</span> <span class="n">unused</span><span class="p">))</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@"I'm dying..."</span><span class="p">);</span>
    <span class="p">};</span>
<span class="p">}</span> <span class="c1">//执行完这一行后就会输出"I'm dying..."
</span></code></pre></div></div>

<p>2.<font color="#FF6100">__attribute__((noreturn))</font>，它用于指定函数是不允许有返回值的。</p>
<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">noReturn</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="n">noreturn</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"hello"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>3.<font color="#FF6100">__attribute__((deprecated))</font>,这个可能是大家见的最多了，苹果也经常干这个事，每隔一两个版本可能就会有那么几个API被废弃，然后提示我们用哪个API代替，在编译的时候就会发出警告。</p>
<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">deprecatedMethodWithMessage</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="n">deprecated</span><span class="p">(</span><span class="s">"this method was deprecated in MyApp.app version 5.0.2, use newMethod instead"</span><span class="p">)))</span>
<span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"his method was deprecated in MyApp.app version 5.0.2, use newMethod instead"</span><span class="p">);</span>
<span class="p">}</span><span class="c1">//调用这个方法的时候会发出警告信息，deprecated后面的参数可要可不要。
</span></code></pre></div></div>

<p>4.<font color="#FF6100">__attribute__((warn_unused_result))</font></p>
<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">printMsg</span><span class="p">:(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">str</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">warn_unused_result</span><span class="p">))</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">str</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//这样调用这个函数会报警告信息,提示用户返回值没有被使用，在一些返回值很重要的函数里，这个很有用
</span><span class="p">[</span><span class="n">self</span> <span class="nf">printMsg</span><span class="p">:</span><span class="s">@"msg"</span><span class="p">];</span>
</code></pre></div></div>

<p>5.<font color="#FF6100">__attribute__((unavailable))</font>，这个和deprecated有很大的不一样，如果对函数加上这个，那么这个函数是禁止使用的。</p>
<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="n">init</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">unavailable</span><span class="p">(</span><span class="s">"这个函数不能用！"</span><span class="p">)));</span>
</code></pre></div></div>
<p>如果强行使用这个函数，编译是通不过的。这一种做法可禁止使用默认的初始化方法生成类的实例对象，只能使用用户提供的初始化方法。</p>

<p>6.<font color="#FF6100">__attribute__((overloadable))</font>，这个可以用来实现函数的重载。这里先来说一下两个概念：重载和覆盖。</p>
<ol>
  <li>
    <p>重载：它作用域是在一个类里面，函数名相同，参数不同（参数类型不同，或者参数个数不同），virtual关键字可有可无。</p>
  </li>
  <li>
    <p>覆盖：作用域不同，一个是在基类中一个是在派生类中，参数相同（参数个数和类型均相同），基类函数必须有virtual关键字（派生类可有可无，因为基类函数被声明为虚函数，派生类同名函数一定也是虚函数）</p>
  </li>
</ol>

<p>知道这个两个概念的区别，那么来讲讲objective-c，在这门语言中，是没有重载这个机制的，但是可以覆盖。使用overloadable后可以实现重载，但是不能像c++那样重载实例方法，只能重载c/c++的函数：</p>
<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//调用以下函数时和c/c++调用的语法一样
</span><span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">)</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">overloadable</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"Add Int %i"</span><span class="p">,</span><span class="n">num</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span> <span class="n">num</span><span class="p">)</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">overloadable</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"Add NSString %@"</span><span class="p">,</span><span class="n">num</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="n">NSNumber</span> <span class="o">*</span> <span class="n">num</span><span class="p">)</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">overloadable</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"Add NSNumber %@"</span><span class="p">,</span><span class="n">num</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>7.<font color="#FF6100">__attribute__((objc_subclassing_restricted))</font>，在类的声明文件中加入这一行，表示这个类，不能被继承，就是java类中的final类。如果试图去继承这个类，编译会报错：</p>
<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//customClass.h
</span><span class="n">__attribute__</span><span class="p">((</span><span class="n">objc_subclassing_restricted</span><span class="p">))</span>
<span class="k">@interface</span> <span class="nc">customClass</span> <span class="p">:</span> <span class="nc">NSObject</span>
</code></pre></div></div>

<p>8.<font color="#FF6100">__attribute__((objc_designated_initializer))</font>,这个用于类的初始化方法。对于对象而言，在生成一个实例的时候，如果需要提供必要的信息来完成初始化，才能使该对象正确的完成后面的工作，这种初始化方法叫”全能初始化方法”(designated initializer)。如果创建一个类的方法有多种，相应的，这个类便会有多个初始化方法。如果这些初始化分别初始化类中不同的属性时，那么在实际使用的过程中，当一使用同一个对象，做同一件事的时候，创建对象使用的是不同的初始化方法，那么问题会视后面具体的事出现不同的问题，有些可能不会造成很大的影响，有些可能会造成重大灾难。在《Effectvie objective-c 2.0》，条款16当中有详细的说明。具体的做法是指定一个全能初始化方法，让其他初始化方法去调用这个全能初始化方法。使用objc_designated_initializer还要注意，当存在继承的时候，子类在初始化时要调用父类的全能初始化方法，完成初始化，否则编译器会给出警告信息。</p>
<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//Rectangle.h
</span><span class="k">@interface</span> <span class="nc">Rectangle</span> <span class="p">:</span> <span class="nc">NSObject</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">assign</span><span class="p">,</span> <span class="n">readonly</span><span class="p">)</span> <span class="kt">float</span> <span class="n">width</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">assign</span><span class="p">,</span> <span class="n">readonly</span><span class="p">)</span> <span class="kt">float</span> <span class="n">heigth</span><span class="p">;</span>
<span class="k">-</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="nf">initWithWidth</span><span class="p">:(</span><span class="kt">float</span><span class="p">)</span> <span class="n">width</span> <span class="n">heigth</span><span class="o">:</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span> <span class="n">heigth</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">objc_designated_initializer</span><span class="p">));</span>
<span class="k">-</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="n">init</span> <span class="p">;</span>
<span class="k">@end</span>
<span class="c1">//Rectangle.m
</span><span class="k">@implementation</span> <span class="nc">Rectangle</span>
<span class="k">-</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="nf">initWithWidth</span><span class="p">:(</span><span class="kt">float</span><span class="p">)</span> <span class="n">width</span> <span class="n">heigth</span><span class="o">:</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span> <span class="n">heigth</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">self</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="nf">init</span><span class="p">])</span> <span class="p">{</span>
        <span class="n">_width</span> <span class="o">=</span> <span class="n">width</span><span class="p">;</span>
        <span class="n">_heigth</span> <span class="o">=</span> <span class="n">heigth</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
<span class="p">}</span>
<span class="o">-</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="n">init</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">self</span> <span class="nf">initWithWidth</span><span class="p">:</span><span class="mi">5</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span> <span class="nf">heigth</span><span class="p">:</span><span class="mi">5</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">];</span>
<span class="p">}</span>
<span class="k">@end</span>
</code></pre></div></div>

<p>9.<font color="#FF6100">__attribute__((objc_requires_super))</font>，这个指令表示在子类重写方法时，必须在调用父类中的方法，不然后会给出警告。</p>
<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//Base.h
</span><span class="k">@interface</span> <span class="nc">Base</span> <span class="p">:</span> <span class="nc">NSObject</span>
<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">method1</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">objc_requires_super</span><span class="p">));</span>
<span class="k">@end</span>
<span class="c1">//Base.m
</span><span class="k">@implementation</span> <span class="nc">Base</span>
<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">method1</span>
<span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"Base"</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">@end</span>
<span class="c1">//Derived.h
</span><span class="k">@interface</span> <span class="nc">Derived</span> <span class="p">:</span> <span class="nc">NSObject</span>

<span class="k">@end</span>
<span class="c1">//Derived.m
</span><span class="k">@implementation</span> <span class="nc">Derived</span>
<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">method1</span>
<span class="p">{</span>
    <span class="p">[</span><span class="n">super</span> <span class="nf">method1</span><span class="p">];</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"Derived"</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">@end</span>
</code></pre></div></div>

<p>10.<font color="#FF6100">__attribute__((nonnull))</font>，这个表示函数参数不为空，由编译器检查。</p>
<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">testNonnull</span><span class="p">:(</span><span class="n">id</span><span class="p">)</span><span class="nv">avg1</span> <span class="nf">avg2</span><span class="p">:(</span><span class="n">id</span><span class="p">)</span><span class="nv">avg2</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">nonnull</span><span class="p">))</span>
<span class="p">{</span>
    <span class="c1">//do something
</span><span class="p">}</span>
<span class="c1">//某个作用域内
</span><span class="p">{</span>
    <span class="p">[</span><span class="n">self</span> <span class="nf">testNonnull</span><span class="p">:</span><span class="nb">nil</span> <span class="nf">avg2</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span><span class="c1">//这样使用时编译器会给出警告
</span><span class="p">}</span>
</code></pre></div></div>

<p><a href="http://www.jianshu.com/p/29eb7b5c8b2d"><strong>attribute</strong> 总结</a></p>

<p><a href="http://blog.sunnyxx.com/2016/05/14/clang-attributes/">Clang Attributes 黑魔法小记</a></p>

<p><a href="http://nshipster.com/__attribute__/"><strong>attribute</strong></a></p>

<p><a href="http://www.aopod.com/2016/08/03/attribute-directives/">__attribute__指令</a></p>

<p><a href="http://www.jianshu.com/p/0237c34158f0">Clang 3.8 documentation</a></p>

<p>–EOF–</p>


                    ]]>
                </content:encoded>
                <guid isPermaLink="false">/objective-c/attribute/2017/05/06/%E7%BC%96%E8%AF%91%E5%99%A8%E6%8C%87%E4%BB%A4attribute/</guid>
                <description>
                    
                    attribute是编译器为我们提供的一个指令，在编程过程中善用它能为我们带来意想不到的好处。
                    
                </description>
                <pubDate>Sat, 06 May 2017 00:00:00 +0800</pubDate>
                <author>冬阳</author>
            </item>
        
    
        
            <item>
                <title>AFNetworking3.0源码解读之下载请求</title>
                <link>http://localhost:4000/objective-c/afnetworking/2017/05/05/AFNetworking3.0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%95%B0%E6%8D%AE%E4%B8%8B%E8%BD%BD/</link>
                <content:encoded>
                    <![CDATA[
                    <p>标签： objective-c AFNetworking download</p>

<hr />

<h3 id="前言">前言</h3>

<p>上一篇简单介绍了一下AFURLSessionManager类的结构以及发起一个网络请求的函数调用过程。AFURLSessionManager类中有很多属性，还定义了很多的局部全局变量，在数据请求那大部分用不上。比如，AFURLSessionManager类定义了很多的block:</p>
<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">AFURLSessionDidBecomeInvalidBlock</span><span class="p">)(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">);</span>
<span class="k">typedef</span> <span class="n">NSURLSessionAuthChallengeDisposition</span> <span class="p">(</span><span class="o">^</span><span class="n">AFURLSessionDidReceiveAuthenticationChallengeBlock</span><span class="p">)(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="n">NSURLAuthenticationChallenge</span> <span class="o">*</span><span class="n">challenge</span><span class="p">,</span> <span class="n">NSURLCredential</span> <span class="o">*</span> <span class="n">__autoreleasing</span> <span class="o">*</span><span class="n">credential</span><span class="p">);</span>

<span class="k">typedef</span> <span class="n">NSURLRequest</span> <span class="o">*</span> <span class="p">(</span><span class="o">^</span><span class="n">AFURLSessionTaskWillPerformHTTPRedirectionBlock</span><span class="p">)(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="n">NSURLSessionTask</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="n">NSURLResponse</span> <span class="o">*</span><span class="n">response</span><span class="p">,</span> <span class="n">NSURLRequest</span> <span class="o">*</span><span class="n">request</span><span class="p">);</span>
<span class="k">typedef</span> <span class="n">NSURLSessionAuthChallengeDisposition</span> <span class="p">(</span><span class="o">^</span><span class="n">AFURLSessionTaskDidReceiveAuthenticationChallengeBlock</span><span class="p">)(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="n">NSURLSessionTask</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="n">NSURLAuthenticationChallenge</span> <span class="o">*</span><span class="n">challenge</span><span class="p">,</span> <span class="n">NSURLCredential</span> <span class="o">*</span> <span class="n">__autoreleasing</span> <span class="o">*</span><span class="n">credential</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">AFURLSessionDidFinishEventsForBackgroundURLSessionBlock</span><span class="p">)(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="n">session</span><span class="p">);</span>

<span class="k">typedef</span> <span class="n">NSInputStream</span> <span class="o">*</span> <span class="p">(</span><span class="o">^</span><span class="n">AFURLSessionTaskNeedNewBodyStreamBlock</span><span class="p">)(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="n">NSURLSessionTask</span> <span class="o">*</span><span class="n">task</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">AFURLSessionTaskDidSendBodyDataBlock</span><span class="p">)(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="n">NSURLSessionTask</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">bytesSent</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">totalBytesSent</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">totalBytesExpectedToSend</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">AFURLSessionTaskDidCompleteBlock</span><span class="p">)(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="n">NSURLSessionTask</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">);</span>

<span class="k">typedef</span> <span class="n">NSURLSessionResponseDisposition</span> <span class="p">(</span><span class="o">^</span><span class="n">AFURLSessionDataTaskDidReceiveResponseBlock</span><span class="p">)(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="n">NSURLSessionDataTask</span> <span class="o">*</span><span class="n">dataTask</span><span class="p">,</span> <span class="n">NSURLResponse</span> <span class="o">*</span><span class="n">response</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">AFURLSessionDataTaskDidBecomeDownloadTaskBlock</span><span class="p">)(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="n">NSURLSessionDataTask</span> <span class="o">*</span><span class="n">dataTask</span><span class="p">,</span> <span class="n">NSURLSessionDownloadTask</span> <span class="o">*</span><span class="n">downloadTask</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">AFURLSessionDataTaskDidReceiveDataBlock</span><span class="p">)(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="n">NSURLSessionDataTask</span> <span class="o">*</span><span class="n">dataTask</span><span class="p">,</span> <span class="n">NSData</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">typedef</span> <span class="n">NSCachedURLResponse</span> <span class="o">*</span> <span class="p">(</span><span class="o">^</span><span class="n">AFURLSessionDataTaskWillCacheResponseBlock</span><span class="p">)(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="n">NSURLSessionDataTask</span> <span class="o">*</span><span class="n">dataTask</span><span class="p">,</span> <span class="n">NSCachedURLResponse</span> <span class="o">*</span><span class="n">proposedResponse</span><span class="p">);</span>

<span class="k">typedef</span> <span class="n">NSURL</span> <span class="o">*</span> <span class="p">(</span><span class="o">^</span><span class="n">AFURLSessionDownloadTaskDidFinishDownloadingBlock</span><span class="p">)(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="n">NSURLSessionDownloadTask</span> <span class="o">*</span><span class="n">downloadTask</span><span class="p">,</span> <span class="n">NSURL</span> <span class="o">*</span><span class="n">location</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">AFURLSessionDownloadTaskDidWriteDataBlock</span><span class="p">)(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="n">NSURLSessionDownloadTask</span> <span class="o">*</span><span class="n">downloadTask</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">bytesWritten</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">totalBytesWritten</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">totalBytesExpectedToWrite</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">AFURLSessionDownloadTaskDidResumeBlock</span><span class="p">)(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="n">NSURLSessionDownloadTask</span> <span class="o">*</span><span class="n">downloadTask</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">fileOffset</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">expectedTotalBytes</span><span class="p">);</span>

<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">AFURLSessionTaskCompletionHandler</span><span class="p">)(</span><span class="n">NSURLResponse</span> <span class="o">*</span><span class="n">response</span><span class="p">,</span> <span class="n">id</span> <span class="n">responseObject</span><span class="p">,</span> <span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">);</span>
</code></pre></div></div>
<p>这里列出了该类所有的block，有没有很吓人，刚开始看的时候，我也看的头疼，后来调试的时候发现在本文接下来要讲的内容中，只用到了两个分别是AFURLSessionTaskCompletionHandler和AFURLSessionDownloadTaskDidFinishDownloadingBlock，这两个block都是delegate在完成代理后调用的。说明AFURLSessionManager中的block属性打酱油了，那我就很好奇了，既然是打酱油的那还要它干吗？其实不是，我们先来仔细观察一下它们的名字——objective-c的命名都是见名知意的，这一点我感觉很不错——以本文的下载为例，AFURLSessionDownloadTaskDidFinishDownloadingBlock意：下载任务完成时的block。那我们怎么去使用这个呢？呆会就讲。</p>

<h2 id="正文">正文</h2>

<p>和上一篇一样还是以官方git上的例子看起，源码如下：</p>
<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">NSURLSessionConfiguration</span> <span class="o">*</span><span class="n">configuration</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSURLSessionConfiguration</span> <span class="nf">defaultSessionConfiguration</span><span class="p">];</span>
<span class="n">AFURLSessionManager</span> <span class="o">*</span><span class="n">manager</span> <span class="o">=</span> <span class="p">[[</span><span class="n">AFURLSessionManager</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">initWithSessionConfiguration</span><span class="p">:</span><span class="n">configuration</span><span class="p">];</span>

<span class="n">NSURL</span> <span class="o">*</span><span class="n">URL</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSURL</span> <span class="nf">URLWithString</span><span class="p">:</span><span class="s">@"http://img04.tooopen.com/images/20130701/tooopen_10055061.jpg"</span><span class="p">];</span>
<span class="n">NSURLRequest</span> <span class="o">*</span><span class="n">request</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSURLRequest</span> <span class="nf">requestWithURL</span><span class="p">:</span><span class="n">URL</span><span class="p">];</span>

<span class="n">NSURLSessionDownloadTask</span> <span class="o">*</span><span class="n">downloadTask</span> <span class="o">=</span> <span class="p">[</span><span class="n">manager</span> <span class="nf">downloadTaskWithRequest</span><span class="p">:</span><span class="n">request</span> <span class="nf">progress</span><span class="p">:</span><span class="nb">nil</span> <span class="n">destination</span><span class="o">:^</span><span class="n">NSURL</span> <span class="o">*</span><span class="p">(</span><span class="n">NSURL</span> <span class="o">*</span><span class="n">targetPath</span><span class="p">,</span> <span class="n">NSURLResponse</span> <span class="o">*</span><span class="n">response</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">NSURL</span> <span class="o">*</span><span class="n">documentsDirectoryURL</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSFileManager</span> <span class="nf">defaultManager</span><span class="p">]</span> <span class="nf">URLForDirectory</span><span class="p">:</span><span class="n">NSDocumentDirectory</span> <span class="nf">inDomain</span><span class="p">:</span><span class="n">NSUserDomainMask</span> <span class="n">appropriateForURL</span><span class="o">:</span><span class="nb">nil</span> <span class="n">create</span><span class="o">:</span><span class="nb">NO</span> <span class="n">error</span><span class="o">:</span><span class="nb">nil</span><span class="p">];</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">documentsDirectoryURL</span> <span class="nf">URLByAppendingPathComponent</span><span class="p">:[</span><span class="n">response</span> <span class="nf">suggestedFilename</span><span class="p">]];</span>
<span class="p">}</span> <span class="n">completionHandler</span><span class="o">:^</span><span class="p">(</span><span class="n">NSURLResponse</span> <span class="o">*</span><span class="n">response</span><span class="p">,</span> <span class="n">NSURL</span> <span class="o">*</span><span class="n">filePath</span><span class="p">,</span> <span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"File downloaded to: %@"</span><span class="p">,</span> <span class="n">filePath</span><span class="p">);</span>
    <span class="n">self</span><span class="p">.</span><span class="n">imgView</span><span class="p">.</span><span class="n">image</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIImage</span> <span class="nf">imageWithData</span><span class="p">:[</span><span class="n">NSData</span> <span class="nf">dataWithContentsOfURL</span><span class="p">:</span><span class="n">filePath</span><span class="p">]];</span>

<span class="p">}];</span>
<span class="c1">//以下三行是我添加的，下面三行设置了下载完成后的回调
</span><span class="k">typedef</span> <span class="n">NSURL</span> <span class="o">*</span> <span class="p">(</span><span class="o">^</span><span class="n">DownloadTaskDidFinishDownloadingBlock</span><span class="p">)(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="n">NSURLSessionDownloadTask</span> <span class="o">*</span><span class="n">downloadTask</span><span class="p">,</span> <span class="n">NSURL</span> <span class="o">*</span><span class="n">location</span><span class="p">);</span>

<span class="n">id</span> <span class="n">block</span> <span class="o">=</span> <span class="o">^</span><span class="p">(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="n">NSURLSessionDownloadTask</span> <span class="o">*</span><span class="n">downloadTask</span><span class="p">,</span> <span class="n">NSURL</span> <span class="o">*</span><span class="n">location</span><span class="p">){</span>
    <span class="c1">//doing something
</span>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"%@"</span><span class="p">,</span><span class="n">location</span><span class="p">);</span>
<span class="cm">/*
 * 将上面的打印语句注释掉，改成下面的，再运行一次看看会有什么结果？
    NSURL *documentsDirectoryURL = [[NSFileManager defaultManager] URLForDirectory:NSDocumentDirectory inDomain:NSUserDomainMask appropriateForURL:nil create:NO error:nil]; 
        
    return [documentsDirectoryURL URLByAppendingPathComponent:[downloadTask.response suggestedFilename]];
    */</span>
<span class="p">};</span>
<span class="p">[</span><span class="n">manager</span> <span class="nf">setDownloadTaskDidFinishDownloadingBlock</span><span class="p">:</span><span class="n">block</span><span class="p">];</span>


<span class="p">[</span><span class="n">downloadTask</span> <span class="nf">resume</span><span class="p">];</span>

</code></pre></div></div>
<p>这里我在网上随便找了一张图片，然后还设置了manager的一个AFURLSessionDownloadTaskDidFinishDownloadingBlock，就是刚才说那些打酱油中的block中的一个。在这里只是简单的打印了一下location，并没有返回一个路径，注意哦，这个block要返回一个路径的哦，这个路径是用来存放我们下载的图片的。</p>

<p>这里通过manager实例方法来创建downloadTask:</p>
<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="n">NSURLSessionDownloadTask</span> <span class="o">*</span><span class="p">)</span><span class="nf">downloadTaskWithRequest</span><span class="p">:(</span><span class="n">NSURLRequest</span> <span class="o">*</span><span class="p">)</span><span class="nv">request</span>
                                             <span class="nf">progress</span><span class="p">:(</span><span class="n">NSProgress</span> <span class="o">*</span> <span class="n">__autoreleasing</span> <span class="o">*</span><span class="p">)</span><span class="nv">progress</span>
                                          <span class="nf">destination</span><span class="p">:(</span><span class="n">NSURL</span> <span class="o">*</span> <span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="n">NSURL</span> <span class="o">*</span><span class="n">targetPath</span><span class="p">,</span> <span class="n">NSURLResponse</span> <span class="o">*</span><span class="n">response</span><span class="p">))</span><span class="nv">destination</span>
                                    <span class="nf">completionHandler</span><span class="p">:(</span><span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="n">NSURLResponse</span> <span class="o">*</span><span class="n">response</span><span class="p">,</span> <span class="n">NSURL</span> <span class="o">*</span><span class="n">filePath</span><span class="p">,</span> <span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">))</span><span class="nv">completionHandler</span>
<span class="p">{</span>
    <span class="n">__block</span> <span class="n">NSURLSessionDownloadTask</span> <span class="o">*</span><span class="n">downloadTask</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
    <span class="n">dispatch_sync</span><span class="p">(</span><span class="n">url_session_manager_creation_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
        <span class="n">downloadTask</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">session</span> <span class="nf">downloadTaskWithRequest</span><span class="p">:</span><span class="n">request</span><span class="p">];</span>
    <span class="p">});</span>
    <span class="c1">//这个是用来设置下载代理的
</span>    <span class="p">[</span><span class="n">self</span> <span class="nf">addDelegateForDownloadTask</span><span class="p">:</span><span class="n">downloadTask</span> <span class="nf">progress</span><span class="p">:</span><span class="n">progress</span> <span class="n">destination</span><span class="o">:</span><span class="n">destination</span> <span class="n">completionHandler</span><span class="o">:</span><span class="n">completionHandler</span><span class="p">];</span>

    <span class="k">return</span> <span class="n">downloadTask</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>然后又进入到[NSURLSessionManager addDelegateForDownloadTask:progress:destination:completionHandler]这个函数设置了具体的代理对象，以及下载完成后设置了图片存储路径的block，上一篇的数据请求也会进行这一步，但下载比数据请求多了一些东西，让我们来看看多了什么：</p>
<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">addDelegateForDownloadTask</span><span class="p">:(</span><span class="n">NSURLSessionDownloadTask</span> <span class="o">*</span><span class="p">)</span><span class="nv">downloadTask</span>
                          <span class="nf">progress</span><span class="p">:(</span><span class="n">NSProgress</span> <span class="o">*</span> <span class="n">__autoreleasing</span> <span class="o">*</span><span class="p">)</span><span class="nv">progress</span>
                       <span class="nf">destination</span><span class="p">:(</span><span class="n">NSURL</span> <span class="o">*</span> <span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="n">NSURL</span> <span class="o">*</span><span class="n">targetPath</span><span class="p">,</span> <span class="n">NSURLResponse</span> <span class="o">*</span><span class="n">response</span><span class="p">))</span><span class="nv">destination</span>
                 <span class="nf">completionHandler</span><span class="p">:(</span><span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="n">NSURLResponse</span> <span class="o">*</span><span class="n">response</span><span class="p">,</span> <span class="n">NSURL</span> <span class="o">*</span><span class="n">filePath</span><span class="p">,</span> <span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">))</span><span class="nv">completionHandler</span>
<span class="p">{</span>
    <span class="n">AFURLSessionManagerTaskDelegate</span> <span class="o">*</span><span class="n">delegate</span> <span class="o">=</span> <span class="p">[[</span><span class="n">AFURLSessionManagerTaskDelegate</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">init</span><span class="p">];</span>
    <span class="n">delegate</span><span class="p">.</span><span class="n">manager</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>
    <span class="n">delegate</span><span class="p">.</span><span class="n">completionHandler</span> <span class="o">=</span> <span class="n">completionHandler</span><span class="p">;</span>
<span class="c1">//downloadTaskDidFinishDownloading -&gt; NSURL * (^AFURLSessionDownloadTaskDidFinishDownloadingBlock)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, NSURL *location);
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">destination</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">delegate</span><span class="p">.</span><span class="n">downloadTaskDidFinishDownloading</span> <span class="o">=</span> <span class="o">^</span><span class="n">NSURL</span> <span class="o">*</span> <span class="p">(</span><span class="n">NSURLSession</span> <span class="o">*</span> <span class="n">__unused</span> <span class="n">session</span><span class="p">,</span> <span class="n">NSURLSessionDownloadTask</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="n">NSURL</span> <span class="o">*</span><span class="n">location</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">destination</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">task</span><span class="p">.</span><span class="n">response</span><span class="p">);</span>
        <span class="p">};</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">progress</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">progress</span> <span class="o">=</span> <span class="n">delegate</span><span class="p">.</span><span class="n">progress</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">downloadTask</span><span class="p">.</span><span class="n">taskDescription</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">taskDescriptionForSessionTasks</span><span class="p">;</span>

    <span class="p">[</span><span class="n">self</span> <span class="nf">setDelegate</span><span class="p">:</span><span class="n">delegate</span> <span class="nf">forTask</span><span class="p">:</span><span class="n">downloadTask</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>
<p>和数据请求相比，这里主要多了两个地方一个是设置了下载完成后的回调，一个是设置了下载的进度。这里设置的是delegate相应的回调。函数的最后一句就是保存delegate，这个和数据请求部分一样，不解释了。最后还会调用这个函数：</p>
<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setDownloadTaskDidFinishDownloadingBlock</span><span class="p">:(</span><span class="n">NSURL</span> <span class="o">*</span> <span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="n">NSURLSessionDownloadTask</span> <span class="o">*</span><span class="n">downloadTask</span><span class="p">,</span> <span class="n">NSURL</span> <span class="o">*</span><span class="n">location</span><span class="p">))</span><span class="nv">block</span> <span class="p">{</span>
    <span class="n">self</span><span class="p">.</span><span class="n">downloadTaskDidFinishDownloading</span> <span class="o">=</span> <span class="n">block</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>因为我们之前设置了manager下载完成后的回调就是这句：</p>
<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">manager</span> <span class="nf">setDownloadTaskDidFinishDownloadingBlock</span><span class="p">:</span><span class="n">block</span><span class="p">];</span>
</code></pre></div></div>

<p>现在可以启动downloadTask了。</p>

<p>网络正常的情况以及URL没错的情况下，收到下载的数据后就会调用manager实现的代理方法：</p>
<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//AFURLSessionManager-&gt;NSURLSessionDownloadDelegate-&gt;下载时调用，可能调用多次
</span><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">URLSession</span><span class="p">:(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="p">)</span><span class="nv">session</span>
      <span class="nf">downloadTask</span><span class="p">:(</span><span class="n">NSURLSessionDownloadTask</span> <span class="o">*</span><span class="p">)</span><span class="nv">downloadTask</span>
      <span class="nf">didWriteData</span><span class="p">:(</span><span class="kt">int64_t</span><span class="p">)</span><span class="nv">bytesWritten</span>
 <span class="nf">totalBytesWritten</span><span class="p">:(</span><span class="kt">int64_t</span><span class="p">)</span><span class="nv">totalBytesWritten</span>
<span class="nf">totalBytesExpectedToWrite</span><span class="p">:(</span><span class="kt">int64_t</span><span class="p">)</span><span class="nv">totalBytesExpectedToWrite</span>
<span class="p">{</span>
    <span class="n">AFURLSessionManagerTaskDelegate</span> <span class="o">*</span><span class="n">delegate</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nf">delegateForTask</span><span class="p">:</span><span class="n">downloadTask</span><span class="p">];</span>
    <span class="p">[</span><span class="n">delegate</span> <span class="nf">URLSession</span><span class="p">:</span><span class="n">session</span> <span class="nf">downloadTask</span><span class="p">:</span><span class="n">downloadTask</span> <span class="n">didWriteData</span><span class="o">:</span><span class="n">bytesWritten</span> <span class="n">totalBytesWritten</span><span class="o">:</span><span class="n">totalBytesWritten</span> <span class="n">totalBytesExpectedToWrite</span><span class="o">:</span><span class="n">totalBytesExpectedToWrite</span><span class="p">];</span>
<span class="c1">//downloadTaskDidWriteData - &gt; void (^AFURLSessionDownloadTaskDidWriteDataBlock)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, int64_t bytesWritten, int64_t totalBytesWritten, int64_t totalBytesExpectedToWrite);
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">downloadTaskDidWriteData</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">self</span><span class="p">.</span><span class="n">downloadTaskDidWriteData</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">downloadTask</span><span class="p">,</span> <span class="n">bytesWritten</span><span class="p">,</span> <span class="n">totalBytesWritten</span><span class="p">,</span> <span class="n">totalBytesExpectedToWrite</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>这个函数没什么可以讲主要就是用来计算下载的进度。当下载完成的时候就会进入到这个代理方法中：</p>
<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//AFURLSessionManager-&gt;NSURLSessionDownloadDelegate-&gt;下载完成是调用
</span><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">URLSession</span><span class="p">:(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="p">)</span><span class="nv">session</span>
      <span class="nf">downloadTask</span><span class="p">:(</span><span class="n">NSURLSessionDownloadTask</span> <span class="o">*</span><span class="p">)</span><span class="nv">downloadTask</span>
<span class="nf">didFinishDownloadingToURL</span><span class="p">:(</span><span class="n">NSURL</span> <span class="o">*</span><span class="p">)</span><span class="nv">location</span>
<span class="p">{</span>
    <span class="n">AFURLSessionManagerTaskDelegate</span> <span class="o">*</span><span class="n">delegate</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nf">delegateForTask</span><span class="p">:</span><span class="n">downloadTask</span><span class="p">];</span>
<span class="c1">//downloadTaskDidFinishDownloading -&gt; NSURL * (^AFURLSessionDownloadTaskDidFinishDownloadingBlock)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, NSURL *location);
</span>    <span class="c1">//下载的时候这个block没有用
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">downloadTaskDidFinishDownloading</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">NSURL</span> <span class="o">*</span><span class="n">fileURL</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">downloadTaskDidFinishDownloading</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">downloadTask</span><span class="p">,</span> <span class="n">location</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fileURL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">delegate</span><span class="p">.</span><span class="n">downloadFileURL</span> <span class="o">=</span> <span class="n">fileURL</span><span class="p">;</span>
            <span class="n">NSError</span> <span class="o">*</span><span class="n">error</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
            <span class="p">[[</span><span class="n">NSFileManager</span> <span class="nf">defaultManager</span><span class="p">]</span> <span class="nf">moveItemAtURL</span><span class="p">:</span><span class="n">location</span> <span class="nf">toURL</span><span class="p">:</span><span class="n">fileURL</span> <span class="n">error</span><span class="o">:&amp;</span><span class="n">error</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
                <span class="p">[[</span><span class="n">NSNotificationCenter</span> <span class="nf">defaultCenter</span><span class="p">]</span> <span class="nf">postNotificationName</span><span class="p">:</span><span class="n">AFURLSessionDownloadTaskDidFailToMoveFileNotification</span> <span class="nf">object</span><span class="p">:</span><span class="n">downloadTask</span> <span class="n">userInfo</span><span class="o">:</span><span class="n">error</span><span class="p">.</span><span class="n">userInfo</span><span class="p">];</span>
            <span class="p">}</span>

            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">delegate</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">[</span><span class="n">delegate</span> <span class="nf">URLSession</span><span class="p">:</span><span class="n">session</span> <span class="nf">downloadTask</span><span class="p">:</span><span class="n">downloadTask</span> <span class="n">didFinishDownloadingToURL</span><span class="o">:</span><span class="n">location</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>这里有一个重点，单步执行的时候会发现，程序会进入到第一个if里面。还记得在开头的例子中我加了三行代码：</p>
<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="n">NSURL</span> <span class="o">*</span> <span class="p">(</span><span class="o">^</span><span class="n">DownloadTaskDidFinishDownloadingBlock</span><span class="p">)(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="n">NSURLSessionDownloadTask</span> <span class="o">*</span><span class="n">downloadTask</span><span class="p">,</span> <span class="n">NSURL</span> <span class="o">*</span><span class="n">location</span><span class="p">);</span>

<span class="n">id</span> <span class="n">block</span> <span class="o">=</span> <span class="o">^</span><span class="p">(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="n">NSURLSessionDownloadTask</span> <span class="o">*</span><span class="n">downloadTask</span><span class="p">,</span> <span class="n">NSURL</span> <span class="o">*</span><span class="n">location</span><span class="p">){</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"%@"</span><span class="p">,</span><span class="n">location</span><span class="p">);</span>
<span class="p">};</span>
<span class="p">[</span><span class="n">manager</span> <span class="nf">setDownloadTaskDidFinishDownloadingBlock</span><span class="p">:</span><span class="n">block</span><span class="p">];</span>
</code></pre></div></div>
<p>这三行设置了manager的downloadTaskDidFinishDownloading属性，它是下载完成后的一个回调，它要求返回一个URL用来存放下载的图片，如果在这个block里返回了一个URL那么它会进入到第一个if里去，并且执行完就返回了。图片也就保存到了返回的这个URL了，后面的代码就不会执行了，如果没有返回一个URL的话，程序就是把下载的图片保存到这里：</p>
<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//这是例子开头我们设置的用来保存图片的URL,如果我们设置了managerr的downloadTaskDidFinishDownloading属性并且同时在这个block里返回了一个URL那么下面这两行代码就不会执行了，因为已经有保存图片的URL了。只有block里没有返回URL下面的代码才会执行
</span><span class="n">NSURL</span> <span class="o">*</span><span class="n">documentsDirectoryURL</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSFileManager</span> <span class="nf">defaultManager</span><span class="p">]</span> <span class="nf">URLForDirectory</span><span class="p">:</span><span class="n">NSDocumentDirectory</span> <span class="nf">inDomain</span><span class="p">:</span><span class="n">NSUserDomainMask</span> <span class="n">appropriateForURL</span><span class="o">:</span><span class="nb">nil</span> <span class="n">create</span><span class="o">:</span><span class="nb">NO</span> <span class="n">error</span><span class="o">:</span><span class="nb">nil</span><span class="p">];</span>

<span class="k">return</span> <span class="p">[</span><span class="n">documentsDirectoryURL</span> <span class="nf">URLByAppendingPathComponent</span><span class="p">:[</span><span class="n">response</span> <span class="nf">suggestedFilename</span><span class="p">]];</span>
</code></pre></div></div>
<p>上面的这两行代码是在这个代理方法里调用的：</p>
<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//AFURLSessionManagerTaskDelegate-&gt;NSURLSessionTaskDelegate-&gt;下载完成时调用
</span><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">URLSession</span><span class="p">:(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="p">)</span><span class="nv">session</span>
      <span class="nf">downloadTask</span><span class="p">:(</span><span class="n">NSURLSessionDownloadTask</span> <span class="o">*</span><span class="p">)</span><span class="nv">downloadTask</span>
<span class="nf">didFinishDownloadingToURL</span><span class="p">:(</span><span class="n">NSURL</span> <span class="o">*</span><span class="p">)</span><span class="nv">location</span>
<span class="p">{</span>
    <span class="n">NSError</span> <span class="o">*</span><span class="n">fileManagerError</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
    <span class="n">self</span><span class="p">.</span><span class="n">downloadFileURL</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
<span class="c1">//downloadTaskDidFinishDownloading -&gt; NSURL * (^AFURLSessionDownloadTaskDidFinishDownloadingBlock)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, NSURL *location);
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">downloadTaskDidFinishDownloading</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">//下载完成时调用block
</span>        <span class="n">self</span><span class="p">.</span><span class="n">downloadFileURL</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">downloadTaskDidFinishDownloading</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">downloadTask</span><span class="p">,</span> <span class="n">location</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">downloadFileURL</span><span class="p">)</span> <span class="p">{</span>
            <span class="p">[[</span><span class="n">NSFileManager</span> <span class="nf">defaultManager</span><span class="p">]</span> <span class="nf">moveItemAtURL</span><span class="p">:</span><span class="n">location</span> <span class="nf">toURL</span><span class="p">:</span><span class="n">self</span><span class="p">.</span><span class="n">downloadFileURL</span> <span class="n">error</span><span class="o">:&amp;</span><span class="n">fileManagerError</span><span class="p">];</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">fileManagerError</span><span class="p">)</span> <span class="p">{</span>
                <span class="p">[[</span><span class="n">NSNotificationCenter</span> <span class="nf">defaultCenter</span><span class="p">]</span> <span class="nf">postNotificationName</span><span class="p">:</span><span class="n">AFURLSessionDownloadTaskDidFailToMoveFileNotification</span> <span class="nf">object</span><span class="p">:</span><span class="n">downloadTask</span> <span class="n">userInfo</span><span class="o">:</span><span class="n">fileManagerError</span><span class="p">.</span><span class="n">userInfo</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>这里需要注意的是这个downloadTaskDidFinishDownloading是delegate里的和manager里的不一样，不要被迷惑了。这个block返回URL，往下执行就是把图片保存在这个URL上了。这个block是不是不知道我们什么时候设置的了。写了这么我，我也差一点忘记了。它是在这个[AFURLSessionMananger addDelegateForDownloadTask:progress:destination:completionHandler:]函数里设置的，注意里面的这一行代码：</p>
<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">destination</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">delegate</span><span class="p">.</span><span class="n">downloadTaskDidFinishDownloading</span> <span class="o">=</span> <span class="o">^</span><span class="n">NSURL</span> <span class="o">*</span> <span class="p">(</span><span class="n">NSURLSession</span> <span class="o">*</span> <span class="n">__unused</span> <span class="n">session</span><span class="p">,</span> <span class="n">NSURLSessionDownloadTask</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="n">NSURL</span> <span class="o">*</span><span class="n">location</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">destination</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">task</span><span class="p">.</span><span class="n">response</span><span class="p">);</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>
<p>block的用法有没有很神奇它竟然捕获从最外面传进来的destination，并且保存到现在，而且现在要执行它来返回图片要保存的URL。</p>

<p>到这里基本也就快结束了，执行完，就会进入这个[AFURLSessionManagerTaskDelegate URLSession:task:didCompleteWithError:]函数里了，这一步和数据请求没有什么区别。经过这么多调用，图片也就下载完了。前面设置manager的downloadTaskDidFinishDownloading属性，这个个人认为可以用来返回指定的URL，也可以用来做一些，下载完成后的后续处理工作。</p>

<p>—EOF—</p>


                    ]]>
                </content:encoded>
                <guid isPermaLink="false">/objective-c/afnetworking/2017/05/05/AFNetworking3.0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%95%B0%E6%8D%AE%E4%B8%8B%E8%BD%BD/</guid>
                <description>
                    
                    本文主要分析AFNetworking的下载请求部分。
                    
                </description>
                <pubDate>Fri, 05 May 2017 00:00:00 +0800</pubDate>
                <author>冬阳</author>
            </item>
        
    
        
            <item>
                <title>AFNetworking3.0源码解读之数据请求</title>
                <link>http://localhost:4000/objective-c/afnetworking/2017/05/03/AFNetworking3.0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82/</link>
                <content:encoded>
                    <![CDATA[
                    <p>标签： objective-c AFNetworking</p>

<hr />

<h3 id="前言">前言</h3>

<p>无论做什么开发，都避免不了和网络打交道。在iOS中，网络请求这一块，大家肯定用过AFNetworking库。那么它到底是怎么实现的呢？本文主要讲它的数据请求部分，在以后博客中，会慢慢讲解其他部分。网上其实已经有很多相关的博客了，有些写的更好，写这篇博客的原因也是为了方便记下自己在看一些开源库的代码时学习到的编程技法、编程思想和问题的解决方案。</p>

<h3 id="正文">正文</h3>
<p>先从AFURLSessionManager开始，可以说它是整个库的核心，后面的AFHTTPSessionManager是就继承自AFURLSessionManager类。AFURLSessionManager类主要是对NSURLSession还有相关代理协议的封装。这个类对用户暴露的接口很少，在实现文件里定义了大量的私有方法，此外还对AFURLSessionManager进行了扩展。进行入AFURLSessionManager.m文件内看可以看到这样的结构：
<img src="/images/AFURLSessionManager类的结构图.png" alt="AFURLSessionManager类结构图" /></p>

<p>在实现文件里，AFURLSessionManager.m里定义了两个类，一个类是AFURLSessionManagerTaskDelegate，还有一个就是_AFURLSessionTaskSwizzling。</p>

<p>AFURLSessionManagerTaskDelegate这个类从名字上看就知道，它是用来实现代理的，所有的网络请求回调都是经过它。呆会通过一个实际的例子来的说明。</p>

<p>那么_AFURLSessionTaskSwizzling类是用来干吗的呢？在写这篇博客的时候，我还没有通过例子实际的使用过，不过它的源码很少，通过看原码和注释大概知道，它是用来进行方法调配，使用了系统的运行期系统来交换两个方法的实现。注释中提到NSURLSessionTask的实现是通过class cluster来实现的，也就是说我们创建的一个NSURLSessionTask对象，并不是真正的创建这个对象而是创建了一个名字叫__NSCFLocalDataTask。这个类只干了一件了，那就是对任务的<code class="highlighter-rouge">resume</code>和<code class="highlighter-rouge">suspend</code>进行了交换，目的可能就是要实现任务的暂停和恢复的功能。对这个类先说这么点点个人理解吧。</p>

<p>接下来，以官方给出的例子跟踪一下，它的调用过程以下是源码：</p>
<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">NSURLSessionConfiguration</span> <span class="o">*</span><span class="n">configuration</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSURLSessionConfiguration</span> <span class="nf">defaultSessionConfiguration</span><span class="p">];</span>
<span class="n">AFURLSessionManager</span> <span class="o">*</span><span class="n">manager</span> <span class="o">=</span> <span class="p">[[</span><span class="n">AFURLSessionManager</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">initWithSessionConfiguration</span><span class="p">:</span><span class="n">configuration</span><span class="p">];</span>

<span class="n">manager</span><span class="p">.</span><span class="n">responseSerializer</span> <span class="o">=</span> <span class="p">[</span><span class="n">AFHTTPResponseSerializer</span> <span class="nf">serializer</span><span class="p">];</span>
<span class="n">NSURL</span> <span class="o">*</span><span class="n">URL</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSURL</span> <span class="nf">URLWithString</span><span class="p">:</span><span class="s">@"http://www.baidu.com"</span><span class="p">];</span>
<span class="n">NSURLRequest</span> <span class="o">*</span><span class="n">request</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSURLRequest</span> <span class="nf">requestWithURL</span><span class="p">:</span><span class="n">URL</span><span class="p">];</span>

<span class="n">NSURLSessionDataTask</span> <span class="o">*</span><span class="n">dataTask</span> <span class="o">=</span> <span class="p">[</span><span class="n">manager</span> <span class="nf">dataTaskWithRequest</span><span class="p">:</span><span class="n">request</span> <span class="nf">completionHandler</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">NSURLResponse</span> <span class="o">*</span><span class="n">response</span><span class="p">,</span> <span class="n">id</span> <span class="n">responseObject</span><span class="p">,</span> <span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@"Error: %@"</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        
        <span class="n">NSString</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSString</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">initWithData</span><span class="p">:</span><span class="n">responseObject</span>  <span class="nf">encoding</span><span class="p">:</span><span class="n">NSUTF8StringEncoding</span><span class="p">];</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@"%@"</span><span class="p">,[</span><span class="n">responseObject</span> <span class="nf">class</span><span class="p">]);</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@"%@"</span><span class="p">,</span><span class="n">result</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}];</span>
<span class="p">[</span><span class="n">dataTask</span> <span class="nf">resume</span><span class="p">];</span>
</code></pre></div></div>
<p>该代码核心只有两句一个是manager的初始化还有一个就是dataTask的创建。先来看看初始化：</p>
<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="nf">initWithSessionConfiguration</span><span class="p">:(</span><span class="n">NSURLSessionConfiguration</span> <span class="o">*</span><span class="p">)</span><span class="nv">configuration</span> <span class="p">{</span>
    <span class="n">self</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="nf">init</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">nil</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">configuration</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">configuration</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSURLSessionConfiguration</span> <span class="nf">defaultSessionConfiguration</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="n">self</span><span class="p">.</span><span class="n">sessionConfiguration</span> <span class="o">=</span> <span class="n">configuration</span><span class="p">;</span><span class="c1">//默认配置
</span>
    <span class="n">self</span><span class="p">.</span><span class="n">operationQueue</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSOperationQueue</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">init</span><span class="p">];</span>
    <span class="n">self</span><span class="p">.</span><span class="n">operationQueue</span><span class="p">.</span><span class="n">maxConcurrentOperationCount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="c1">//最大并发数，此处应该当成串行队列来用了
</span>
    <span class="n">self</span><span class="p">.</span><span class="n">session</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSURLSession</span> <span class="nf">sessionWithConfiguration</span><span class="p">:</span><span class="n">self</span><span class="p">.</span><span class="n">sessionConfiguration</span> <span class="nf">delegate</span><span class="p">:</span><span class="n">self</span> <span class="n">delegateQueue</span><span class="o">:</span><span class="n">self</span><span class="p">.</span><span class="n">operationQueue</span><span class="p">];</span><span class="c1">//创建session，设置代理对象
</span>
    <span class="n">self</span><span class="p">.</span><span class="n">responseSerializer</span> <span class="o">=</span> <span class="p">[</span><span class="n">AFJSONResponseSerializer</span> <span class="nf">serializer</span><span class="p">];</span><span class="c1">//默认的解析器
</span>
    <span class="n">self</span><span class="p">.</span><span class="n">securityPolicy</span> <span class="o">=</span> <span class="p">[</span><span class="n">AFSecurityPolicy</span> <span class="nf">defaultPolicy</span><span class="p">];</span>

<span class="cp">#if !TARGET_OS_WATCH
</span>    <span class="n">self</span><span class="p">.</span><span class="n">reachabilityManager</span> <span class="o">=</span> <span class="p">[</span><span class="n">AFNetworkReachabilityManager</span> <span class="nf">sharedManager</span><span class="p">];</span>
<span class="cp">#endif
</span>
    <span class="n">self</span><span class="p">.</span><span class="n">mutableTaskDelegatesKeyedByTaskIdentifier</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSMutableDictionary</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">init</span><span class="p">];</span>

    <span class="n">self</span><span class="p">.</span><span class="n">lock</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSLock</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">init</span><span class="p">];</span>
    <span class="n">self</span><span class="p">.</span><span class="n">lock</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">AFURLSessionManagerLockName</span><span class="p">;</span>

    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">session</span> <span class="nf">getTasksWithCompletionHandler</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">NSArray</span> <span class="o">*</span><span class="n">dataTasks</span><span class="p">,</span> <span class="n">NSArray</span> <span class="o">*</span><span class="n">uploadTasks</span><span class="p">,</span> <span class="n">NSArray</span> <span class="o">*</span><span class="n">downloadTasks</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">NSURLSessionDataTask</span> <span class="o">*</span><span class="n">task</span> <span class="k">in</span> <span class="n">dataTasks</span><span class="p">)</span> <span class="p">{</span>
            <span class="p">[</span><span class="n">self</span> <span class="nf">addDelegateForDataTask</span><span class="p">:</span><span class="n">task</span> <span class="nf">completionHandler</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">NSURLSessionUploadTask</span> <span class="o">*</span><span class="n">uploadTask</span> <span class="k">in</span> <span class="n">uploadTasks</span><span class="p">)</span> <span class="p">{</span>
            <span class="p">[</span><span class="n">self</span> <span class="nf">addDelegateForUploadTask</span><span class="p">:</span><span class="n">uploadTask</span> <span class="nf">progress</span><span class="p">:</span><span class="nb">nil</span> <span class="n">completionHandler</span><span class="o">:</span><span class="nb">nil</span><span class="p">];</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">NSURLSessionDownloadTask</span> <span class="o">*</span><span class="n">downloadTask</span> <span class="k">in</span> <span class="n">downloadTasks</span><span class="p">)</span> <span class="p">{</span>
            <span class="p">[</span><span class="n">self</span> <span class="nf">addDelegateForDownloadTask</span><span class="p">:</span><span class="n">downloadTask</span> <span class="nf">progress</span><span class="p">:</span><span class="nb">nil</span> <span class="n">destination</span><span class="o">:</span><span class="nb">nil</span> <span class="n">completionHandler</span><span class="o">:</span><span class="nb">nil</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}];</span>

    <span class="p">[[</span><span class="n">NSNotificationCenter</span> <span class="nf">defaultCenter</span><span class="p">]</span> <span class="nf">addObserver</span><span class="p">:</span><span class="n">self</span> <span class="nf">selector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">taskDidResume</span><span class="o">:</span><span class="p">)</span> <span class="n">name</span><span class="o">:</span><span class="n">AFNSURLSessionTaskDidResumeNotification</span> <span class="n">object</span><span class="o">:</span><span class="nb">nil</span><span class="p">];</span>
    <span class="p">[[</span><span class="n">NSNotificationCenter</span> <span class="nf">defaultCenter</span><span class="p">]</span> <span class="nf">addObserver</span><span class="p">:</span><span class="n">self</span> <span class="nf">selector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">taskDidSuspend</span><span class="o">:</span><span class="p">)</span> <span class="n">name</span><span class="o">:</span><span class="n">AFNSURLSessionTaskDidSuspendNotification</span> <span class="n">object</span><span class="o">:</span><span class="nb">nil</span><span class="p">];</span>

    <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>看起来好多，对我们本次的目的其实需要关心的东西很少，我都给出来了注释。</p>

<p>第二处是dataTask的创建，为了说明，先把程序跑起来看看函数的调用栈。任务一启动，首先进入到了[AFURLSessionManager dataTaskWithRequest:completionHandler:]函数中：</p>
<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="n">NSURLSessionDataTask</span> <span class="o">*</span><span class="p">)</span><span class="nf">dataTaskWithRequest</span><span class="p">:(</span><span class="n">NSURLRequest</span> <span class="o">*</span><span class="p">)</span><span class="nv">request</span>
                            <span class="nf">completionHandler</span><span class="p">:(</span><span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="n">NSURLResponse</span> <span class="o">*</span><span class="n">response</span><span class="p">,</span> <span class="n">id</span> <span class="n">responseObject</span><span class="p">,</span> <span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">))</span><span class="nv">completionHandler</span>
<span class="p">{</span>
    <span class="n">__block</span> <span class="n">NSURLSessionDataTask</span> <span class="o">*</span><span class="n">dataTask</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
    <span class="n">dispatch_sync</span><span class="p">(</span><span class="n">url_session_manager_creation_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
        <span class="n">dataTask</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">session</span> <span class="nf">dataTaskWithRequest</span><span class="p">:</span><span class="n">request</span><span class="p">];</span>
    <span class="p">});</span>

    <span class="p">[</span><span class="n">self</span> <span class="nf">addDelegateForDataTask</span><span class="p">:</span><span class="n">dataTask</span> <span class="nf">completionHandler</span><span class="p">:</span><span class="n">completionHandler</span><span class="p">];</span>

    <span class="k">return</span> <span class="n">dataTask</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>函数体内主要是在一个GCD队列里创建dataTask，此处用到的是GCD同步API。然后调用了第一个私有方法[AFURLSessionManager addDelegateForDataTask:completionHandler:]来设置dataTask的代理和回调的block:</p>
<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">addDelegateForDataTask</span><span class="p">:(</span><span class="n">NSURLSessionDataTask</span> <span class="o">*</span><span class="p">)</span><span class="nv">dataTask</span>
             <span class="nf">completionHandler</span><span class="p">:(</span><span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="n">NSURLResponse</span> <span class="o">*</span><span class="n">response</span><span class="p">,</span> <span class="n">id</span> <span class="n">responseObject</span><span class="p">,</span> <span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">))</span><span class="nv">completionHandler</span>
<span class="p">{</span>
    <span class="n">AFURLSessionManagerTaskDelegate</span> <span class="o">*</span><span class="n">delegate</span> <span class="o">=</span> <span class="p">[[</span><span class="n">AFURLSessionManagerTaskDelegate</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">init</span><span class="p">];</span>
    <span class="n">delegate</span><span class="p">.</span><span class="n">manager</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>
    <span class="n">delegate</span><span class="p">.</span><span class="n">completionHandler</span> <span class="o">=</span> <span class="n">completionHandler</span><span class="p">;</span>

    <span class="n">dataTask</span><span class="p">.</span><span class="n">taskDescription</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">taskDescriptionForSessionTasks</span><span class="p">;</span>
    
    <span class="p">[</span><span class="n">self</span> <span class="nf">setDelegate</span><span class="p">:</span><span class="n">delegate</span> <span class="nf">forTask</span><span class="p">:</span><span class="n">dataTask</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>
<p>在这个函数内真正的设置了网络的代理，就是刚才提到的AFURLSessionManagerTaskDelegate类，这里有一个小细节需要注意一下，就是这一行<code class="highlighter-rouge">delegate.manager = self</code>，在该函数内定义了一个delegate并且持有了manager,而在AFURLSessionManagerTaskDelegate定义中声明了一个AFURLSessionManager对象manager。这就是说delegate持有了manager，manager持有了delegate，循环引用的问题就出来了，这里的解决方法是通过将AFURLSessionManagerTaskDelegate中的manager属性的内存管理语义声明为weak。我们看一下，该类的声明就知道了。</p>
<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">@interface</span> <span class="nc">AFURLSessionManagerTaskDelegate</span> <span class="p">:</span> <span class="nc">NSObject</span> <span class="o">&lt;</span><span class="n">NSURLSessionTaskDelegate</span><span class="p">,</span> <span class="n">NSURLSessionDataDelegate</span><span class="p">,</span> <span class="n">NSURLSessionDownloadDelegate</span><span class="o">&gt;</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">weak</span><span class="p">)</span> <span class="n">AFURLSessionManager</span> <span class="o">*</span><span class="n">manager</span><span class="p">;</span><span class="c1">//内存管理语义为weak
</span><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">strong</span><span class="p">)</span> <span class="n">NSMutableData</span> <span class="o">*</span><span class="n">mutableData</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">strong</span><span class="p">)</span> <span class="n">NSProgress</span> <span class="o">*</span><span class="n">progress</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">copy</span><span class="p">)</span> <span class="n">NSURL</span> <span class="o">*</span><span class="n">downloadFileURL</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">copy</span><span class="p">)</span> <span class="n">AFURLSessionDownloadTaskDidFinishDownloadingBlock</span> <span class="n">downloadTaskDidFinishDownloading</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">copy</span><span class="p">)</span> <span class="n">AFURLSessionTaskCompletionHandler</span> <span class="n">completionHandler</span><span class="p">;</span>
<span class="k">@end</span>
</code></pre></div></div>

<p>接着上面的说，接下来函数的调用栈就进入了[AFURLSessionManager setDelegate:dataTask:]。</p>
<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setDelegate</span><span class="p">:(</span><span class="n">AFURLSessionManagerTaskDelegate</span> <span class="o">*</span><span class="p">)</span><span class="nv">delegate</span>
            <span class="nf">forTask</span><span class="p">:(</span><span class="n">NSURLSessionTask</span> <span class="o">*</span><span class="p">)</span><span class="nv">task</span>
<span class="p">{</span>
    <span class="n">NSParameterAssert</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
    <span class="n">NSParameterAssert</span><span class="p">(</span><span class="n">delegate</span><span class="p">);</span>

    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">lock</span> <span class="nf">lock</span><span class="p">];</span>
    <span class="n">self</span><span class="p">.</span><span class="n">mutableTaskDelegatesKeyedByTaskIdentifier</span><span class="p">[</span><span class="err">@</span><span class="p">(</span><span class="n">task</span><span class="p">.</span><span class="n">taskIdentifier</span><span class="p">)]</span> <span class="o">=</span> <span class="n">delegate</span><span class="p">;</span>
    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">lock</span> <span class="nf">unlock</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>
<p>这个函数是用来干吗的呢？还加了锁。从代码上看，就是保存task的代理。</p>

<p>至此，所有的准备工作都做完了只等我们去启动这个任务了。没错，就是通过这一句<code class="highlighter-rouge">[dataTask resume]</code>。写到这，先来总结一下，这些准备工作的函数调用过程，直接甩图了：
<img src="/images/调用过程.png" alt="调用过程" /></p>

<p>接下来就是代理了，代理的过程是这样的，AFURLSessionManager自己实现了代理协议，但是在代理协议方法中，根据dataTask的taskIdentifier找到相应的delegate对象，把具体代理该做的事，交给这个delegate。任务启动后第一个调用的是AFURLSessionManager这个函数：</p>
<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//这是AFURLSessionManager类的方法
</span><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">URLSession</span><span class="p">:(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="p">)</span><span class="nv">session</span>
          <span class="nf">dataTask</span><span class="p">:(</span><span class="n">NSURLSessionDataTask</span> <span class="o">*</span><span class="p">)</span><span class="nv">dataTask</span>
    <span class="nf">didReceiveData</span><span class="p">:(</span><span class="n">NSData</span> <span class="o">*</span><span class="p">)</span><span class="nv">data</span>
<span class="p">{</span>
    <span class="n">AFURLSessionManagerTaskDelegate</span> <span class="o">*</span><span class="n">delegate</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nf">delegateForTask</span><span class="p">:</span><span class="n">dataTask</span><span class="p">];</span>
    <span class="p">[</span><span class="n">delegate</span> <span class="nf">URLSession</span><span class="p">:</span><span class="n">session</span> <span class="nf">dataTask</span><span class="p">:</span><span class="n">dataTask</span> <span class="n">didReceiveData</span><span class="o">:</span><span class="n">data</span><span class="p">];</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">dataTaskDidReceiveData</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">self</span><span class="p">.</span><span class="n">dataTaskDidReceiveData</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">dataTask</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>可以看出它把delegate取出来之后就转到AFURLSessionManagerTaskDelegate类中去了，调用了AFURLSessionManagerTaskDelegate同名方法。</p>
<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//这是AFURLSessionManagerTaskDelegate类的方法
</span><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">URLSession</span><span class="p">:(</span><span class="n">__unused</span> <span class="n">NSURLSession</span> <span class="o">*</span><span class="p">)</span><span class="nv">session</span>
          <span class="nf">dataTask</span><span class="p">:(</span><span class="n">__unused</span> <span class="n">NSURLSessionDataTask</span> <span class="o">*</span><span class="p">)</span><span class="nv">dataTask</span>
    <span class="nf">didReceiveData</span><span class="p">:(</span><span class="n">NSData</span> <span class="o">*</span><span class="p">)</span><span class="nv">data</span>
<span class="p">{</span>
    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">mutableData</span> <span class="nf">appendData</span><span class="p">:</span><span class="n">data</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>
<p>上面的这个函数才是真正干事的，AFURLSessionManager类中的同名方法只是打了一个酱油。当请求结束的时候，同样首先会调用AFURLSessionManager中的方法：</p>
<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//这是AFURLSessionManager类的方法
</span><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">URLSession</span><span class="p">:(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="p">)</span><span class="nv">session</span>
              <span class="nf">task</span><span class="p">:(</span><span class="n">NSURLSessionTask</span> <span class="o">*</span><span class="p">)</span><span class="nv">task</span>
<span class="nf">didCompleteWithError</span><span class="p">:(</span><span class="n">NSError</span> <span class="o">*</span><span class="p">)</span><span class="nv">error</span>
<span class="p">{</span>
    <span class="n">AFURLSessionManagerTaskDelegate</span> <span class="o">*</span><span class="n">delegate</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nf">delegateForTask</span><span class="p">:</span><span class="n">task</span><span class="p">];</span>

    <span class="c1">// delegate may be nil when completing a task in the background
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">delegate</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">[</span><span class="n">delegate</span> <span class="nf">URLSession</span><span class="p">:</span><span class="n">session</span> <span class="nf">task</span><span class="p">:</span><span class="n">task</span> <span class="n">didCompleteWithError</span><span class="o">:</span><span class="n">error</span><span class="p">];</span>

        <span class="p">[</span><span class="n">self</span> <span class="nf">removeDelegateForTask</span><span class="p">:</span><span class="n">task</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">taskDidComplete</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">self</span><span class="p">.</span><span class="n">taskDidComplete</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
    <span class="p">}</span>

<span class="p">}</span>
</code></pre></div></div>
<p>真正干事的还是AFURLSessionManagerTaskDelegate类中的同名方法。这里给出这个方法的部分代码：</p>
<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//在没有错误的时候就执行这一段代码
</span><span class="n">dispatch_async</span><span class="p">(</span><span class="n">url_session_manager_processing_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
    <span class="n">NSError</span> <span class="o">*</span><span class="n">serializationError</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
    <span class="n">responseObject</span> <span class="o">=</span> <span class="p">[</span><span class="n">manager</span><span class="p">.</span><span class="n">responseSerializer</span> <span class="nf">responseObjectForResponse</span><span class="p">:</span><span class="n">task</span><span class="p">.</span><span class="n">response</span> <span class="nf">data</span><span class="p">:</span><span class="n">data</span> <span class="n">error</span><span class="o">:&amp;</span><span class="n">serializationError</span><span class="p">];</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">downloadFileURL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">responseObject</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">downloadFileURL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">responseObject</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">userInfo</span><span class="p">[</span><span class="nf">AFNetworkingTaskDidCompleteSerializedResponseKey</span><span class="p">]</span> <span class="o">=</span> <span class="n">responseObject</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">serializationError</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">userInfo</span><span class="p">[</span><span class="nf">AFNetworkingTaskDidCompleteErrorKey</span><span class="p">]</span> <span class="o">=</span> <span class="n">serializationError</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//这是真正干事的
</span>    <span class="n">dispatch_group_async</span><span class="p">(</span><span class="n">manager</span><span class="p">.</span><span class="n">completionGroup</span> <span class="p">?:</span> <span class="n">url_session_manager_completion_group</span><span class="p">(),</span> <span class="n">manager</span><span class="p">.</span><span class="n">completionQueue</span> <span class="p">?:</span> <span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
    	<span class="c1">//执行completionHandler，把取到的数据传到外面去，这里的responseObject就是我们请求到的数据
</span>        <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">completionHandler</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">self</span><span class="p">.</span><span class="n">completionHandler</span><span class="p">(</span><span class="n">task</span><span class="p">.</span><span class="n">response</span><span class="p">,</span> <span class="n">responseObject</span><span class="p">,</span> <span class="n">serializationError</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
            <span class="p">[[</span><span class="n">NSNotificationCenter</span> <span class="nf">defaultCenter</span><span class="p">]</span> <span class="nf">postNotificationName</span><span class="p">:</span><span class="n">AFNetworkingTaskDidCompleteNotification</span> <span class="nf">object</span><span class="p">:</span><span class="n">task</span> <span class="n">userInfo</span><span class="o">:</span><span class="n">userInfo</span><span class="p">];</span>
        <span class="p">});</span>
    <span class="p">});</span>
<span class="p">});</span>

</code></pre></div></div>
<p>至此整个代理过程就结束了。其中有一个地方值得注意一下，那就是每用manager创建一个task时，manager都会以task的taskIdentifier属性为key，以delegate为value存入字典中。这样的做的目的应该是一个manager可以管理多个task。</p>

<p>—EOF—</p>


                    ]]>
                </content:encoded>
                <guid isPermaLink="false">/objective-c/afnetworking/2017/05/03/AFNetworking3.0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82/</guid>
                <description>
                    
                    本文主要分析AFNetworking的数据请求部分。
                    
                </description>
                <pubDate>Wed, 03 May 2017 00:00:00 +0800</pubDate>
                <author>冬阳</author>
            </item>
        
    
  </channel>
</rss>
